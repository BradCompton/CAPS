    ∇ M CSE_BUFFERS P;K;H;B;E;O;G;W;Q;L;C;F;V;A;T;D;J;Z;head;S;U;R;N;Rh;I;V2;P2[1]   ⍝Create mask for scenario #1⊃⍵ in path 2⊃⍵, with joint mask path 3⊃⍵, metric table 1⊃⍺ and grid table 2⊃⍺[2]   ⍝Global:[3]   ⍝   csb         scenario table[4]   ⍝   wbuffer     tiny watershed buffer[5]   ⍝   landgrids   grids that are treated as landcover rather than settings[6]   ⍝   bw, tw      watershed tables for internal use, read here and kept for future calls[7]   ⍝               (use special bigwatersheds4csb.txt with MER for entire watershed, despite subs)[8]   ⍝Set changed for text description in report:[9]   ⍝   changed[J;1]   (town ids)[10]  ⍝   changed[J;2]   [n] changes to culverts/bridges[11]  ⍝   changed[J;3]   [n] changes to dams[12]  ⍝   changed[J;4]   [n] changes to terrestrial passage structures[13]  ⍝   changed[J;5]   [n] changes tidal restrictions[14]  ⍝   changed[J;6]   [n] miles of new roads[15]  ⍝   changed[J;7]   approximately [n] miles of modified roads        * done in CSE_MODIFY[16]  ⍝   changed[J;8]   [n] acres of landcover change to [x]             * done in CSE_MODIFY[17]  ⍝   changed[J;9]   [x] (new landcover type)                         * done in CSE_MODIFY[18]  ⍝   changed[J;10]  [n] (mitigation discount for landcover change)   * done in CSE_MODIFY[19]  ⍝B. Compton, 15-20 Aug 2012, pulled from CSE and rewritten for multiple buffers[20]  ⍝23 May 2013: take just watershed features fall in, not watersheds in feature's MER[21]  ⍝4-6 Jun 2013: drop any big watersheds/big TR watersheds we're not doing from tables[22]  ⍝13 Jun 2013: edit big lakes table too. I'm looking for overlapping MERs, so we'll get a few false positives, which is okay[23]  ⍝20 Jun 2013: keep subwatersheds of big ones we're keeping[24]  ⍝10 Jul 2013: write joint mask[25]  [26]  [27]  [28]   J P P2 ← P[29]   M D ← M[30]   K←Z←0[31]  [32]   changed[J;2 3 4 5]←+⌿csb[;csb_ COL 'type']∘.≡FRDBL¨↓MATRIFY 'crossing dam wildlife tr'                     ⍝Count number of culverts, dams, wildlife crossings, and trs[33]   changed[J;6]←0.000621371×+/LINELENGTH¨(csb[;csb_ COL 'type']≡¨⊂'newroad')/csb[;csb_ COL 'spatial']         ⍝miles of new roads[34]   N←(1↑⍴R←TABLE T←P,'tables\biglakes.txt')⍴0                             ⍝Read big lakes grid -- we'll edit it[35]   Rh←head[36]  [37]  L1:→((1↑⍴csb)<K←K+1)/L9                                                 ⍝For each feature,[38]   LOG (6⍴' '),'Feature: ',(⊃csb[K;2]),' ',(⊃csb[K;1]),(~0∊⍴⊃csb[K;8])/' - ',⊃csb[K;8][39]   ⍎'A O ← ',(csb[K;csb_ COL 'feature']⊃'POINTGRID' 'LINEGRID' 'POLYGRID'),' ','⊃csb[K;csb_ COL ''spatial'']' ⍝   Convert to grid[40]  [41]  ⍝Collect data for text description of project[42]   Q←READBLOCK (⊂pathS,'towns'),(FINDCELL O),⍴A[43]   Z←UNIQUENZ Z,UNIQUENZ (,A)/,Q                                          ⍝   Collect list of towns[44]   →reportonly/L1                                                         ⍝   If reportonly, we only need to set changed[45]   C←(0,∨/1 0↓M[;M[1;]⍳csb[;csb_ COL 'type']])⌿M[;M[1;] COL 'group buffer']⍝    groups and buffers[46]   C←(⊂'')⍴¨⎕FI¨⍕¨C[47]   C←C[⍒C;][48]   C←(C[;1]≠0,¯1↓C[;1])⌿C                                                 ⍝   Groups and max buffer for each group[49]   U←⍳0                                                                   ⍝   List of all watersheds we'll be doing for this scenario[50]  [51]   L←0[52]  L2:→((1↑⍴C)<L←L+1)/L6                                                   ⍝   For each metric group,[53]   BREAKCHECK[54]   B←C[L;2]                                                               ⍝     Buffer for this group[55]  [56]   H←B BUFFER (-(2×B)+⍴A)↑(B+⍴A)↑A                                        ⍝     expand & buffer[57]   E←((FINDCELL O)-B),⍴H                                                  ⍝     window into grid[58]  [59]   :if ((⊂'aqconnect')∊T)∨(⊂'watershed')∊GETTYPE¨T←((1↓M[;M[1;] COL 'group'])∊C[;1])/1↓M[;1]   ⍝      If calling aqconect or any watershed metrics,[60]      T←((1↑⍴R),4)⍴((FINDPOINT E[1 2]),FINDPOINT E[1 2]+E[3 4])[1 4 3 2]  ⍝        MER for this buffer[61]      N←N∨(^/R[;2 3]≤T[;3 4])^^/R[;4 5]≥T[;1 2]                           ⍝        look for MERs overlapping big lakes[62]   :end[63]  [64]  [65]   →(~((⊂'tr')∊T)∨(⊂'watershed')∊GETTYPE¨T←((1↓M[;M[1;] COL 'group'])=C[L;1])/1↓M[;1])/L4   ⍝      If calling TR or any watershed metrics,[66]   U←U,W←UNIQUENZ,H×READBLOCK (⊂pathS,'watersheds'),E                     ⍝         Watershed(s) this feature falls in[67]   'bw' 'tw' LOAD¨(⊂pathT),¨'bigwatersheds4csb.txt' 'tinywatersheds.txt'[68]  [69]   →(~∨/(1⊃tw)[;(2⊃tw) MATIOTA 'watershed']∊W)/L3                         ⍝         If any tiny watersheds,[70]   Q←E+¯1 ¯1 2 2×⌈1000×wbuffer÷cellsize                                   ⍝            tiny watershed buffer[71]   G←(READBLOCK (⊂pathS,'watersheds'),Q)∊W                                ⍝            get cells in these watersheds[72]   E H ← E Q MERGEGRIDS H G                                               ⍝            and merge with mask[73]  [74]  L3:Q←((1⊃bw)[;(2⊃bw) MATIOTA 'watershed']∊W)⌿(1⊃bw)[;(2⊃bw) MATIOTA MATRIFY 'xmin ymin xmax ymax']    ⍝         MER of big watersheds[75]   →(0∊⍴Q)/L4                                                             ⍝         If any big watersheds,[76]   G←(READBLOCK (⊂pathS,'watersheds'),Q←MER2CELLS (⌊⌿Q[;1 2]),⌈⌿Q[;3 4])∊W⍝            get cells in these watersheds[77]   E H ← E Q MERGEGRIDS H G                                               ⍝            and merge with mask[78]  [79]  L4:H←H×2*C[L;1]-1                                                       ⍝      Mask is 2*metric group-1[80]   →(L≥2)/L5                                                              ⍝      If 1st loop,[81]   F V ← E H                                                              ⍝         save grid[82]   →L2                                                                    ⍝      else,[83]  L5:F V ← E F SUMGRIDS H V                                               ⍝         sum with running result[84]   →L2[85]  [86]  L6:→(K=1)/L8                                                            ⍝   If mask has already been written,[87]   H←READBLOCK (⊂P,'grids\mask'),F                                        ⍝      read it[88]   V←V BITOR H                                                            ⍝      and OR two masks bitwise[89]  L8:V WRITEBLOCK (⊂P,'grids\mask'),F                                     ⍝   Save the mask[90]   :if J=1                                                                ⍝   If this is 1st scenario,[91]      V WRITEBLOCK (⊂P2,'grids\jointmask'),F                              ⍝      write mask to joint mask[92]   :else                                                                  ⍝   else,[93]      V2←V BITOR READBLOCK (⊂P2,'grids\jointmask'),F                      ⍝      combine mask with joint mask[94]      V2 WRITEBLOCK (⊂P2,'grids\jointmask'),F                             ⍝      and write it[95]   :end[96]  [97]  [98]  ⍝Now copy landcover & settings grids[99]   D←D⍪'include' 1 (pathG PATH 'include') 'grids\'                        ⍝   Copy include grid straight[100] [101]  L←0[102] L7:→((1↑⍴D)<L←L+1)/L1                                                   ⍝   For each landcover/settings grid to copy,[103] ⍝⎕←'         Grid: ',⊃D[L;3] ⋄ FLUSH  ⍝TEMP[104]  BREAKCHECK[105]  Q←READBLOCK (D[L;3]),F,0                                               ⍝      Read the MER of the buffer for the source grid[106]  Q←MVREP Q (V=0)                                                        ⍝      mask to buffer (so we are't writing unnecessary stuff)[107]  T←~D[L;1]∊landgrids                                                    ⍝      settings variables will be forced to floating point[108]  Q WRITEBLOCK (⊂P,⊃,/D[L;4 1]),F,0 1,T                                  ⍝      and write the grid out transparently & force floating point for settings variable[109]  →L7[110] [111] L9:S←MATIN T←P,'tables\bigwatersheds4csb.txt'                           ⍝Only include target watersheds in big watersheds table[112]  S←((S[;1]∊U)∨S[;2]=2)⌿S                                                ⍝target big watersheds and all subwatersheds[113]  B←(1↑⍴S)⍴1[114]  :for I :in (S[;2]=2)/⍳1↑⍴S                                             ⍝Now, for each subwatershed,[115]     B[I]←(READBLOCK (⊂pathS,'watersheds'),(FINDCELL S[I;3 4]),1 1)∊U    ⍝   keep it if it's a sub of one of our targeted watersheds[116]  :end[117]  (B⌿S) CMATOUT T                                                        ⍝And save slimmed down watershed table[118] [119]  S←MATIN T←P,'tables\trbigwatersheds.txt'                               ⍝And the same for TR watersheds[120]  head←Rh[121]  (N⌿R) CMATOUT P,'tables\biglakes.txt'                                  ⍝And edit biglakes.txt to include only overlapping MERs[122]  changed[J;1]←⊂Z                                                        ⍝List of towns    ∇