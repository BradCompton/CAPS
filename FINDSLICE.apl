    ∇ A FINDSLICE S;A;X;Q;block;loop;test;grids;ffile;noread;tilesize;source;result;targets;Z;buffer;E;N;tilemapinclude;dot;exclude;skiptilemap;density;W;F;head;target[1]   ⍝Find the value to slice grid source at to get target% of the total value[2]   ⍝Parameters:[3]   ⍝   source          name of target grid[4]   ⍝   result          name of result grid[5]   ⍝   target          target percent of sum(source)[6]   ⍝   density         density of samples per tile[7]   ⍝   tilesize        size of tiles (in cells)[8]   ⍝   targets = '1:1' needs to be in parameters.par to run a single thread[9]   ⍝Runs as a CAPS metric, but only uses one thread.[10]  ⍝pathR\findslice.txt must exist before running.  Results are appended to it.[11]  ⍝B. Compton, 25 Sep 2014 (from QUANTILESCALE)[12]  [13]  [14]  [15]  ⍝-----Pass 1: Sample cells[16]   READPARS ME[17]   buffer←4⊃A[18]   exclude←''[19]   loop←test←noread←0 ⋄ grids←0 0⍴''              ⍝   Silly junk for BLOCK, etc.[20]   ffile←'FINDSLICE (pass 1) '[21]   BLOCK 2⍴tilesize[22]   SETTILE[23]  [24]   tilemapinclude←0[25]   skiptilemap←0                                  ⍝Don't let DEBUG sabotage this[26]   E←TILEMAP '' tilesize 0 0                      ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[27]  [28]   Z←⍳0[29]   N←0[30]  L1:→(~E[N←N+1])/L2                              ⍝Repeat: read tile, skip if not in tilemap    --- For each tile ---[31]   BREAKCHECK ⋄ DOT[32]   X←READ 1⊃A                                     ⍝   Read target grid to get missing values[33]   :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[34]      X←MVREP X ((READ mask)∊0,MV)                ⍝      read mask & apply it[35]   :end[36]   Q←⌈density××/⍴X                                ⍝   number of cells to sample[37]   X←(,X)[Q?×/⍴X]                                 ⍝   get samples[38]   Z←Z,(X≠MV)/X                                   ⍝   throw away missing samples[39]  L2:→(0≠NEXTBLOCK)/L1                            ⍝   Until no more tiles[40]  [41]   Z←Z[⍒Z]                                        ⍝   sort largest-to-smallest, and take cumulative sum[42]   W←'FINDSLICE, run ',NOW[43]   W←W OVER 'Source grid: ',1⊃A[44]   W←W OVER 'Target = ',(⍕target),'%'[45]   W←W OVER 'Estimated sum = ',FRDBL,'CF18.2' ⎕FMT Q←(+/Z)÷density[46]   W←W OVER 'Target value = ',FRDBL,'CF18.2' ⎕FMT Q×target÷100[47]   W←W OVER 'Value to slice at = ',⍕Z←Z[1++/(+\Z)<(target÷100)×+/Z][48]   W←W OVER ''[49]   ⎕←MTOV W ⋄ FLUSH[50]   Q←LOCKFILE F←pathR PATH 'findslice.txt'[51]   (MTOV W) NAPPEND F[52]   UNLOCKFILE Q[53]  [54]  [55]  ⍝-----Pass 2: Write result[56]    dot←⍴⍞←'Creating result grid' ⋄ FLUSH[57]    N←0[58]    BLOCK 2⍴tilesize[59]  L3:→(~E[N←N+1])/L4                              ⍝Repeat: read tile, skip if not in tilemap    --- For each tile ---[60]   BREAKCHECK ⋄ DOT[61]   X←READ 1⊃A                                     ⍝   Read target grid to get missing values[62]   X←MVREP (X≥Z) (X=MV)[63]   :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[64]      X←MVREP X ((READ mask)∊0,MV)                ⍝      read mask & apply it[65]   :end[66]   X WRITE 3⊃A[67]  L4:→(0≠NEXTBLOCK)/L3                            ⍝   Until no more tiles[68]   ⎕←'FINDSLICE is done.' ⋄ FLUSH[69]   →0[70]  [71]  [72]  what:auxiliary[73]  type:table[74]  info:(source) ('') (result) 0 ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[75]  check:CHECKVAR 'source result target density tilesize targets'    ∇