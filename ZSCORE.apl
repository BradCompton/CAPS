    ∇ A ZSCORE S;buffer;loop;test;noread;grids;ffile;tilesize;tilemapinclude;skiptilemap;E;Z;N;L;strata;M;X;value;usebench;B;U;T;P;Q;I;savebench;head;result;Y;R;targets;trim;setdev;W;alsoexclude[1]   ⍝Standardize grid, optionally stratified, with benchmarking[2]   ⍝Development and excluded are omitted when finding mean & SD[3]   ⍝Parameters:[4]   ⍝   value               path & name of value grid to standardize[5]   ⍝   strata              name of stratification grid (only one); use '' for no stratification[6]   ⍝   result              path & name of result grid[7]   ⍝   savebench           name of benchmark file to write[8]   ⍝   usebench            name of benchmark file to use (skips 1st pass)[9]   ⍝   trim                trim anything beyond this many SD (use 0 to skip)[10]  ⍝   setdev              set developed cells to this (use '' to skip)[11]  ⍝   alsoexclude         types to exclude along with developed--these get nodata[12]  ⍝   tilesize            size of tiles (in cells)[13]  ⍝   targets = '1:1'     needs to be in parameters.par to run a single thread[14]  ⍝Runs as a CAPS metric, but only uses one thread.  It'll be fastest if you set host = 'w00'.[15]  ⍝B. Compton, 25 Apr 2017 (12 yards of compost delivered: "Mount Martin")[16]  ⍝26 May 2017: exclude development and excluded systems[17]  ⍝28 Jun 2017: add trim and setdev[18]  ⍝29 Jun 2017: add alsoexclude[19]  [20]  [21]  [22]   READPARS ME[23]   buffer←4⊃A[24]   loop←test←noread←0 ⋄ grids←0 0⍴''   ⍝Silly junk for BLOCK, etc.[25]   ffile←'ZSCORE '[26]   BLOCK (2⍴tilesize),buffer[27]   SETTILE[28]  [29]   tilemapinclude←0[30]   skiptilemap←0              ⍝Don't let DEBUG sabotage this[31]   E←TILEMAP '' tilesize 0 0  ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[32]  [33]  [34]   :if 0∊⍴usebench            ⍝If finding benchmarks, ------- 1st pass -------[35]  [36]      ⎕←'Running ZSCORE on ',(⍕+/E),' tiles (pass 1)' ⋄ FLUSH[37]        [38]      Z←0 4⍴0                 ⍝   Strata, sum, SS, n for each strata; accumulated across tiles[39]      N←0[40]  L1: →(~E[N←N+1])/L2         ⍝   Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[41]      BREAKCHECK [42]      DOT   [43]      L←READ 1⊃1⊃A            ⍝      Read landcover grid [44]      →(0∊⍴Y←S INCLUDE L)/L2  ⍝      Exclude development & excluded systems[45]      Y←Y^~L∊LOOK alsoexclude ⍝      also exclude other stuff[46]      :if ~0∊⍴strata          ⍝      If stratification grid supplied,[47]         M←READ 2⊃1⊃A         ⍝         read it[48]      :else                   ⍝      Else,[49]         M←(⍴L)⍴1             ⍝         all in one strata[50]      :end[51]      L←MVREP L (~Y)          ⍝      Set all excluded stuff to missing--it'll get nuked[52]      X←READ 3⊃1⊃A   [53]      B←,~(L∊MV)∨(M∊MV)∨X∊MV  ⍝      Missing anywhere → missing[54]      M←B/,M[55]      X←B/,X[56]  [57]      U←UNIQUE M              ⍝      Unique strata[58]      T←(~U∊Z[;1])/U          ⍝      new ones[59]      Z←Z⍪((⍴T),4)↑((⍴T),1)⍴T ⍝      add to list[60]      [61]      M←M[P←⍋M]               ⍝      sort by strata[62]      X←X[P][63]      B←M≠¯1↓0,M              ⍝      partition vector[64]      Q←(B pSUM X),(B pSUM X*2),[1.5]B pSUM (⍴B)⍴1  ⍝      sum, SS, and N for each strata[65]      Z[I;2 3 4]←Z[I←Z[;1]⍳B/M;2 3 4]+Q             ⍝      keep running sum of these[66]  [67]  L2: →(0≠NEXTBLOCK)/L1       ⍝   Until no more tiles[68]   [69]      Z←Z[;1],(Z[;,2]÷Z[;,4]),BIGSD Z[;2 3 4]   ⍝   strata, mean, SD[70]      :if ~0∊⍴savebench          ⍝   If saving benchmarks,[71]         head←1↓⎕TCHT MTOV MATRIFY 'strata mean sd'[72]         Z TMATOUT pathW PATH savebench[73]      :end[74]   [75]   :end[76]    [77]   :if ~0∊⍴usebench                ⍝If using existing benchmarks,[78]      Z←MATIN pathW PATH usebench  ⍝   read them[79]   :end[80]   [81]  ⍝ ------- 2nd pass ------- [82]   ⎕←'Running ZSCORE on ',(⍕+/E),' tiles (pass 2)' ⋄ FLUSH[83]   BLOCK (2⍴tilesize),buffer[84]   SETTILE[85]   N←0[86]  L3: →(~E[N←N+1])/L4         ⍝Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[87]      BREAKCHECK [88]      DOT   [89]      L←READ 1⊃1⊃A            ⍝   Read landcover grid [90]      :if ~0∊⍴strata          ⍝   If stratification grid supplied,[91]         M←READ 2⊃1⊃A         ⍝      read it[92]      :else                   ⍝   Else,[93]         M←(⍴L)⍴1             ⍝      all in one strata[94]      :end[95]      R←⍴X←READ 3⊃1⊃A   [96]      B←,~(L∊MV)∨(M∊MV)∨(L∊LOOK alsoexclude)∨X∊MV  ⍝      Missing anywhere → missing[97]      M←B/,M[98]      X←B/,X[99]  [100]     I←Z[;1]⍳M[101]     X←(X-Z[I;2])÷Z[I;3]     ⍝   Standardize[102]     [103]     X←MVREP (R⍴B\X) (R⍴~B)  ⍝   back to original matrix[104]  [105] W←X[106] [107]    :if trim≠0               ⍝   if trimming results[108]        X←(-trim)⌈trim⌊X     ⍝      trim to specified SD[109]     :end[110]     :if 0≠⍴,setdev          ⍝   if there's a value to set development to[111]        X←setdev MVREP X (L∊LOOK 'developed')[112] W←setdev MVREP W (L∊LOOK 'developed')[113]     :end[114]     X WRITE result          ⍝   Write results[115] W WRITE result,'U'          ⍝   Write UNTRIMMED results[116]  [117]  L4: →(0≠NEXTBLOCK)/L3      ⍝Until no more tiles[118] [119]  [120]  [121]   ⎕←''[122]  LOG 'ZSCORE is done.'[123]  →0[124] [125] [126] what:auxiliary[127] type:table[128] info:('land' strata value) ('') (result) 0 ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[129] check:CHECKVAR 'value strata result savebench usebench trim setdev alsoexclude tilesize targets'    ∇