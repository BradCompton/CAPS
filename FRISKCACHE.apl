    ∇ Z←P FRISKCACHE N;D;D_;B;L;R;head;X;Y;T;C;E;F;G;A;lock;I;J;V;H;Q;S;lock2;th;M;cachelogdetails;ch[1]   ⍝Frisk the local grid cache directory: free up ⍵ MB and clear hung copying attempts, missing grids, and spurius folders[2]   ⍝   ⍺[1] - deletecopies - TRUE if 'copying' grids should be deleted whether or not they're stale and unindexed grids should be deleted[3]   ⍝   ⍺[2] - getlock - if TRUE, gets a lock at start and release it when done[4]   ⍝Two primary uses:[5]   ⍝   1. At initial launch: called with freeup = 0, deletecopies = TRUE, getlock = TRUE (when no threads are running yet).[6]   ⍝      Deletes all grids that are not indexed, removes index entries that have no corresponding grid, and deletes grids/removes [7]   ⍝      entries for all grids that have status 'copying'.[8]   ⍝   2. From READBLOCKC, when space needs to be made to copy a grid: called with freeup = (default: deletesize), deletecopies = FALSE,[9]   ⍝      getlock = FALSE.  Does frisking as above, but only deletes 'copying' grids if they're more than 24 hours old.  Deletes [10]  ⍝      least-recently accessed grids in order to free up at least freeup GB.[11]  ⍝Returns 1 if success, 0 if couldn't free up ⍵ MB[12]  ⍝B. Compton, 10 Mar 2014[13]  ⍝18 Apr 2014: also delete any leftover crap in directory[14]  ⍝16 Jun 2014: add hours option and change so this can be run while threads are running + check for bad entries + optional delay[15]  ⍝Clearing missing grids was giving negative number of spurious folders to clear[16]  ⍝5 Feb 2015: exit if caching is turned off[17]  ⍝23 May-7 Jun 2016: COMPLETE REWRITE for new hashed caches[18]  ⍝6 Sep 2016: I had the default bit vector for grid deletion backwards (my well went dry yesterday; worst drought in decades)[19]  ⍝7 Sep 2016: add logging to Anthill log & fix bug in getting elapsed time on copying grids[20]  ⍝22 Aug 2017: check amount of free space after getting lock--another thread may have just frisked this cache, so maybe we don't need to do anything (my 1st D2R2 on Saturday; 66% solar eclipse on Monday)[21]  ⍝23 Aug 2017: oops[22]  ⍝5 Sep 2017: bail as unnecessary if ≥50% of requested is available, as we were still getting cascades[23]  ⍝16 Nov 2017: bug: deleted grids in 1st pass (expired, stale copying, missing or damaged) were not removed from master list, thus sizes were kept for cacheinfo.txt[24]  ⍝             and: if we determined in 2nd pass that we couldn't delete grids, we still excluded them from size count[25]  ⍝9 Feb 2018: add logging each deleted grid to try to catch vanishing grid bug[26]  ⍝12 Mar 2018: don't delete unindexed grids unless deletecopies is true. We were plagued for 3 months with a horrible bug that was caused by FRISKCACHE deleting[27]  ⍝             unindexed grids that were copying at the time--these don't have cache entries yet, as READBLOCKC doesn't know where they're going at that point.[28]  ⍝             So we'll only delete unindexed grids on startup.[29]  [30]  [31]  [32]   cachelogdetails←1[33]  [34]   ⍎(0=⎕NC'P')/'P←0 1'[35]   P←2↑P,1[36]   ch←0[37]   [38]   ⍎((th←0)≠⎕NC'thread')/'th←thread'[39]   M←(1+N=0)⊃'FRISKCACHE is freeing up space in grid cache on ' 'FRISKCACHE is cleaning up grid cache on '[40]   (⎕←M,name) ANTLOG pathA 'anthill.log' (name←GETNAME) th '' 0 0[41]  [42]   GETCACHECONFIG ⋄ CONFIG[43]   :if P[2]                                           ⍝If getlock,[44]      A←⎕AI[2]                                        ⍝      Start cachewait timer[45]      lock←LOCKFILE GETNAME,' cache'                  ⍝      Get a lock on cacheinfo[46]   :end[47]  [48]   S←(FILEINFO 2⊃cache)[3]                            ⍝Free space on cache drive[49]   Q←,0 MATIN F←(2⊃cache),'index\cacheinfo.txt'       ⍝Read cacheinfo[50]   :if (N≠0)^((S-cache[4])⌊cache[3]-Q[2])≥N×0.5       ⍝If trying to free space and our target has already been met: ((free-minfree)⌊maxsize-used)≥50% of requested (because another thread already frisked), we're done here[51]      Z←1                                             ⍝   return success[52]      (⎕←'FRISKCACHE is unnecessary--another thread just did it on ',name) ANTLOG pathA 'anthill.log' name th '' 0 0[53]      →L5[54]   :end[55]   [56]   C←'\',¨FRDBL¨↓MATRIFY 'dblbnd.adf hdr.adf sta.adf w001001.adf w001001x.adf'[57]   L←12⍴0  ⍝Log vector: [1] date, [2] computer, [3] system (APL), [4] duration, [5] result, [6] missing, [7] expired, [8] copying, [58]           ⍝[9] unindexed, [10] purged, [11] GBcleaned, [12] GBfreed [59]   V←⎕AI[2]                                           ⍝Start timer for duration[60]   L[1 2 3]←NOW name 'APL'[61]   E←0 7⍴0[62]   [63]   ⎕←'FRISKING cache...' ⋄ FLUSH[64]   [65]   I←0[66]  L1:→(cache[5]<I←I+1)/L4                             ⍝For each cache index,[67]    DOT[68]    D T lock2 A ← 0 GETCACHEDIR I                     ⍝   get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[69]    D D_ ← D[70]    B←(1↑⍴D)⍴1                                        ⍝   selection vector for index[71]    H←P[1]∨24≤((⊂⎕TS) ELAPSED¨PARSEDATE¨D[;D_ COL 'cachedate'])÷60*2    ⍝   mark grids that are older than 24 hours; always true if deletecopies[72]  [73]    J←0[74]  L2: →((1↑⍴D)<J←J+1)/L3                              ⍝   For each grid in cache,[75]        :if D[J;D_ COL 'status']≡⊂'expired'           ⍝      If grid is expired,[76]           ⎕←'   [FRISKCACHE is deleting expired grid ',(⊃D[J;2]),']' ⋄ FLUSH[77]           RDIR STRIPPATH ⊃D[J;2]                     ⍝         delete grid [78]           :if cachelogdetails[79]               head←1↓⎕TCHT MTOV MATRIFY 'date computer system cachepath sourcepath message' [80]               (NOW name 'APL',D[J;2 1],⊂'expired') LOCKWRITE pathA,'friskcachedetails.log'[81]               ch←1[82]           :end[83]           B[J]←0                                     ⍝         will clear it from index[84]           L[7]←L[7]+1                                ⍝         increment expired grid count[85]        :elseif H[J]^D[J;D_ COL 'status']≡⊂'copying'  ⍝      If grid is 'copying' and older than 24 hours or deletecopies,[86]           ⎕←'   [FRISKCACHE is deleting copying grid ',(⊃D[J;2]),']' ⋄ FLUSH[87]           :if cachelogdetails[88]               head←1↓⎕TCHT MTOV MATRIFY 'date computer system cachepath sourcepath message' [89]               (NOW name 'APL',D[J;2 1],⊂'copying') LOCKWRITE pathA,'friskcachedetails.log'[90]               ch←1[91]           :end[92]           RDIR STRIPPATH ⊃D[J;2]                     ⍝         delete grid (or fragments)[93]           B[J]←0                                     ⍝         will clear it from index[94]           L[8]←L[8]+1                                ⍝         increment copying grid count[95]        :elseif (~^/IFEXISTS¨D[J;D_ COL 'cache'],¨C)^D[J;D_ COL 'status']≡⊂'ready'    ⍝      If grid is 'ready' and missing or damaged, *** may want to use CHECKGRID, test = false, when I implement it[96]           ⎕←'   [FRISKCACHE is deleting missing or damaged grid ',(⊃D[J;2]),']' ⋄ FLUSH[97]           :if cachelogdetails[98]               head←1↓⎕TCHT MTOV MATRIFY 'date computer system cachepath sourcepath message' [99]               (NOW name 'APL',D[J;2 1],⊂'missing') LOCKWRITE pathA,'friskcachedetails.log'[100]              ch←1[101]          :end[102]          RDIR STRIPPATH ⊃D[J;2]                     ⍝         delete remains of grid if they exist[103]          B[J]←0                                     ⍝         will clear it from index[104]          L[6]←L[6]+1                                ⍝         increment missing grid count[105]       :end[106]       →L2[107]     [108]  L3:[109]       D←B⌿D                                         ⍝   drop deleted grids from index[110]       :if 0∊B                                       ⍝   If any changes to index,[111]          D D_ PUTCACHEDIR I                         ⍝      save new index with entries dropped[112]       :end[113]       E←E⍪D                                         ⍝   append to comprehensive index[114]       UNLOCKFILE lock2[115]       →L1[116] [117] L4:⎕←'' ⋄ FLUSH[118]  :if P[1]                                           ⍝If deletecopies, look for unindexed grids[119]     X←⎕LIB 2⊃cache                                  ⍝   Now delete spurious grids that aren't in index...[120]     X←X[(⍳1↑⍴X)~X MATIOTA MATRIFY 'old_gridcache.txt index\';]      ⍝   Don't want extra junk[121]     X←¯1↓¨FRDBL¨↓(,'\'=(RJUST X)[;1↓⍴X])⌿X          ⍝   Folders in cache directory on disk[122]     Y←STRIP¨¯1↓¨STRIPPATH¨E[;D_ COL 'cache']        ⍝   Folders in gridcache.txt[123]     X←cache[2],¨(~X∊Y)/X                            ⍝   Spurious folders not in cache directory - we'll delete these[124]     L[9]←⍴X                                         ⍝   Number of unindexed grids deleted[125]     :if ~0∊⍴X[126]        ⎕←'   [FRISKCACHE is deleting unindexed grids:'[127]        ⎕←' ',' ',' ',' ',(⎕PW-4) TELPRINT ↑X[128]        :if cachelogdetails[129]           head←1↓⎕TCHT MTOV MATRIFY 'date computer system cachepath sourcepath message' [130]           T←↑(⊂NOW name 'APL'),¨(⊂¨X),¨(⊂⊂''),¨⊂⊂'unindexed'[131]           T LOCKWRITE pathA,'friskcachedetails.log'[132]           ch←1[133]        :end[134]        RDIR¨X                                       ⍝   Away they go[135]     :end[136]  :end[137] [138]  L[11]←0⌈3 ROUND 0.001×(FILEINFO 2⊃cache)[3]-S      ⍝Amount of space freed up by cleaning (GB) -- don't report <0, as there may be interference[139] [140]  B←0                                                ⍝Default: not deleting any![141]  :if N>0                                            ⍝If need to free up space,[142]     B←(⊂'ready')≡¨E[;D_ COL 'status']               ⍝   Only 'ready' grids (not 'copying') can be deleted[143]     F←PARSEDATE¨¨↓¨'/' MATRIFY¨E[;D_ COL 'reads']   ⍝      Access dates[144]     B←B^B\1≤((⊂⎕TS) ELAPSED¨⊃¨B/F)÷60*2             ⍝      Don't delete anything read in the past hour[145]     R←⍋↑MEAN¨B/F                                    ⍝      Sort mean read date, oldest to newest[146]     B←B\(1,¯1↓N>+\(B/E[;D_ COL 'size'])[R])[⍋R]     ⍝      These are the grids to delete from the cache[147]     L[12]←3 ROUND 0.001×T←+/B/E[;D_ COL 'size']     ⍝      Amount of space freed up by freeing (GB)            [148]     :if Z←N≤T                                       ⍝      If we'll be able to clear enough (set success flag),[149]        Q←B/E[;D_ COL 'cache']                       ⍝         cached grids to delete[150]        G←1 GETCACHEPATH¨B/E[;D_ COL 'source']       ⍝         hashes of these grids[151]        L[10]←⍴Q                                     ⍝         number of grids purged to free up space[152]        ⎕←'   [FRISKCACHE is deleting cached grids ',(2↓⊃,/(⊂', '),¨Q),']'[153] [154]        :if cachelogdetails[155]           head←1↓⎕TCHT MTOV MATRIFY 'date computer system cachepath sourcepath message' [156]           (↑(⊂NOW name 'APL'),¨↓(B⌿E[;2 1]),⊂'purged') LOCKWRITE pathA,'friskcachedetails.log'[157]           ch←ch∨1∊B[158]        :end[159] [160]        Q←Q[T←⍋G]                                    ⍝         Sort grids to delete by hash so we can take advantage of multiple grids/index[161]        H←UNIQUE G[162]        :for I :in H                                 ⍝         For each affected cache index,[163]           D T lock2 A ← 0 GETCACHEDIR I             ⍝            get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[164]           D D_ ← D[165]           D←(~D[;D_ COL 'cache']∊Q)⌿D               ⍝            remove target grids from index[166]           D D_ PUTCACHEDIR I                        ⍝            write index[167]           UNLOCKFILE lock2[168]        :end[169]        RDIR¨STRIPPATH¨Q                             ⍝         Delete all of these grids[170]     :else[171]        B←0                                          ⍝       Else, we've failed to delete anything, so don't drop from size sum![172]     :end[173]  :end[174] [175] [176]  Q←,0 MATIN F←(2⊃cache),'index\cacheinfo.txt'       ⍝Read cacheinfo[177]  Q[2]←+/(~B)/E[;D_ COL 'size']                      ⍝update total cache size of remaining grids                           [178]  ((⍕Q[1]),⎕TCNL,⍕Q[2]) NWRITE F                     ⍝and write cacheinfo[179] [180]  L[4]←⊂TIME ⎕AI[2]-V[181]  Q←+/L[6 7 8 9][182]  L[5]←'ok' ((⍕Q),' error',(Q≠1)/'s')[1+Q≠0][183]  ⍎(0=⎕NC'cluster')/'cluster←1'[184]  head←1↓⎕TCHT MTOV MATRIFY 'date computer system duration result missing expired copying unindexed purged GBcleaned GBfreed' [185]  L LOCKWRITE pathA,'friskcache.log'[186] [187]  ⎕←'FRISKCACHE results:'[188]  ⎕←(RJUST ⎕TCHT MATRIFY head),':',' ',MIX ⍕¨L       ⍝Print out report[189]  FLUSH[190]  [191]  :if cachelogdetails^~ch[192]     head←1↓⎕TCHT MTOV MATRIFY 'date computer system cachepath sourcepath message' [193]     (NOW name 'APL' '' '' 'nochange') LOCKWRITE pathA,'friskcachedetails.log'[194]  :end[195]  [196]  ⍎((th←0)≠⎕NC'thread')/'th←thread'[197]  ('FRISKCACHE is done on ',name) ANTLOG pathA 'anthill.log' name th '' 0 0[198] [199] [200] L5:[201]  :if P[2]                                           ⍝If getlock,[202]     UNLOCKFILE lock                                 ⍝   return cacheinfo lock[203]     CACHEWAIT A[204]  :end    ∇