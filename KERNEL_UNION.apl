    ∇ A KERNEL_UNION S;buffer;loop;test;noread;grids;ffile;tilesize;tilemapinclude;skiptilemap;E;N;Q;I;X;P;Y;points;Z;head;result;zeros[1]   ⍝Find threadhold for union of kernels[2]   ⍝Make sure that the threshold you pick is greater than the background value for any of the source kernels![3]   ⍝Parameters:[4]   ⍝   grids               list of source grids...all must be quantile-scaled[5]   ⍝   result              name of result table (text file)[6]   ⍝   points              number of sample points per tile[7]   ⍝   tilesize            size of tiles (in cells)[8]   ⍝   zeros               if yes, treat nodata as zero; otherwise, remove cells that are nodata for any grid[9]   ⍝   targets = '1:1'     needs to be in parameters.par to run a single thread[10]  ⍝Runs as a CAPS metric, but only uses one thread.  It'll be fastest if you set host = 'w00'.[11]  ⍝B. Compton, 6 Jun 2017 (rainy with high temperature in the 40's--the last fire of the season, again)[12]  ⍝18 Jul 2017: don't let missing values through (where landcover exists but masked)[13]  ⍝19-20 Sep 2017: add zeros option[14]  [15]  [16]  [17]   READPARS ME[18]   buffer←4⊃A[19]  [20]  [21]   loop←test←noread←0 ⋄ grids←0 0⍴''  ⍝Silly junk for BLOCK, etc.[22]   ffile←'KERNEL_UNION'[23]   BLOCK (2⍴tilesize),buffer[24]   SETTILE[25]   tilemapinclude←0[26]   skiptilemap←0                      ⍝Don't let DEBUG sabotage this[27]   E←TILEMAP '' tilesize 0 0          ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[28]   Y←(0,¯1+⍴1⊃A)⍴0[29]  [30]   N←0[31]  L1:→(~E[N←N+1])/L4                  ⍝Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[32]   BREAKCHECK [33]   DOT   [34]   X←,READ 1⊃1⊃A                      ⍝   Read landcover[35]   X←MVREP X (X∊⊃,/LOOK¨FRDBL¨↓','MATRIFY exclude)  ⍝   exclude ocean [36]   P←points?⍴X                        ⍝   sample points[37]   P←(X[P]≠MV)/P                      ⍝   drop those that fall in excluded (basically ocean) or nodata in landcover[38]   Q←((1↑⍴P),0)⍴0[39]  [40]   I←1[41]  L2:→((⍴1⊃A)<I←I+1)/L3               ⍝   For each source grid,[42]   X←,READ I⊃1⊃A[43]   Q←Q,X[P]                           ⍝      get samples [44]   →L2[45]  [46]  L3:Q←(MV,0)[zeros+1] MVREP Q        ⍝   If zeros = yes, replace MV with zero[47]   Q←(^/Q≠MV)⌿Q                       ⍝   Drop any rows with missing values for kernel grids[48]   Y←Y⍪Q[49]  [50]  L4:→(0≠NEXTBLOCK)/L1                ⍝Until no more tiles[51]  [52]   ⎕←''[53]  [54]   head←1↓⊃,/⎕TCHT,¨STRIP¨1↓1⊃A[55]   Y TMATOUT (STRIPPATH result),(STRIP result),'_full.txt'[56]  [57]   Y←⌈/Y                              ⍝Take maximum at each cell[58]   Z←99 2⍴0[59]   [60]   I←0[61]  L5:→(99<I←I+1)/L6                   ⍝For each cutpoint,[62]   Z[I;]←(I÷100),(+/Y≥I÷100)÷⍴Y       ⍝   Take proportion of samples ≥ cutpoint[63]   →L5[64]  [65]  L6:head←1↓⎕TCHT MTOV MATRIFY 'cutpoint proportion'[66]   Z TMATOUT result[67]   LOG 'Result table written to ',result   [68]   →0[69]  [70]  [71]  [72]  what:auxiliary[73]  type:table[74]  info:((⊂'land'),FRDBL¨↓MATRIFY grids) ('') ('') 0 ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[75]  check:CHECKVAR 'grids result points zeros tilesize targets'    ∇