    ∇ Z←W TILEMAP G;X;F;Q;B;REST;I;J;noread;ifchat;Y;V;T;dot;L;M;A;U;C;H;E;S;N;O;K;QQQ;t[1]   ⍝Tracks empty tiles (size, buffer, maskgroup in 2 3 4⊃⍵) in for include grid 1⊃⍵ and current mask grid to save runtime; ignore mask if ⍺ or if 1⊃⍵ = '*'[2]   ⍝Globals:[3]   ⍝   tilemap         Filename to use; if '' turn off this facility[4]   ⍝   tilemapinclude  If yes, use the include grid, if no, assume it's all 1s[5]   ⍝   altmask         If not empty, this is the alternative mask name (used for jointmask from CSE_SCENARIOS)[6]   ⍝   block           Assumes BLOCK/READ have already been called for current situation[7]   ⍝   skiptilemap     If true, just return 1 (for DEBUG)[8]   ⍝On first call for a particular grid/tile/buffer, the grid will be scanned[9]   ⍝to look for empty blocks; results are saved in tilemap database.  On subsequent[10]  ⍝runs, database is used.  Delete tilemap.txt to reset database (duh).[11]  ⍝Returns binary vector corresponding to blocks in landscape.[12]  ⍝maskgroup (⍵[4]) is interpreted as follows:[13]  ⍝  > 0      indicates which bit of the mask grid is used for the mask.[14]  ⍝  = 0      all positive cells in the grid are considered unmasked[15]  ⍝  = ¯1     all cells > ¯1 are considered unmasked (zero + positive integers)[16]  ⍝  = MV     only MV cells are considered masked (in all of the above MV cells are also masked)[17]  [18]  ⍝B. Compton, 16-19 Nov 2010[19]  ⍝7 Dec 2010: Screen out blocks that are all missing, but include zeros--need this for BARRIERS.  Sigh.[20]  ⍝3 Feb 2011: Allow alternate grid names, with default of include.  Back to excluding zeros, because BARRIERS can use land.[21]  ⍝4 Apr 2011: Strip path from grid name[22]  ⍝16 Jun 2011: bug - restart blocks at 0,0[23]  ⍝21 Jun 2011: don't read if only 1 block[24]  ⍝22 Jun 2011: use local grid server to prevent bogging down[25]  ⍝27 Oct 2011: don't replace include grid with stripped version--then it can't find it if it's somewhere funny[26]  ⍝19 Jan 2012: keep full path of reference grid, in case of differing extents[27]  ⍝8 Feb 2012: oops--match case when looking up grid name!; restore block (I wish APL had leaky localization!)[28]  ⍝10 Jul 2012: respect the mask!  *** Note: if you change the mask, you'll have to delete tilemap.txt![29]  ⍝20 Aug 2012: attempt to read the whole grid at once with FASTBLOCKMAP.  4x+ speedups.[30]  ⍝21 Aug 2012: include bitmask group in tilemap file (* all old blockmap files are obsolete!)[31]  ⍝24 Aug 2012: rename from BLOCKMAP; add tilemapinclude; store mask grid too; exclude negative mask elements; lock directory; new maskgroup interpretations[32]  ⍝4 Sep 2012: ignore mask if ⍺[33]  ⍝5 Sep 2012: Aaargh! Was exiting before releasing lock.[34]  ⍝27 Sep 2012: unlock tilemap directory if there's an error[35]  ⍝14 Jan 2013: a couple of minor bugs involving tilemapinclude and mask[36]  ⍝18 Feb 2013: I had mask grid condition switched(?!)[37]  ⍝28 Feb 2013: when setting ⎕ELX, clear RETURNLOCK so it only gets called once[38]  ⍝14 Jun 2013: call CONFIG before getting a lock[39]  ⍝26 Jul 2013: add altmask; 12 Aug 2013: don't fail if it doesn't exist[40]  ⍝1 Aug 2013: don't try to use mask grid if mask = ''[41]  ⍝20 Aug 2013: If using altmask, it gets full status as mask grid[42]  ⍝21 Nov 2013: completely revise locking scheme to keep from piling up TILEMAPs[43]  ⍝3 Jan 2014: use LOCKFILE/UNLOCKFILE[44]  ⍝9 Jan 2014: add recovery from crashes so tilemap.txt isn't screwed up[45]  ⍝28 Jan 2014: recover properly when calling TILEMAPRECOVER[46]  ⍝5 Feb 2014: read multiple tiles in each pass for a significant speed-up (2.4x for tiles of 1000, to 18.9x for tiles of 200); 20 Feb: I forgot the buffer![47]  ⍝6 Mar 2014: include grid of '*' also turns off TILEMAP (needed for MAKEMASK)[48]  ⍝10 Jul 2014: add skiptilemap for DEBUG[49]  ⍝26 Sep 2014: altmask of '*' is treated as nomask[50]  [51]  [52]  [53]   ⍎(0=⎕NC'W')/'W←0'[54]   Z←1[55]   :if 0≠⎕NC 'skiptilemap'[56]      →skiptilemap/0[57]   :end[58]   U←0[59]   →(0=⎕NC'tilemap')/0[60]   →(('*'≡1⊃G)∨(~0∊⍴blocks)∨0∊⍴tilemap)/0             ⍝If tilemap facility is turned off (or selected blocks turned on), just exit[61]  [62]   ⍎(0∊⍴⊃G[1])/'G[1]←⊂1 GRIDNAME ''include'''         ⍝Default grid is include[63]   G←4↑G,0[64]   G[1]←'' (1⊃G)[tilemapinclude+1]                    ⍝If tilemapinclude = no, include grid is blank[65]   T←'mask' ⋄ ⍎(0≠⎕NC'altmask')/'T←(1+0≠⍴altmask)⊃''mask'' altmask'[66]   M←(~T≡,'*')/(~W)/GRIDNAME T                        ⍝Mask grid (if used; set it to nothing in inputs.par to not use it ... or use ⍺=1)[67]   X←''[68]  [69]   F←pathP PATH tilemap[70]   A←(~cluster)∨≡/FRDBL¨TOLOWER¨pathA F               ⍝If doing a cluster run and writing to a path other than Anthill, we'll have to lock[71]  L10:[72]   :if ~A[73]  ⍝    (⎕←'Locking ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[74]      H←LOCKFILE (1+-(⌽F)⍳'\')↓F                      ⍝   get a lock[75]   :end[76]   →(~IFEXISTS F)/L1                                  ⍝If tilemap exists,[77]   X←NREAD F                                          ⍝   Read it[78]   Q←FRDBL¨↓VTOM TOLOWER ⎕TCHT FIRSTCOL X             ⍝   grid names[79]   B←Q≡¨⊂TOLOWER FRDBL 1⊃G                            ⍝   matches[80]   B←B^(⊂TOLOWER M)≡¨TOLOWER¨FRDBL¨↓VTOM ⎕TCHT FIRSTCOL REST    ⍝   mask grid[81]   B←B^G[2]=⎕FI ' ' MTOV VTOM ⎕TCHT FIRSTCOL REST     ⍝   block size matches[82]   B←B^G[3]=⎕FI ' ' MTOV VTOM ⎕TCHT FIRSTCOL REST     ⍝   buffer size[83]   B←B^G[4]=⎕FI ' ' MTOV VTOM ⎕TCHT FIRSTCOL REST     ⍝   maskgroup (0 means no mask or not in a group)[84]   →(~1∊B)/L1                                         ⍝   If found,[85]   Z←(B⌿VTOM REST)[1;]                                ⍝      get binary vector (take 1st occurence by some error there are multiples)[86]   :if (10↑Z)≡'working...'                            ⍝      If tilemap is being built by another task,[87]      :if ~A                                          ⍝         if not writing to Anthill path,[88]  ⍝        (⎕←'Unlocking (1) ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[89]  [90]         UNLOCKFILE H                                 ⍝            return the lock[91]      :end[92]      ⍞←(~U)/'Waiting for another thread to build tilemap for',(⍕G),'(',NOW,')...',⎕TCNL ⋄ FLUSH[93]      [94]  ⍝    [95]  ⍝    QQQ←NOW,': ',name,'.',(⍕thread),' running ',project[96]  ⍝    QQQ←QQQ OVER '   waiting for another thread to build tilemap for ',⍕⊃G [97]  ⍝    t←¯5 120↑VTOM ⎕TCNL,X ⋄ QQQ←⍕QQQ OVER ⍕' ',' ',' ',(¯5↑B),t[98]  ⍝    ⎕←QQQ ⋄ FLUSH ⋄ QQQ LOCKNWRITE pathA,'tilemap\tilemaplog.txt'   [99]  ⍝    [100]     [101]     U←1[102]     T←⎕DL 60                                        ⍝         sleep for a minute[103]     →L10                                            ⍝         and try again[104]  :end[105]  Z←⎕FI((2×⍴Z)⍴1 0)\Z                                ⍝      decode it & return[106]  →L9[107] [108] L1:X←X,⎕TCNL,(C←⊃,/((⊂M),⍕¨G)[2 1 3 4 5],¨⎕TCHT),'working...' ⍝Else, we'll have to build tilemap. Write 'working...' to tilemap.txt[109] [110] ⍝ (⎕←'Writing ',C,' to ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[111] [112]  X NWRITE F[113]  :if ~A                                             ⍝   and return the lock[114] ⍝        (⎕←'Unlocking (2) ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[115] [116]     UNLOCKFILE H[117]  :end[118] [119] ⍝[120] ⍝[121] ⍝    QQQ←NOW,': ',name,'.',(⍕thread),' running ',project[122] ⍝    QQQ←QQQ OVER '   building tilemap for ',⍕⊃G [123] ⍝    t←¯5 120↑VTOM ⎕TCNL,X ⋄ QQQ←⍕QQQ OVER ⍕t[124] ⍝    ⎕←QQQ ⋄ FLUSH ⋄ QQQ LOCKNWRITE pathA,'tilemap\tilemaplog.txt'   [125] ⍝[126] ⍝[127] [128] [129]  tilemaprecover ← A F C ⎕ELX[130]  ⎕ELX←'TILEMAPRECOVER ⋄ ⎕ERROR ⎕DM'                 ⍝   Set error trapping to recover if we crash while building the tile map[131] [132]  L←block                                            ⍝   If only 1 block[133]  →(∨/block[6 7]≠1)/L5[134]  V←1 1⍴1[135]  →L4[136] [137] L5:ifchat←noread←0[138]  block[4 5]←0                                       ⍝      Reset to start of blocks[139] ⍝ ⎕←'Building tilemap library for',(tilemapinclude)/' grid ',(1⊃G),','),' tile size ',(⍕2⊃G),', buffer ',(⍕3⊃G),', and mask group ',(⍕4⊃G),' (',(⍕block[6]),' x ',(⍕block[7]),' tiles)' ⋄ FLUSH[140]  Q←('grid ',1⊃G) ('mask ',M) ('tile size ',⍕2⊃G) ('buffer ',⍕3⊃G) ('mask group ',⍕4⊃G)[141]  Q←(tilemapinclude,(~0∊⍴M),1 1,0≠4⊃G)/Q[142]  ⎕←'Building tilemap library for ',(ONETWOMANY Q),' (',(⍕block[6]),' x ',(⍕block[7]),' tiles)' ⋄ FLUSH[143] [144]  →(~0∊⍴V←M FASTTILEMAP G)/L4                        ⍝   If fast version fails (because grid is too big), resort to old block-by-block version,[145]  V←block[6 7]⍴0[146] [147] ⍝Now figure out how many tiles we can read at once. I think we don't care how many panes read read across--we have to do it some time.[148]  N←⌊(⌊16E6÷block[1]+2×block[3])÷block[2]+2×block[3] ⍝   Shoot for 16M cells (our max size).  This is how many tiles we can read.[149]  ⎕ERROR (N=0)/'Error: tile + buffer is too damn big!'[150]  ⎕←'Reading ',(⍕N⌊(⍴V)[2]),' tiles at a time (',(⍕(⍴V)[1]×⌈(⍴V)[2]÷N),' passes)...' ⋄ FLUSH[151] [152]  I←0[153] L2:→(block[6]<I←I+1)/L4                             ⍝      For each row of tiles,[154]  J←0[155] L3:→(0∊⍴O←J+⍳N⌊block[7]-J)/L6                       ⍝         For each set of column tiles,[156]  block[5]←J+1                                       ⍝            starting column tile[157]  J←J+⍴O[158]  BREAKCHECK[159]  DOT[160]  S←THISBLOCK[1 2],(block[1 2]×1,⍴O),block[3]        ⍝            Starting row, col, size of block, buffer (THISBLOCK results)[161]  :if tilemapinclude                                 ⍝            If tilemapinclude = yes,[162]     Y←READBLOCK (⊂pathG PATH 1⊃G),S                 ⍝               read wide block of include grid[163]     Y←~Y∊0,MV                                       ⍝               included cells[164]  :else[165]     Y←1[166]  :end[167] [168]  :if ~W∨0∊⍴M                                        ⍝               If using mask grid,[169]     Q←READBLOCK (⊂pathG PATH M),S                   ⍝                  read wide block of mask grid[170]     ⍎(G[4]=MV)/'Q←Q≠MV'                             ⍝            if G[4]=MV, everything but MV is in[171]     Y←Y^Q>0-G[4]=¯1                                 ⍝            mask is true if positive; include 0 G[4]=¯1[172]     Q←0⌈0 MVREP Q[173]     :if ~(G[4]∊0 ¯1 MV)∨~∨/,Y                       ⍝            If using maskbits and there's anything in mask,[174]        Y←Y^(⊖((G[4]⍴2)⊤Q))[G[4];;]                  ⍝               apply them[175]     :end[176]  :end[177] [178]  Y←∨⌿Y                                              ⍝            Collapse out rows[179]  K←0[180] L7:→((⍴O)<K←K+1)/L3                                 ⍝            For each tile (have to loop b/c of buffers),[181]  V[I;O[K]]←∨/Y[((K-1)×block[2])+⍳block[2]+2×S[5]]   ⍝               This tile is in if any data in it[182]  →L7[183] [184] L6:block[4]←block[4]+1                              ⍝   Increment tile row[185]  →L2[186] [187] [188] L4:⎕←⎕TCNL,'Tile map:'[189]  ⎕←' ',' ',' ',1 0⍕V[190]  ⎕←'' ⋄ FLUSH[191]  G[1]←⊂1⊃G                                          ⍝Strip path from grid name (a little dangerous?)[192]  block←L                                            ⍝Restore block to its original value[193] [194]  ⎕ELX←4⊃tilemaprecover                              ⍝We're good--turn off error trapping[195]  :if ~A[196] ⍝    ('Locking (F) ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[197] [198]     H←LOCKFILE (1+-(⌽F)⍳'\')↓F                      ⍝Get the lock again[199]  :end[200]  X←VTOM ⎕TCNL,NREAD F                               ⍝Read the file again[201] [202] ⍝[203] ⍝    QQQ←NOW,': ',name,'.',(⍕thread),' running ',project[204] ⍝    QQQ←QQQ OVER '   finished building tilemap for ',⍕⊃G [205] ⍝    t←¯5 120↑X ⋄ QQQ←⍕QQQ OVER ⍕t[206] ⍝    ⎕←QQQ ⋄ FLUSH ⋄ QQQ LOCKNWRITE pathA,'tilemap\tilemaplog.txt'   [207] ⍝[208] [209] [210] ⍝ (⎕←'Finished with ',C,' to ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[211] [212] [213]  I←((⊂C)≡¨↓X[;⍳⍴C])⍳1                               ⍝Find our line[214] [215]  :if I>1↑⍴X[216] ⍝     (⎕←'Error in ',C,' to ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[217]  :end[218] [219]  Q←C,1 0⍕Z←,V[220]  X←((1↑⍴X),(1↓⍴X)⌈⍴Q)↑X                             ⍝Replace it[221]  X[I;]←(1↓⍴X)↑Q[222]  X←1↓MTOV X[223]  X NWRITE F                                         ⍝And write it[224] [225] ⍝[226] ⍝    QQQ←NOW,': ',name,'.',(⍕thread),' running ',project[227] ⍝    QQQ←QQQ OVER '   written tilemap for ',⍕⊃G [228] ⍝    t←¯5 120↑VTOM ⎕TCNL,X ⋄ QQQ←⍕QQQ OVER ⍕t[229] ⍝    ⎕←QQQ ⋄ FLUSH ⋄ QQQ LOCKNWRITE pathA,'tilemap\tilemaplog.txt'   [230] ⍝[231] ⍝[232] [233] L9:→A/0                                             ⍝If writing to a path other than Anthill,[234] ⍝        (⎕←'Unlocking (3) ',F,' (',(⍕3↓⎕TS),')') GETLOCK thread[235] [236]  UNLOCKFILE H                                       ⍝   unlock directory    ∇