    ∇ A ABUFFERS S;B;I;X;W;Q;R;F;Z;U;L;slice;expand;toosmall;M;transparent;dot;E;H;O;fd;P;R2;O2;J;sg;buf;lentic;C;kernels;Y;G;multiplier;wetmultiplier;accumrange;wresistrange;bandwidth;buffer;logistic;T;result;cores[1]   ⍝Build buffers for existing aquatic reserve cores for LCD[2]   ⍝Input grids:[3]   ⍝   cores           existing aquatic core grid (all values ≥1 are cores)[4]   ⍝   land            landcover grid[5]   ⍝   flow            flow grid[6]   ⍝   wresist         time of flow aquatic resistance[7]   ⍝   fd8accum        flow accumulation[8]   ⍝Parameters:[9]   ⍝   cores           name of existing aquaitc core grid[10]  ⍝   result          name of result grid[11]  ⍝   multiplier      multiplier on value for costs[12]  ⍝   accumrange      range of ln(d8flowaccum) across the region (use 5.8 20)[13]  ⍝   wetmultiplier   multiplier for aquatic cores at (min, max) watershed size[14]  ⍝   bandwidth       default bandwidth (h, or s.d. of kernel), in meters[15]  ⍝   logistic        inflection & scaling factor to use for resistance (use 0 for no logistic function)[16]  ⍝   wresistrange    range of wresist grid, used to scale resistance for aquatic cores[17]  ⍝   buffer          number of cells to buffer tiles - should be radius of largest core + bandwidth÷cellsize[18]  ⍝Results:[19]  ⍝   buffers         buffers for cores, quantitative, ready for quantile scaling[20]  ⍝Intended to create buffers for existing cores analogous to those created by ACORES, 2nd pass.  Assumes input cores have[21]  ⍝already been screened for size, lakes have been filled out, etc.  Deals only with centerlines for lotic cells, and all[22]  ⍝lentic cells.  Lentic patches of ≤2 cells are treated as part of any adjacent downstream lotic.[23]  ⍝B. Compton, 6 Jan 2015, from ACORES[24]  ⍝1 Jul 2016: zero out missing flow accumulation from cores (these can come in from anadramous and salmon cores)[25]  ⍝5 Jul 2016: if core has a zillion edge cells, trim a bit so it doesn't take forever--NO! Can't do this, as we need to follow up every path. It's just slow.[26]  ⍝12 Jul 2016: specify input & result in parameters.par to avoid inputs.par/results.par confusion[27]  [28]  [29]  [30]   READPARS ME[31]   lentic←LOOK 'lentic'[32]   X←READ 1⊃1⊃A                                   ⍝Read cores[33]   sg←1=READ 6⊃1⊃A                                ⍝and stream centerlines[34]   W←READ 2⊃1⊃A                                   ⍝and landcover[35]   X←0 MVREP X (W=MV)                             ⍝Carry over missing cells in landcover[36]   X←(X≥1)^sg∨W∊lentic                            ⍝Keep cells in cores + centerlines, or in lakes[37]   H←READ 5⊃1⊃A                                   ⍝Read flow accumulation[38]   X←0 MVREP X (H=MV)                             ⍝Zero out cores beyond flow accumulation (these come from species cores)[39]  [40]   L←FINDPATCH X^W∊lentic                         ⍝Lentic patches[41]   Q←(Q≠0)/Q←,L[42]   Q←Q[⍋Q][43]   B←Q≠0,¯1↓Q[44]   Q←(B/Q),[1.5]B pSUM (⍴B)⍴1                     ⍝Patch #, number of cells[45]   L←L∊(Q[;2]≥2)/Q[;1]                            ⍝Lakes ≥2 cells get their own patches[46]   Y←FINDPATCH X+L                                ⍝Build patches (8-neighbor) - lakes ≥2 cells get their own patches[47]   U←((U⍳U)=⍳⍴U)/U←(,Y≠0)/,Y                      ⍝Bbuild unique core list[48]  [49]  [50]   buf←1+⌈bandwidth÷cellsize                      ⍝Buffer; take 1 extra cell to deal with rounding[51]   E←READ 3⊃1⊃A                                   ⍝Read flow grid[52]   R←READ 4⊃1⊃A                                   ⍝and time of flow resistance[53]   [54]   fd←(2*¯1+⍳8),8 2⍴0 1 1 1 1 0 1 ¯1 0 ¯1 ¯1 ¯1 ¯1 0 ¯1 1[55]   Z←(⍴X)⍴0[56]   ⍞←⎕TCNL,'Building kernels for ',(⍕⍴U),' cores',MB ⋄ FLUSH[57]  [58]   I←0[59]  L4:→((⍴U)<I←I+1)/L7                             ⍝For each core,[60]   BREAKCHECK[61]   DOT[62]   S←Y=U[I]                                       ⍝   Select cells in core[63]   L M ← buf CLIP S                               ⍝   Clip to this core plus buffer[64]   S←S[L;M][65]   O2←(INDICES O←O=⌈/,O←H[L;M]×S)[1;]             ⍝   Identify bottommost cell--we'll always keep this in; O2 is indices[66]  [67]   C←O∨S^0≠E[L;M] UPFLOW ~S                       ⍝   find "edges"--cells in core that stuff flows into from outside[68]   C←INDICES C                                    ⍝   make list of indices[69]   G←(⍴S)⍴0[70]   :if (W[L;M][O2[1];O2[2]])=lentic               ⍝   if it's a lake,[71]      P←multiplier                                ⍝      use standard multiplier[72]   :else                                          ⍝   else, for rivers,[73]      F←⍟H[L;M][O2[1];O2[2]]                      ⍝      ln(flow accumulation at botttommost cell of core before expansion)[74]      P←wetmultiplier[1]+(-/wetmultiplier[2 1])×(F-accumrange[1])÷-/accumrange[2 1]    ⍝   multiplier is a function of watershed area[75]   :end[76]   R2←P RESIST (R-wresistrange[1])÷wresistrange[2]⍝rescale time of flow into resistance[77]  [78]   J←0[79]   dot←⍴⍞←⎕TCNL,(⍕I),' of ',(⍕⍴U),' cores, ',(⍕1↑⍴C),' cells',MB ⋄ FLUSH[80]  L5:→((1↑⍴C)<J←J+1)/L6                           ⍝   For each "edge" cell,[81]   DOT[82]   G←G⌈(÷buf)×WETSPREAD buf (C[J;1]) (C[J;2]) (R2[L;M]) (E[L;M])   ⍝      Build kernel[83]   →L5[84]  [85]  L6:Z[L;M]←Z[L;M]⌈S⌈E[L;M] CORE_WATERSHED G S    ⍝   mask kernel so we only build upstream of core[86]   →L4[87]  [88]  L7:⎕←''[89]   transparent←3                                  ⍝Use max transparency mode[90]   (MVREP Z ((W=MV)∨Z=0)) WRITE 3⊃A               ⍝Save transparently, with all 0's set to missing[91]   →0[92]  [93]  [94]  [95]  what:auxiliary[96]  type:standard[97]  info:(cores 'land' 'flow' (pathS,'wresist') 'fd8accum' 'streams') ('') (result) (buffer⌈⌈bandwidth÷cellsize)       ⍝Source grid, settings table, result grid, and buffer size[98]  check:CHECKVAR 'multiplier bandwidth buffer wetmultiplier accumrange logistic cores result'    ∇