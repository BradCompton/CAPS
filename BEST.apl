    ∇ Z←X BEST N;I;Q;T;E[1]   ⍝Find optimal set of ⍵ sorted items ⍺ (matrix of item #, count, value, list of elements)[2]   ⍝Recursively optimizes set of ⍵ items with no overlapping elements. Count (cost) must be integer.[3]   ⍝Returns value, vector of row numbers in ⍺[4]   ⍝Probably won't work for large ⍵ - time required is related to ⍵![5]   ⍝In our application (LINKRESULTS), ties will be vanishingly rare, so first[6]   ⍝item in list is picked when there's a tie, and multiples will be favored[7]   ⍝B. Compton, 22 Jan 2013[8]   [9]   [10]  [11]   →((⍴X)[2]>3)/L0                ⍝If only 3 columns,[12]   X←(⍳1↑⍴X),X                    ⍝   add row numbers[13]   X←(X[;3]≠0)⌿X                  ⍝   delete 0-valued rows for speed[14]   X←X[⍒X[;3];]                   ⍝   and sort[15]  [16]  L0:Z←(3↑,(X[;2]=N)⌿X)[3 1]      ⍝Best N: (value) (item #)[17]  [18]   I←0[19]  L1:→((N-1)<I←I+1)/0             ⍝For I=1 to N-1,[20]   Q←X BEST I                     ⍝   Get BEST I[21]   E←(E≠0)/E←⊃,/X[X[;1]⍳1↓Q;4]    ⍝   elements in the first pick[22]   T←((~∨/¨X[;4]∊¨⊂E)⌿X) BEST N-I ⍝   And BEST N-I of remaining items without elements in first pick[23]   Q←(Q[1]+T[1]),(1↓Q),1↓T        ⍝   Combine the two[24]   →(Z[1]≥Q[1])/L1                ⍝   pick the best so far[25]   Z←Q[26]   →L1    ∇