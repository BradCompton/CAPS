    ∇ Z←M FASTTILEMAP G;R;I;J;K;L;Y;N;T;Q[1]   ⍝Fast version of TILEMAP (info ⍵, mask ⍺) for landscapes that fit into memory (like Massachusetts)[2]   ⍝Return tile map, or ⍳0 if grid is too big[3]   ⍝B. Compton, 20-21 Aug 2012[4]   ⍝24 Aug 2012: rename from FASTBLOCKMAP; add tilemapinclude; negative mask elements are excluded; new maskgroup interpretations[5]   [6]   [7]   [8]    Z←⍳0[9]    Y←1 ⋄ →(~tilemapinclude)/L5                        ⍝If tilemapinclude = yes,[10]   →(TRY 'Y←READGRID pathG PATH 1⊃G')/0               ⍝   Read whole dang include grid, if possible[11]   Y←~Y∊0,MV[12]  [13]  L5:→(0∊⍴M)/L1                                       ⍝If using mask grid,[14]   →(TRY 'N←0 MVREP READGRID pathG PATH M')/0         ⍝   read it[15]   ⍎(G[4]=MV)/'Q←Q≠MV'                                ⍝   if G[4]=MV, everything but MV is in[16]   Y←Y^N>0-G[4]=¯1                                    ⍝   mask is true if positive; include 0 G[4]=¯1[17]  [18]  L1:⎕←'Using FASTTILEMAP!'[19]  [20]   Z←block[6 7]⍴0=⍴⍴Y[21]   →(0=⍴⍴Y)/0                                         ⍝If neither include grid nor mask, we're done[22]   I←0[23]  L2:→(block[6]<I←I+1)/0                              ⍝For each row of blocks,[24]   BREAKCHECK[25]   J←0[26]  L3:→(block[7]<J←J+1)/L2                             ⍝   For each column,[27]   DOT[28]   R←THISBLOCK[29]   K←((K≥1)^K≤1↑⍴Y)/K←(R[1]-1+R[5])+⍳R[3]+2×R[5][30]   L←((L≥1)^L≤1↓⍴Y)/L←(R[2]-1+R[5])+⍳R[4]+2×R[5][31]   Q←,Y[K;L][32]   →((G[4]∊0 ¯1 MV)∨~∨/,Y)/L4                         ⍝      If using maskbits and there's anything in mask,[33]   Q←Q^,(⊖((G[4]⍴2)⊤N[K;L]))[G[4];;]                  ⍝         apply them (have to do it here so we don't blow out memory)[34]  L4:Z[I;J]←∨/Q[35]   T←NEXTBLOCK[36]   →L3    ∇