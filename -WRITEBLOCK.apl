    ∇ X ∆WRITEBLOCK P;R;C;Q;Y1;X1;P;B;G;M;N;F;err;A;W;firstfail[1]   ⍝Write data ⍺ to block 1↓⍵ of grid (1⊃⍵), primitive function[2]   ⍝Read block 1↓⍵ from grid 1⊃⍵[3]   ⍝   ⍵[1]    grid path & name[4]   ⍝   ⍵[2 3]  starting row & column[5]   ⍝   ⍵[4 5]  nrows & ncols[6]   ⍝   ⍵[6]    buffer in cells (default = 0)[7]   ⍝   ⍵[7]    write MVs transparently (i.e., existing data shows through MVs); if ⍵[7]=2, matrix is added to existing grid, if ⍵[7]=3, max of existing value is taken[8]   ⍝   ⍵[8]    force floating point[9]   ⍝Don't write grid data for all-missing blocks in C mode[10]  ⍝B. Compton, 15-16 Jan 2009; E. Ene, 7 Jan 2009; bug fixed 30 Apr 2009[11]  ⍝8 Jun 2010: C++ version of transparent mode added[12]  ⍝17 Nov 2010: Transparent mode 2 sums to grid[13]  ⍝2 May 2011: set global gridwait for task manager[14]  ⍝14 Mar 2013: make robust to attempts to write beyond origin[15]  ⍝5 Sep 2013: rename from WRITEBLOCK[16]  ⍝11 Oct 2013: oops: only bail on all nodata if transparent mode is on--we might want to write MV over existing data[17]  ⍝29 Oct 2013: don't drop buffer any more--this now happens in WRITEBLOCK[18]  ⍝13 Nov 2013: add grid server recovery[19]  ⍝14 Nov 2013: fix parameter screw-up[20]  ⍝21-22 Nov 2013: check for multitiled grid and give error[21]  ⍝24 Jan 2014: give an error when attempting to write too large a block[22]  [23]  [24]  [25]   G←1⊃P ⋄ P←8↑(1↓P),0[26]   →(aplc=1)/L7                       ⍝If C version,[27]  [28]    ⎕ERROR (16E6<×/P[3 4])/'Error: block of ',(⍕P[3]),' rows by ',(⍕P[4]),' columns is too large to write to a grid'[29]  [30]   →((P[7]≠0)^^/,X=MV)/0              ⍝If transparent and all nodata, no need to write anything![31]   →(3=⎕NC'WRITEBLOCKc')/L1           ⍝   If not loaded,[32]   Q←⎕EX 'WRITEBLOCKc'[33]   ⎕ERROR REPORTC 'DLL I4←CAPS_LIB.writeblock_dbl(*C1,I4,I4,I4,I4,F8,*F8,I4)' ⎕NA 'WRITEBLOCKc'[34]   ⎕ERROR REPORTC 'DLL I4←CAPS_LIB.writeblock_int(*C1,I4,I4,I4,I4,I4,*I4,I4)' ⎕NA 'WRITEBLOCKIc'[35]  ⍝⎕←'CAPS_LIB.writeblock_dbl and .writeblock_int loaded.'[36]  [37]  L1:Y1 X1 R C B M F ← 7↑P                        ⍝Default: no buffer, not transparent, don't force floating point[38]   X←(¯2↑1 1,⍴X)⍴X[39]   →((P[7]≠0)^^/,X=MV)/0                          ⍝If transparent and all nodata, no need to write anything![40]   :if ∨/Y1 X1≤0                                  ⍝If writing beyond orgin,[41]      W←0⌈1-Y1 X1                                 ⍝   drop this part of grid[42]      Y1 X1 ← 1⌈Y1 X1[43]      R C ← R C - W[44]      X←W↓X[45]   :endif[46]   ⎕ERROR (∨/(R,C)≠⍴X)/'.WRITEBLOCK: Wrong size matrix'[47]  L2:Q←GRIDTYPE G[48]   :if Q≠0[49]      ⎕ERROR (MULTITILE G)/'Error: grid ',G,' is a multitiled ESRI grid - it can''t be written'[50]   :end[51]   A←⎕AI[2][52]   →(Q=0 1 2)/L5,L3,L4                            ⍝Case grid type,[53]  L3:err←WRITEBLOCKIc (G,⎕TCNUL) Y1 X1 R C MV X M ⍝   Integer grid[54]   →(RECOVERY err)/L3                             ⍝   Wait for crashed grid servers to recover[55]   →L6[56]  [57]  L4:err←WRITEBLOCKc (G,⎕TCNUL) Y1 X1 R C MV X M  ⍝   Floating point[58]   →(RECOVERY err)/L4                             ⍝   Wait for crashed grid servers to recover[59]   →L6[60]  [61]  L5:((1+F∨645=⎕DR X),1) GRIDCREATE G             ⍝   Grid doesn't exist--create it[62]   →L2[63]  [64]  L6:GRIDWAIT A[65]   ⎕ERROR G REPORTC err[66]   →0[67]  [68]  L7:(G,(~'.'∊G)/'.asc') (BLOCKPOS) WRITEBLOCKa X ⍝APL version: read from .asc grid.  N.B.: writes to current block, not specified one. Also no transparent mode.    ∇