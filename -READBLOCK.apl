    ∇ Z←H ∆READBLOCK GP;Q;A;T1;T2;T3;T4;T5;T6;G;P;err;E;firstfail[1]   ⍝Read block 1↓⍵ from grid 1⊃⍵, with optional grid description ⍺; primitive function[2]   ⍝   ⍵[1]    grid path & name[3]   ⍝   ⍵[2 3]  starting row & column[4]   ⍝   ⍵[4 5]  nrows & ncols[5]   ⍝   ⍵[6]    buffer in cells (default = 0)[6]   ⍝Optionally passed grid description ⍺[7]   ⍝B. Compton, 15 Jan 2009; E. Ene, 7 Jan 2009[8]   ⍝2 May 2011: set global gridwait for task manager (20 May: do it right!)[9]   ⍝25 Apr 2013: make robust to attempts to read beyond origin[10]  ⍝5 Sep 2013: rename from READBLOCK[11]  ⍝9 Sep 2013: no longer set header/gridwindow[12]  ⍝30 Sep 2013: optionally passed grid description[13]  ⍝13 Nov 2013: add grid server recovery[14]  ⍝21 Nov 2013: check for multitiled grid and give error[15]  ⍝24 Jan 2014: give an error when attempting to read too large a block[16]  ⍝20 Jun 2016: round to single-precision (Full moon solstice). 28 Jun 2016: but don't round integer grids!!![17]  [18]  [19]  [20]   :if 0≠⎕NC'noread'[21]      →noread/1↑⍴Z←0 0⍴''[22]   :end[23]   G←1⊃GP ⋄ P←5↑1↓GP[24]  [25]   ⎕ERROR (16E6<×/P[3 4])/'Error: block of ',(⍕P[3]),' rows by ',(⍕P[4]),' columns is too large to read from a grid'[26]  [27]   →(aplc=1)/L9                        ⍝If C version,[28]   →(3=⎕NC'READBLOCKc')/L1             ⍝   If not loaded,[29]   Q←⎕EX 'READBLOCKc'[30]   ⎕ERROR REPORTC 'DLL I4←CAPS_LIB.readblock_dbl(*C1,I4,I4,I4,I4,I4,F8,*F8←)' ⎕NA 'READBLOCKc'[31]   ⎕ERROR REPORTC 'DLL I4←CAPS_LIB.readblock_int(*C1,I4,I4,I4,I4,I4,I4,*I4←)' ⎕NA 'READBLOCKIc'[32]  ⍝⎕←'CAPS_LIB.readblock_dbl and .readblock_int loaded.'[33]  [34]  L1:E←0⌈1-P[1 2] ⋄ P[⍳4]←(1⌈P[1 2]),P[3 4]-E   ⍝Make sure we're not reading beyond west/north edges[35]   ⎕ERROR (MULTITILE G)/'Error: grid ',G,' is a multitiled ESRI grid - it can''t be read'[36]   :if 0=⎕NC'H'                       ⍝If grid description wasn't passed,[37]      H←∆GRIDDESCRIBE G               ⍝   Get info[38]   :end[39]   T1 T2 T3 T4 T5 T6←P,MV[40]   A←⎕AI[2][41]   →(H[7]=2)/L2                       ⍝If integer grid,[42]   Z←(P[3 4]+2×P[5])⍴0[43]  L4:err Z←READBLOCKIc (G,⎕TCNUL) T1 T2 T3 T4 T5 T6 Z[44]   →(RECOVERY err)/L4                 ⍝Wait for crashed grid servers to recover[45]   →L3[46]  [47]  L2: Z←(P[3 4]+2×P[5])⍴0.1           ⍝Else, floating point[48]  L5:err Z←READBLOCKc (G,⎕TCNUL) T1 T2 T3 T4 T5 T6 Z[49]   Z←7 ROUND Z                        ⍝Round to single precision to prevent goofy rounding errors[50]   →(RECOVERY err)/L5                 ⍝Wait for crashed grid servers to recover[51]  [52]  L3:GRIDWAIT A[53]   Z←((E[1],(⍴Z)[2])⍴MV)⍪Z            ⍝Fill out grid if we've read beyond 0,0[54]   Z←(((⍴Z)[1],E[2])⍴MV),Z[55]   ⎕ERROR G REPORTC err[56]   →0[57]  [58]  L9:Z←P READBLOCKa G,(~'.'∊G)/'.asc' ⍝APL version: read from .asc file    ∇