    ∇ Z←FINDCONNECTION_APL_R W;D;E;I;P;Q[1]   ⍝Find the connection matching window 1⊃⍵ on optional path 2⊃⍵[2]   ⍝⍵ is ncol, nrow, xll, yll, cellsize[3]   ⍝Result is matched connection number or 0 if no matches.[4]   ⍝Multiple matches are resolved by checking to see if the drive[5]   ⍝associated with one of the connections matches the path or,[6]   ⍝failing that, by returning the first matching connection.[7]   ⍝B. Compton, 4 and 7 Oct 2013. The government is still shut down.[8]   [9]   [10]  [11]   ⍎(1≥≡W)/'W←W '''''[12]   W P ← W[13]  [14]  ⍝  # Preallocate vectors for keeping track of which connections match the arguments[15]  ⍝  drivematches <-  extentmatches <- rep(FALSE, nrow(.status$connections))[16]  [17]   D←E←(1↑⍴connections)⍴0                                 ⍝Bit vectors for drive matches and extent matches[18]  [19]  ⍝  # Identify matching extents[20]  ⍝  for(i in 1:length(extentmatches))[21]  ⍝    if(coincide(as.list(.status$connections[i, ]), x)) extentmatches[i] <- TRUE[22]  [23]   E←(⊂W)≡¨5↑¨connections[;connections_ COL 'window']     ⍝Matching extents[24]  [25]  ⍝  # if there are one or no matching extents or drive is undefinied we don't need to worry[26]  ⍝  # about the drive and we'll just return the first matching extent or NA for no matches.[27]  ⍝  if(sum(extentmatches) ==0) return(NA)[28]  ⍝  if(sum(extentmatches) == 1 | path=="" | is.na(path)) return(which(extentmatches)[1])[29]  [30]   →(~∨/E)/Z←0                                            ⍝If no matching extents, return 0[31]   Z←''⍴E/⍳⍴E ⋄ →((1=+/E)∨P≡'')/0                         ⍝If only 1 match or no path specified, return 1st connection[32]  [33]  ⍝  # More than one extent matches. We'll use drive to find the best match if we can.[34]  ⍝  path <- tolower(path)[35]  ⍝  path <- gsub("\\\\", "/", path)[36]  ⍝  # Determine whether each drive matches[37]  ⍝  for(i in 1:length(drivematches)){[38]  ⍝    d <- as.character(.status$connections$drive[i])[39]  ⍝    if(is.na(d) || d == ""){[40]  ⍝      drivematches[i] <- NA[41]  ⍝    }else {[42]  ⍝      p <- substr(path, 1, nchar(d))[43]  ⍝      drivematches[i] <- p==d[44]  ⍝    }[45]  ⍝  }[46]  [47]   D←connections[;connections_ COL 'drive'] FIND P        ⍝More than one extent matches, so do best match based on drive[48]  [49]  ⍝  a <- drivematches & extentmatches[50]  ⍝[51]  ⍝  if( sum(!is.na(a) & a) > 0) return(which(a)[1])  # one or more matches for both extent and drive return the first[52]  [53]   →((⍴D)≥Z←(D^E)⍳1)/0                                    ⍝If one or more matches for extent and drive, return the first[54]  [55]  ⍝[56]  ⍝  a[is.na(a)] <- TRUE[57]  ⍝  if(sum(a) > 0) return(which(a)[1])  # if no complete matches accept matches where the drive is undefined[58]  [59]   Q←E∨D∨0∊¨⍴¨connections[;connections_ COL 'drive']      ⍝If no matches with drive, accept one undefined drive[60]   →((⍴Q)≥Z←Q⍳1)/0[61]  [62]  ⍝  return(which(matches)[1])  # fall back position if none of the drive matching worked out just take the first extent that matches.[63]  ⍝}[64]  [65]   Z←D⍳1                                                  ⍝Final fallback is to take first extent that matches[66]  [67]  [68]  [69]   →0[70]  ⍝Test code:[71]  [72]   CLEANUP[73]   GRIDINIT 'glyptemys' 3339 'C:'[74]   MAKEWINDOW 15 12 0 0 10[75]   1 GRIDINIT 'glyptemys' 3338 'D:'[76]   MAKEWINDOW 8 6 0 0 20[77]   1 GRIDINIT 'glyptemys' 3337 'D:'[78]   MAKEWINDOW 15 12 0 0 10[79]   1 GRIDINIT 'glyptemys' 3336[80]   FINDCONNECTION 15 12 0 0 30[81]  [82]  [83]   CLEANUP ⋄ GRIDINIT 'glyptemys' 3339 'C:' ⋄ MAKEWINDOW 15 12 0 0 10 ⋄ 1 GRIDINIT 'glyptemys' 3338 'D:' ⋄ MAKEWINDOW 8 6 0 0 20 ⋄ 1 GRIDINIT 'glyptemys' 3337 'D:' ⋄ MAKEWINDOW 15 12 0 0 10 ⋄ 1 GRIDINIT 'glyptemys' 3336 ⋄ FINDCONNECTION 15 12 0 0 30    ∇