    ∇ Z←E READBLOCKC GP;G;P;D;L;D_;T;I;V;H;Q;head;C;mingrids;W;⎕ELX;lock;A;S;cacheok;iscached;copying;F;ci;N[1]   ⍝Get block from grid 1⊃⍵, with optional grid description ⍺; potentially using caching[2]   ⍝   ⍵[1]    grid path & name[3]   ⍝   ⍵[2 3]  starting row & column[4]   ⍝   ⍵[4 5]  nrows & ncols[5]   ⍝   ⍵[6]    buffer in cells (default = 0)[6]   ⍝   ⍵[7]    nocache - okay to cache grid? (default = 0)[7]   ⍝Optionally passed grid description ⍺[8]   ⍝This version manages the local grid cache. Caching is initialized on each machine with CACHEINIT[9]   ⍝B. Compton, 16 Sep 2013[10]  ⍝30 Sep 2013: optionally passed grid description[11]  ⍝1 Oct 2013: finish this off, after a long hiatus on the Allagash[12]  ⍝21 Oct 2013: oops. Set sourcedate to the grid's modification date, not caching date.  Gay marriages in NJ today; Christie drops appeals.[13]  ⍝21 Nov 2013: format xll and yll to a whole lot of digits in cache directory; 25 Nov: and cellsize[14]  ⍝25 Nov 2013: call FILEINFO separately for grid and cache drive[15]  ⍝3 Dec 2013: save cached directory while we still have the lock; throw an error if it takes longer than 10 minutes for another thread to copy a grid to the cache[16]  ⍝9 Dec 2013: suppress caching if global caching = 0; 19 Dec: and, or, it's all the same...isn't it?[17]  ⍝6 Feb 2014: Deal properly with lock-releasing ⎕ELX from call to GETCACHEDIR; check here for multitiled grids so we don't copy them to the cache[18]  ⍝11 Mar 2014: unlock before ⎕ERROR, though error-handling should catch it anyway[19]  ⍝1 Apr 2014: tell MAKEDIR not to get a second lock on cache--we already have the right one[20]  ⍝1 May 2014: wait 30 min instead of 10 for grid to be copied by another thread[21]  ⍝28 Aug 2014: oops! was double-counting existing cache when figuring out whether to delete grids from cache.[22]  ⍝18 Nov 2014: oops! check for grid×10 being too big was wrong, turning off caching when cache was full![23]  ⍝21 Nov 2014: add cachewait[24]  ⍝2 Dec 2014: Nov 18th change broke check for cached grid too big (Reva's funeral today)[25]  ⍝4 Dec 2014: redo cache size checking & grid deletion to give much-needed clarification (and test it)[26]  ⍝12 Aug 2015: I broke caching with a new directory on 18 Nov 2014, and finally found it when we replaced a bad drive!; 17 Aug 2015: oops[27]  ⍝19-20 May 2016: MAJOR REWRITE for hashed caches[28]  ⍝7 Jun 2016: throw error if FRISKCACHE fails--it's crazy to frisk for every read[29]  ⍝6 Sep 2016: When waiting for copy, re-find grid in index in case it moved...if it's no longer in the index, move on semi-gracefully[30]  ⍝31 Jan 2017: change 'wait' to 'cachetimeout' and add it to config.txt. Needs to be 60 min, because frisking takes up to 40 min[31]  ⍝26 Apr 2017: when waiting for a copying grid times out, instead of giving an error, initiate another copy (because KILL often leaves hanging copying entries)[32]  ⍝7 Nov 2017: call CHECKCACHEINFO to try to find cache discrepancy bug[33]  ⍝27 Nov 2017: was crashing if another process frisked away stuck copying grid[34]  ⍝1 Dec 2017: reread cacheinfo.txt after FRISKCACHE, dummy![35]  ⍝5 Dec 2017: simplify if stuck copying grid is frisked away[36]  [37]  [38]  [39]   mingrids←10                               ⍝Minimum number of grids in cache (mingridcapacity)[40]   ⍎(0=⎕NC'cachetimeout')/'cachetimeout←60'  ⍝Number of minutes to wait for grid to be copied to cache by another thread before giving error...10 min was too short...30 was too[41]   G←TOLOWER 1⊃GP ⋄ P←6↑1↓GP[42]   :if 0≠⎕NC'noread'[43]      →noread/1↑⍴Z←0 0⍴''[44]   :end[45]  [46]  [47]  ⍝-----PART I: figure out caching, copy grid if necessary-----[48]  [49]   GETCACHECONFIG[50]   [51]   W←0 ⋄ N←'---) as cache-in-place'                   ⍝Wait count, for copying; tracking for cache-in-place [52]   :if cacheok←cache[1]^caching^~P[6]                 ⍝If caching is on and not suppressed for this grid,[53]      V←FILEINFO G,'\'                                ⍝   Get grid size & make sure it exists[54]      ⎕ERROR (0∊⍴V)/'Source grid ',G,' does not exist'[55]      →((⊂2↑2⊃cache) FIND ⊂2↑H←G)/L1                  ⍝   If grid is on same drive as cache, cache-in-place[56]      D L lock A ← 0 GETCACHEDIR G                    ⍝   Get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[57]      D D_ ← D                                        ⍝   grid cache directory & header[58]   [59]      :if iscached←0≠I←I←D D_ LOOKUP_GRID G           ⍝   If grid is in directory,[60]         :while (⊃D[I;D_ COL 'status'])≡'copying'     ⍝      While waiting for grid to be copied by another thread,[61]            CACHEWAIT A[62]            :if cachetimeout<T←(⎕TS ELAPSED PARSEDATE ⊃D[I;D_ COL 'cachedate'])÷60      ⍝         Wait an hour (or whatever) for grid to copy[63]                iscached←0                            ⍝            if it times out, clear iscached and drop out of while...we'll copy the damn thing ourselves later[64]                :leave[65]  ⍝             ⎕ERROR 'Error: grid ',G,' cached on ',GETNAME,' has had ''copying'' status for ',(⍕⌊T),' minutes'[66]            :end                                      ⍝         else, wait for copy[67]            UNLOCKFILE lock                           ⍝         return lock[68]            :if 1=W←W+1[69]               ⎕←'--> Waiting for grid ',G,' to be copied to cache (',NOW,')...' ⋄ FLUSH[70]            :end[71]            T←⎕DL 120                                 ⍝         wait 2 minutes[72]            D L lock A ← 0 GETCACHEDIR G              ⍝         get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[73]            D D_ ← D                                  ⍝         grid cache directory & header[74]            I←D D_ LOOKUP_GRID G                      ⍝         re-find grid in directory--it may have moved if FRISKCACHE deleted grids[75]            :if I=0                                   ⍝         if the grid isn't in the directory,[76]               iscached←0                             ⍝            the copying thread must have given up...trigger the whole process again[77]               →L2                                    ⍝            skip ahead to dealing with uncached grid[78]            :end[79]         :end[80]  [81]         :if ~(PARSEDATE ⊃D[I;D_ COL 'sourcedate'])≡PARSEDATE 2⊃V     ⍝      If grid is stale,[82]            iscached←0[83]            D[I;D_ COL 'source status']←⊂'expired'    ⍝      Cached grid is out of date--we'll deleted it on next frisk[84]         :end[85]      :end[86]      [87]  L2:[88]      :if ~iscached                                   ⍝   If grid isn't in cache,[89]         :if MULTITILE G                              ⍝      If multitiled grid,[90]            UNLOCKFILE lock                           ⍝         return lock & throw error[91]            CACHEWAIT A[92]            ⎕ERROR 'Error: grid ',G,' is a multitiled ESRI grid - it can''t be read'[93]         :end[94]  [95]         D←D⍪0                                        ⍝      add grid to index[96]         D[I←1↑⍴D;D_ COL 'source status size reads cachedate sourcedate']←G 'copying' (V[1]) '' NOW (2⊃V) [97]         D D_ PUTCACHEDIR G[98]         UNLOCKFILE lock                              ⍝      return cache index lock[99]         CACHEWAIT A[100]         [101]        A←⎕AI[2]                                     ⍝      Start cachewait timer[102]        lock←LOCKFILE GETNAME,' cache'               ⍝      Get a lock on cacheinfo[103]        copying←1[104] [105]        [106]       [107]        ci←,0 MATIN F←(2⊃cache),'index\cacheinfo.txt'⍝      Read cacheinfo[108]        S←cache[3]⌊ci[2]+(FILEINFO 2⊃cache)[3]-cache[4] ⍝      Space available for cache (maxsize MIN used + free - minfree)[109]        :if (V[1]×mingrids)>S                        ⍝      If (grid×10) is too big to fit in empty cache[110]           TRACK '   [READBLOCKC: cache isn''t big enough to cache ',G,' ',NOW,']'[111]           copying←cacheok←0                         ⍝         suppress caching and read from gridserver[112]        :else                                        ⍝      else[113]           :if S<(V[1]+ci[2])                        ⍝         If we're requesting too much space ((grid size + cache size) > total available for cache),[114]              TRACK '   [READBLOCKC: calling FRISKCACHE to free up space for grid ',G,' ',NOW,']'[115]              :if ~0 0 FRISKCACHE V[1]⌈cache[6]      ⍝            FRISKCACHE to delete a bunch of grids and make space[116]                 UNLOCKFILE lock                     ⍝            return cache index lock[117]                 ⎕ERROR 'Cache is full and there is no way to free sufficient space without deleting grids that have been read recently. Probably your cache is too small to be useful.'                   ⍝            If FRISKCACHE fails, throw error[118]              :end [119]              ci←,0 MATIN F                          ⍝         Re-read cacheinfo, as FRISKCACHE will have changed it![120]           :end[121]        :end[122] [123] [124] [125] [126] [127]        :if copying                                  ⍝      If we're copying the grid (1st time),[128]           ci[1]←ci[1]+1                             ⍝         increment cache id[129]           ci[2]←ci[2]+V[1]                          ⍝         and update total cache size                           [130]           ((⍕ci[1]),⎕TCNL,⍕ci[2]) NWRITE F          ⍝         write cacheinfo[131]        :end[132]  [133]        UNLOCKFILE lock                              ⍝         return cache index lock[134]        CACHEWAIT A[135] [136] [137]        :if copying                                  ⍝      If we're copying the grid (2nd time),[138]           TRACK '   [READBLOCKC copying grid ',G,' to cache, ',NOW,']'[139]           SETCACHE 1                                ⍝         use local grid server to copy grid[140]           ACTIVATECONNECTION[141]           1 MAKEDIR C←(2⊃cache),(⍕ci[1]),'\'        ⍝         target to cached grid; make containing folder[142]           G GRIDCOPY C←C,STRIP G                    ⍝         copy grid to the cache[143]           TRACK '   [READBLOCKC has copied grid ',G,' to cache, ',NOW,']'[144]        :end[145] [146]        D L lock A ← 0 GETCACHEDIR G                 ⍝      Get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[147]        D D_ ← D                                     ⍝      grid cache directory & header[148]        I←D D_ LOOKUP_GRID G                         ⍝      find grid in directory[149] [150]        :if copying                                  ⍝      If we're copying the grid (3rd time),[151]           D[I;D_ COL 'cache status']←C 'ready'      ⍝         update cache location and status[152]        :else                                        ⍝      else,[153]           D←(I≠⍳1↑⍴D)⌿D                             ⍝         remove this grid from index[154]           D D_ PUTCACHEDIR G                        ⍝         write cache index          [155] [156] [157] [158] [159]           UNLOCKFILE lock                           ⍝         return cache index lock[160]           CACHEWAIT A[161]        :end[162]     :end       [163]  :end[164]  [165]       [166]  ⍝-----PART II: read block-----[167]  :if cacheok                                        ⍝If caching, read block from cache,[168]     Q←1↓'/' MTOV T[⍳5⌊1↑⍴T←NOW OVER '/' MATRIFY Q←⊃D[I;D_ COL 'reads'];][169]     D[I;D_ COL 'reads']←⊂Q                          ⍝    Update access timestamps[170]     head←1↓⎕TCHT MTOV D_[171] ⍝    D[;D_ COL 'xll yll cellsize']←FMTALL D[;D_ COL 'xll yll cellsize']    ⍝   Format xll, yll, and cellsize with a zillion digits[172]     H←⊃D[I;D_ COL 'cache']                          ⍝   Cached grid name[173]     N←(GETCACHEPATH G),') as cached version'        ⍝   (for tracking)[174]     D D_ PUTCACHEDIR G                              ⍝   Write directory[175]     UNLOCKFILE lock                                 ⍝   Unlock[176]     CACHEWAIT A[177] [178] L1: SETCACHE 1                                      ⍝   Read from local grid server (entry for cache-in-place)[179]     ACTIVATECONNECTION[180]     TRACK '   [READBLOCKC reading ',G,', from ',H,' (index: ',N,']'[181]     :if 0=⎕NC 'E'                                   ⍝   Read from the grid (pass grid info if we already have it)[182]        Z←∆READBLOCK (⊂H),P[183]     :else[184]        Z←E ∆READBLOCK (⊂H),P[185]     :end[186]  :else                                              ⍝Else, read from grid server[187]     ⎕ERROR (MULTITILE G)/'Error: grid ',G,' is a multitiled ESRI grid - it can''t be read'[188]     SETCACHE 0                                      ⍝   turn off reading from local grid server[189]     ACTIVATECONNECTION[190]     TRACK '   [READBLOCKC reading ',G,', uncached]'[191]     Z←∆READBLOCK (⊂G),P                             ⍝   and read the block normally[192]  :end    ∇