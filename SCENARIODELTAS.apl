    ∇ A SCENARIODELTAS S;M;L;scenarios;X;H;I;J;Y;C;compare;N;Q;D;Z;V;T;B;R;G;change;F;grid;postmetrics;weights;names;badnames;index;prettymodel;includemetrics;O;dot;source;W;K;del;scenarios_;head;E;U;plainname;P;F3;dev;F2;inflate;excludemetrics[1]   ⍝Post-process scenarios[2]   ⍝1st scenario in list is treated as base scenario; all others are compared to it[3]   ⍝Runs as CAPS metric[4]   ⍝Ignores systems; use weights.par to select communities[5]   ⍝Parameters:[6]   ⍝   scenarios   Scenarios file[7]   ⍝   compare     Comparison type: 1st (='base'), in time-step pairs ('paired'), or all against all ('full')[8]   ⍝   change      Type of change: 'direct', 'indirect', or 'both'[9]   ⍝   futuregrids Names of future metrics--these are treated as 0 in base scenario[10]  ⍝   futurepath  Alternate path for future metrics[11]  ⍝   regional    Benchmarks were created with REGIONALPOST, so include _full_1 in benchmark name[12]  ⍝Results (in deltas\):[13]  ⍝   <metric><scenario(s)>   Delta for each metric between scenarios being compared[14]  ⍝   delta<scenario(s)>      Combined delta, also known as ∆IEI[15]  ⍝   impact<scenario(s)>     Impact, IEI-weighted ∆IEI[16]  ⍝   indirect<scenario(s)>   Indirect delta only[17]  ⍝   model\deltatables.sf    Aspatial results for each block, for SUMMARIZESCENARIOS[18]  ⍝      1. Scenario names[19]  ⍝      2. Community classes[20]  ⍝      3. Metrics (IEI 1st)[21]  ⍝      4. Years[22]  ⍝      5. Cellsize[23]  ⍝B. Compton, 21 Aug and 1-9 Sep 2009[24]  ⍝3 Jan and 13-17 Feb 2012: renamed from SCENARIOS; revised to CAPS 3.0; return impact as well as deltas[25]  ⍝20 Feb 2012: some debugging; drop SCENARIO_RESULTS[26]  ⍝29 Mar-3 Apr 2012: implement new logistic rescaling; more on 10 Apr 2012; 9 May 2012: use 90th percentile[27]  ⍝21 Jun 2012: be careful reversing integrity metrics[28]  ⍝13 Jul 2012: each scenario can specify different lists of metrics[29]  ⍝31 Jul 2012: don't rescale resiliency metrics[30]  ⍝3 Oct 2012: bug when metrics weren't specified[31]  ⍝4 Oct 2012: 3 bugs[32]  ⍝7 Oct 2012: write years to deltatables.sf; 10 Oct 2012: and cellsize[33]  ⍝25 Apr 2013: use new version of PATIENTTIE, which uses lock server instead of APL file locking[34]  ⍝20 May 2013: for direct change, don't multiply by 2 any more; use maskbits to mask each metrics separately; work right when landcover = MV[35]  ⍝28 May-4 Jun 2013: account for both gains and losses when direct change, and call QUICKPOST if necessary; aspatial results are in IEI-ha[36]  ⍝17 Jun 2013: when mitigating, expect mitigation factor grid in results\ - multiply IEI by it[37]  ⍝20 Jun 2013: bug: was inappropriately reversing resiliency metrics, thanks to 31 Jul 2012 change[38]  ⍝20 Jun 2013: inflate ∆IEI by 100 so values aren't too tiny to handle[39]  ⍝24-25 Jun 2013: add mask column to scenarios.par[40]  ⍝2 Jul 2013: inflate IEI properly, thank you! Use inflate. Also, wasn't scaling ∆IEI to ha for some unknown reason; round when writing to grids to avoid FP errors[41]  ⍝29 Jul 2013: minor mask bug - was bailing on global mask when local mask existed[42]  ⍝2 Jul 2014: use mitigation discount; and rearrange to create IEI(alt) whenever ∆IEI>0[43]  ⍝1 Dec 2014: don't convert mitigation discount from percent again; produce quick IEI when change to natural, not just for impact[44]  ⍝9 Dec 2014: always calculate IEIalt when ∆IEI>>0 (account for rounding errors) when called from CSE, because we need it for impact[45]  ⍝18-20 Apr 2017: if regional, use scenario file name from REGIONALPOST [46]  ⍝21 Apr 2017: for futuregrids (searise and climate), use 0 for base timestep, and MAKENAMES gives future path for future timestep[47]  ⍝24 Apr 2017: use MOSAICNAME to substitute _m if necessary (since we can't use GRIDAME here)[48]  ⍝25 Apr 2017: add devonly to facilitate running development-only scenarios without worrying about alt IEI (12 yards of compost delivered!)[49]  ⍝8 May 2017: OMG! I was dropping direct change from delta & impact grids. Fucking A.[50]  ⍝15 May 2017: oh shit...I was using alternate IEI whenever delta was positive--makes no sense for development-only scenarios (Trump hands over classified info to Russians...it's something new every day)[51]  ⍝22 May 2017: missing values for direct loss were getting through in tabular output as IEI-¯9999 and IEI-¯9999*2[52]  [53]  [54]  [55]   READPARS 'scenarios'[56]   POSTSOURCE 'scenarios'[57]  [58]   inflate←1                                          ⍝Factor to inflate deltas by, to get values in a reasonable range (might want to use 100 for CSB)[59]   scenarios←1 TABLE scenarios                        ⍝Read scenarios file[60]   scenarios_←(',',⎕TCHT) MATRIFY '.".' TEXTREPL head ⍝and get header[61]   scenarios←((⍴scenarios)⌈0,1↑⍴scenarios_)↑scenarios,⊂''[62]   L←MIX⊃¨postland MAKENAMES scenarios[;scenarios_ COL 'land']    ⍝Landcover grid names for each scenario--we'll always use the base landcover[63]  [64]  ⍝Put together scenario × metric table[65]   R←TOLOWER¨(↓MATRIFY includemetrics),(0∊⍴includemetrics)/postmetrics  ⍝Only need to deal with metrics involved in scenarios--others won't change[66]   R←R~FRDBL¨↓MATRIFY excludemetrics                              ⍝exclude metrics we don't want[67]  [68]   U←((U⍳U)=⍳⍴U)/U←⊃,/M←FRDBL¨¨↓¨MATRIFY¨scenarios[;scenarios_ COL 'metrics'][69]   R←(1+~0∊⍴U)⊃R U                                                ⍝If metrics specified in scenarios table, use those[70]   M←(1+~0∊⍴U)⊃((1↑⍴scenarios)⍴⊂R) M[71]   M[(0=⊃,/⍴¨M)/⍳⍴M]←⊂R                                           ⍝Any empty lists get all metrics[72]   H←↑R MAKENAMES scenarios[;scenarios_ COL 'results']            ⍝Scenario × metric table[73]   H←FRDBL¨(⍴H)⍴B\(B←⊃,/(⊂R)∊¨M)/,H[74]  [75]   G←⊃,/'iei' MAKENAMES scenarios[;scenarios_ COL 'iei']          ⍝IEIs by scenario[76]   T←benchpath,(0∊⍴benchpath)/pathE[77]   E←MATIN T PATH 'benchmark1',(gradient/'g'),(regional/'_full_1'),'.csv'              ⍝Read benchmark file[78]   E←E[;(MATRIFY head) MATIOTA MATRIFY 'metric count q0.9']       ⍝Take weighted sum of 90th percentile for each metric[79]   B←~E[;1]≡¨(⊂''),¯1↓E[;1][80]   E←(B⌿TOLOWER¨E[;1]),[1.5]B pSUM E[;3]×E[;2]÷(B pSUM (⍴B)⍴1)/B pSUM E[;2][81]  [82]  ⍝Comparisons can be base: 1st against each other, paired: paired time steps, or full: all against all[83]   change←'direct' 'indirect' 'both'⍳⊂TOLOWER change  ⍝What kind of change to look at?  Direct, indirect, or both?[84]   compare←TOLOWER compare[85]   B←(⍳1↑⍴L)∘.<⍳1↑⍴L                                  ⍝Upper triangle[86]   T←(1,[1.5]1↓⍳1↑⍴L) ((¯1↓⍳1↑⍴L),[1.5]1↓⍳1↑⍴L) ((,B)⌿(,⍉T),[1.5],T←(2⍴1↑⍴L)⍴⍳1↑⍴L)[87]   C←('base' 'paired' 'full'⍳⊂compare)⊃T              ⍝Comparisons (base, paired, or full)[88]   D←scenarios[C;scenarios_ COL 'name'][89]   U←MIX,/(0,compare≡'base')↓D                        ⍝Comparison names (if base, omit base name)[90]  [91]   →(0∊⍴mask)/L0                                      ⍝If mask grid supplied,[92]   F←0 MVREP READ MOSAICNAME mask                     ⍝   read it (will use maskbits for each metric)[93]  [94]  L0:W←((1↑⍴C),(⍴names),2+1↑⍴R)⍴0                     ⍝Aspatial results: scenario × system × (delta, impact, metrics)[95]   I←0[96]  L1:→((1↑⍴C)<I←I+1)/L9                               ⍝For each comparison,[97]   BREAKCHECK[98]   LOG '   Comparison: scenario ',(⊃D[I;1]),' vs. scenario ',⊃D[I;2][99]   del←⊃scenarios[C[I;2];scenarios_ COL 'deltas'][100]  →(IFEXISTS del)/L7                                 ⍝   If result path doesn't exist,[101]  MAKEDIR del                                        ⍝      Create it[102] L7:X←READ MOSAICNAME L[C[I;1];]                     ⍝   Base scenario landcover[103]  :if ∨/' '≠T←⊃scenarios[C[I;2];scenarios_ COL 'mask']⍝   If mask supplied in mask column,[104]     F2←0 MVREP READ MOSAICNAME pathG PATH T         ⍝      read it[105]  :elseif 0≠⎕NC 'F'                                  ⍝   otherwise, if we've got global mask,[106]     F2←F                                            ⍝      use it[107]  :else                                              ⍝   otherwise,[108]     F2←(⍴X)⍴1                                       ⍝      mask is all 1s[109]  :end[110]  →(^/,(F2∊0,MV)∨X=MV)/L1                            ⍝   Bail if base is all missing or masked[111]  Y←READ MOSAICNAME L[C[I;2];]                       ⍝   comparison landcover[112]  B←(X≠Y)^(X≠MV)^Y≠MV                                ⍝   cells with community change[113] [114]  Z←(⍴X)⍴0[115]  M←READ MOSAICNAME (pathE,'scaled\') PATH ⊃G[C[I;1]]⍝   read base IEI (need it for direct change and for impact)[116] [117]  :if (change≠1)^0∊B                                 ⍝   If any →→→→ indirect change ←←←← (community type stays the same), we want ∆metric[118]     J←0[119] L4: →((⍴R)<J←J+1)/L5                                ⍝      For each metric,[120]     BREAKCHECK[121]     DOT[122]     →(∨/0=⊃,/⍴¨H[C[I;1 2];J])/L4                    ⍝         Only do comparison if both scenarios use this metric[123]     →(~1∊F3←(J⊃R) MASKBITS F2)/L4                   ⍝         get mask for this metric, and skip if this tile is all masked[124] [125]     N←READ MOSAICNAME (path PATH source) PATH ⊃H[C[I;2];J]                ⍝         Read metric for comparison scenario[126]     :if (⊂TOUPPER STRIP ⊃H[C[I;1];J])∊FRDBL¨↓MATRIFY TOUPPER futuregrids  ⍝         If this is a futuregrid, [127]        P←(⍴N)⍴0                                                           ⍝            it gets 0 for baseline[128]     :else                                                                 ⍝         Else, [129]        P←READ MOSAICNAME (path PATH source) PATH ⊃H[C[I;1];J]             ⍝            Read metric for base scenario[130]     :end[131] [132]     O←(N=MV)∨P=MV[133]     S←-E[E[;1]⍳TOLOWER¨R[J];2]÷⍟¯1+2÷0.95+1         ⍝         rescale logistically such that 90th percentile of raw metric = 0.95[134] [135]     →('positive'≡GETDIRECTION J⊃R)/L12              ⍝         If stressor metric (negative direction),[136]     N←1-¯1+2×(0,S) LOGISTIC N                       ⍝            rescale[137]     P←1-¯1+2×(0,S) LOGISTIC P[138] [139] L12:Q←inflate×N-P                                   ⍝         change is inflate × ∆metric for each community from table[140]     Q←MVREP (MVREP Q O) B                           ⍝         any missing or direct loss → missing[141]     Q←MVREP Q (~F3)                                 ⍝         masked cells → MV[142] [143]     T←(T[;1]≤1↑⍴weights)⌿T←(weights[;1]⍳,X),[1.5],Q ⍝         community index, metric delta[144]     T←(T[;2]≠MV)⌿T[145]     T←T[⍋T[;1];][146]     K←T[;1]≠0,¯1↓T[;1][147]     W[I;K/T[;1];J+2]←K pSUM T[;2]                   ⍝         save sums for this metric[148] [149]     (5 ROUND Q) WRITE del PATH (FRDBL ⊃R[J]),(~plainname)/⍕I    ⍝         save metric delta[150]     Q←0 MVREP Q (B∨Q=MV)                                        ⍝         In cumulative delta, any direct loss → 0[151]     V←(weights⍪0)[weights[;1]⍳,X;1+postmetrics⍳TOUPPER¨R[J]]    ⍝         metric weights for base scenario[152]     Z←Z+Q×(⍴Q)⍴V                                                ⍝         weight metric by base community[153]     →L4[154]  :end[155] [156] L5:⍝      Now, →→→→ get IEI(alt) ←←←←[157]  dev←(0 'groups.par' LOOKUP 1 2⍴0,'developed')[;1],⊃,/LOOK¨FRDBL¨↓','MATRIFY exclude[158]  :if devonly                                        ⍝      If running development-only scenarios, alternate IEI is always zero[159]     N←(⍴M)⍴0[160]  :elseif 0∊⍴⊃scenarios[C[I;2];scenarios_ COL 'iei'] ⍝      Else, if no IEI(alt) supplied, we've been called from CAPS Scenario Builder,[161]     N←QUICKPOST Y ((Z>0.0001)∨B^Y≠MV) (H[C[I;2];])  ⍝         so generate our own IEI(alt) for impact (where ∆IEI >> 0) and for direct (when changing to natural)[162]     :if ∨/~((,B)/,Y)∊dev                            ⍝         If any change → natural,[163]        T←READ MOSAICNAME (⊃scenarios[I;scenarios_ COL 'results']),'mitigate'[164]        N←N×1 MVREP T                                ⍝            multiply by mitigation factor (1 - mitigation discount ÷ 100, done in CSE_MODIFY)[165]     :end[166]  :else                                              ⍝      else, called from LCAD or some other situation where we've already created IEI(alt)[167]     N←READ MOSAICNAME (pathE,'scaled\') PATH ⊃G[C[I;2]]        ⍝         read comparison IEI[168]  :end[169] [170]  Z←Z+inflate×B×(0 MVREP N)-0 MVREP M                ⍝      Direct change is inflate×∆IEI[171] [172]  :if (change≠1)^0∊B                                 ⍝      If →→→→ indirect change ←←←←, round 2, now that we have IEIalt[173]     ⎕←''[174]     (5 ROUND MVREP Z (M=MV)) WRITE del PATH 'delta',(~plainname)/⍕I               ⍝         save combined delta grid (preserve MVs in base IEI)[175]     :if devonly                                     ⍝      If running development-only scenarios,[176]        Q←M×Z                                        ⍝         impact is always based on base scenario's IEI[177]     :else                                           ⍝      Else, have IEI for alternate scenario, so[178]        Q←(M×Z≤0.0001)+N×Z>0.0001                    ⍝         use IEI when ∆IEI≤0, AND IEI(alt) when ∆IEI>0 (discounting rounding errors)[179]     :end[180]     (5 ROUND Q←MVREP Q (M=MV)) WRITE del PATH 'impact',(~plainname)/⍕I ⍝         save IEI×∆IEI ("impact") grid[181] [182]     T←(T[;1]≤1↑⍴weights)⌿T←(~,B)⌿(weights[;1]⍳,X),(,Z),[1.5],Q ⍝         community index, ∆IEI, impact for indirect change only[183]     T←((∨/T[;2 3]≠0)^^/T[;2 3]≠MV)⌿T[184]     T←T[⍋T[;1];][185]     K←T[;1]≠0,¯1↓T[;1][186]     W[I;K/T[;1];1 2]←W[I;K/T[;1];1 2]+K pSUM T[;2 3]⍝         save sums for this ∆IEI, impact[187] [188]     →(change=1)/L1                                  ⍝         If we did indirect change,[189]     Z←MVREP Z B[190]     (5 ROUND Z) WRITE del PATH 'indirect',(~plainname)/⍕I        ⍝            save indirect delta grid[191]  :end[192] [193] [194]  :if (change≠2)^1∊B                                 ⍝   If any →→→→ direct change ←←←← (=community type change), we want ∆IEI[195]     Z←inflate×B×(0 MVREP N)-0 MVREP M               ⍝      change is inflate×∆IEI[196]     Z←MVREP Z (F2∊0,MV)                             ⍝      masked cells → MV[197]     (5 ROUND MVREP Z (~B)) WRITE del PATH 'direct',(~plainname)/⍕I ⍝      Save direct delta grid[198] [199]     M←0 MVREP M ⋄ N←0 MVREP N                       ⍝      Make sure there are no missing values in the IEIs!!![200]     Q←,B×X∊landcover[;1]~dev                        ⍝      Natural changed to something (loss)[201]     T←(weights[;1]⍳Q/,X),-(Q/,M),[1.5](Q/,M)*2      ⍝      community index, ∆IEI, impact for loss[202]     Q←,B×Y∊landcover[;1]~dev                        ⍝      Something changed to natural (gain)[203]     T←T⍪(weights[;1]⍳Q/,Y),(Q/,N),[1.5](Q/,N)*2     ⍝      community index, ∆IEI, impact for gain[204]     T←((∨/T[;2 3]≠0)^^/T[;2 3]≠MV)⌿T[205]     T←T[⍋T[;1];][206]     K←T[;1]≠0,¯1↓T[;1][207]     W[I;K/T[;1];1 2]←W[I;K/T[;1];1 2]+inflate×K pSUM T[;2 3]   ⍝      save sums for direct ∆IEI and impact, inflated[208]  :end[209]  →L1[210] [211] [212] L9:W←W×1E¯4×cellsize*2                              ⍝Convert aspatial measures to IEI-hectares[213]  N←PATIENTTIE Q←pathI,'deltatables.sf'              ⍝Now save aspatial deltas[214]  →(0≠-/2↑⎕FSIZE N)/L8                               ⍝If result file is empty,[215]  T←U (weights[;1]) (('iei' 'impact'),R) (scenarios[;7]) (CELLSIZE) ⎕FAPPEND N  ⍝   write headers (comparisons × communities × metrics) to first record[216] L8:T←W ⎕FAPPEND N                                   ⍝Write aspatial stuff[217]  ⎕FUNTIE N[218]  RETURNLOCK Q[219]  →0[220] [221] [222] what:auxiliary[223] type:standard[224] info:('') ('') ('') (0)                             ⍝Source grid, settings table, result grid, and buffer size[225] init:MAKEDELTAFILE                                  ⍝Create temporary component file for accumulating deltas[226] check:CHECKVAR 'scenarios compare change'[227] check:CHECKVALUES 'compare base paired full'        ⍝Check for legal values of compare[228] check:CHECKVALUES 'change direct indirect both'     ⍝Check for legal values of change[229] check:CHECKBLOCK 0                                  ⍝Make sure metrics.par has no scenarios    ∇