    ∇ A MAKECORES_GOOD S;bandwidth;B;buffer;I;X;W;C;Q;V;R;K;F;G;T;Z;D;U;Y;KK8;head;L;systems;slice;expand;toosmall;multiplier;density;which;M;transparent;dot;barriers;culverts;E;wresistrange;H;O;fd;N;wetmultiplier;accumrange;P;wetexpand;R2;O2;S2;expandmult;J[1]   ⍝Build buffered reserve cores for LCD using resistant kernel[2]   ⍝Input grids:[3]   ⍝   value           value grid (IEI or selection index)[4]   ⍝   land            landcover grid[5]   ⍝   cores           result grid[6]   ⍝the following are only used if which = 'aquatic':[7]   ⍝   flow            flow grid[8]   ⍝   wresist         time of flow aquaitc resistance[9]   ⍝   fd8accum        flow accumulation[10]  ⍝Parameters:[11]  ⍝   which           type of cores: 'terrestrial' or 'aquatic'[12]  ⍝   systems         text file listing names of systems to include (usually terrestrial.txt or aquatic.txt)[13]  ⍝   slice           include values > slice in patches[14]  ⍝   expand          number of cells to expand to eliminate small gaps (usually 1)[15]  ⍝   toosmall        drop tiny patches with this many cells or fewer[16]  ⍝   multiplier      multiplier on value for costs[17]  ⍝   wetexpand       how far (m) to expand stream cores downstream at (min, max) watershed size?[18]  ⍝   expandmult      multiplier for resistant expansion (set to 0 to do non-resistant expansion)[19]  ⍝   wetmultiplier   multiplier for aquatic cores at (min, max) watershed size[20]  ⍝   bandwidth       default bandwidth (h, or s.d. of kernel), in meters[21]  ⍝   density         build kernels for every nth cell to speed things up[22]  ⍝   barriers        optional list of cover types to treat as absolute barriers, used to keep reserves from spanning highways[23]  ⍝   culverts        optional list of cover types representing culverts or dams, treated as barriers if adjacent to one of 'barriers'[24]  ⍝   wresistrange    range of wresist grid, used to scale resistance for aquatic cores[25]  ⍝   buffer          number of cells to buffer tiles - should be radius of largest core + bandwidth÷cellsize[26]  ⍝Results:[27]  ⍝   cores           reserve kernels[28]  ⍝   seeds           seed cores (aquatic only at the moment). 2 = core, 1 = expansion.[29]  ⍝B. Compton, 18-25 Jun 2014, from BUFFERCORES[30]  ⍝11 Jul 2014: expand stream cores downstream based on watershed area, and base multiplier on watershed area[31]  ⍝14 Jul 2014: don't expand into larger rivers; write seeds to help with evaluation[32]  ⍝22-23 Jul 2014: use resistance when expanding[33]  ⍝29 Jul 2014: don't expand aquatic cores downstream through dams[34]  [35]  [36]  [37]   READPARS ME[38]   X←READ 1⊃1⊃A                                   ⍝Read value grid[39]   W←READ 2⊃1⊃A                                   ⍝And landcover[40]   Q←W∊LOOKNAMES barriers                         ⍝Set highways to missing so they'll get super-high resistance[41]   X←MVREP X (Q∨(W∊LOOKNAMES culverts)^FOCALMAX Q)⍝Set culverts and dams to missing if adjacent to highways[42]   Q←0 ⎕TCHT MATIN pathI PATH systems,(~'.'∊systems)/'.txt'[43]   Y←X×W∊(LOOKUP 0,Q)[;1]                         ⍝Set everything outside of selected systems in landcover to 0[44]   Y←Y≥slice                                      ⍝Take values ≥ slice[45]   Y←((Y≠0)^W≠MV)×expand BUFFER Y                 ⍝Buffer to merge fragments, but not across value = 0 or landcover = missing[46]   Y←FINDPATCH Y                                  ⍝Build patches (8-neighbor)[47]  [48]   Q←(Q≠0)/Q←,Y[49]   Q←Q[⍋Q][50]   B←Q≠0,¯1↓Q[51]   Q←(B/Q),[1.5]B pSUM (⍴B)⍴1                     ⍝Patch #, number of cells[52]   Y←Y×Y∊U←(Q[;2]>toosmall)/Q[;1]                 ⍝Drop tiny patches[53]   Y←MVREP Y ((W=MV)∨X=MV)                        ⍝Carry over missing cells in landcover or value[54]  [55]   B←1+⌈bandwidth÷cellsize                        ⍝Buffer; take 1 extra cell to deal with rounding[56]   D←(⍳1+2×B)-B+1                                 ⍝Maximum radius possible to travel[57]   KK8←8 2⍴¯1 0 1 0 0 ¯1 0 1 ¯1 ¯1 1 1 ¯1 1 1 ¯1  ⍝8-neighbor rule for FOCALMIN[58]   Z←(⍴X)⍴0[59]  [60]   I←0[61]   :if which≡'terrestrial'                        ⍝If terrestrial cores,[62]   dot←⍴⍞←'Building kernels for ',(⍕⍴U),' cores' ⋄ FLUSH[63]   R←1+multiplier×1-X                             ⍝   Rescale IEI/selection index into resistance[64]   R←1E6 MVREP R (Y=MV)                           ⍝   missing cells get resistance of a million[65]  L1:→((⍴U)<I←I+1)/L5                             ⍝   For each core,[66]   BREAKCHECK[67]   DOT[68]   L M ← B CLIP Y=U[I]                            ⍝      Clip to this core plus buffer[69]   C←C×(C≠0)^0=FOCALMIN C←Y[L;M]                  ⍝      Edges of core[70]   V←(⍴C)⍴0[71]   S←20<+/,C=U[I]                                 ⍝      If core is small with few edge cells, don't skip any cells[72]  [73]   J←1[74]  L2:→(((1↑⍴C))<J←J+1)/L4                         ⍝      For each row,[75]   →(S^(J÷density)≠⌊J÷density)/L2                 ⍝         skip this row?[76]   K←1[77]  L3:→(((1↓⍴C))<K←K+1)/L2                         ⍝         For each column,[78]   →(S^(K÷density)≠⌊K÷density)/L3                 ⍝         skip this column?[79]   →((C[J;K]≠U[I]))/L3                            ⍝            If in edge of this core,[80]   F←((F>0)^F≤1↑⍴C)/F←J+D ⋄ G←((G>0)^G≤1↓⍴C)/G←K+D[81]   T←SPREAD B (F⍳J) (G⍳K) (R[L;M][F;G])           ⍝            Build kernel[82]   V[F;G]←V[F;G]⌈T÷B                              ⍝            Take max with core's result[83]   →L3[84]  [85]  L4:Z[L;M]←Z[L;M]⌈V                              ⍝      Take max of this core and running results[86]   →L1[87]  [88]   :else                                          ⍝Else, aquatic cores,[89]   E←READ 3⊃1⊃A                                   ⍝   Read flow grid[90]   R←READ 4⊃1⊃A                                   ⍝   and time of flow resistance[91]   H←READ 5⊃1⊃A                                   ⍝   and flow accumulation[92]   S2←(⍴X)⍴0                                      ⍝   for writing seeds[93]   fd←(2*¯1+⍳8),8 2⍴0 1 1 1 1 0 1 ¯1 0 ¯1 ¯1 ¯1 ¯1 0 ¯1 1[94]   N←FINDPATCH W=LOOK 'lentic'                    ⍝   Identify all lakes[95]   Y←FINDPATCH Y⌈N∊T←(T≠0)/T←,N×Y≥1               ⍝   Light up entire lakes that our cores fall into & rebuild cores[96]   U←((U⍳U)=⍳⍴U)/U←(,Y≠0)/,Y                      ⍝   rebuild unique core list[97]   ⍞←'Building kernels for ',(⍕⍴U),' cores' ⋄ FLUSH[98]  [99]  L6:→((⍴U)<I←I+1)/L5                             ⍝   For each core,[100]  BREAKCHECK[101]  L M ← B CLIP S←Y=U[I]                          ⍝      Select cells in core,[102]  O2←(INDICES O←O=⌈/,O←H[L;M]×S←S[L;M])[1;]      ⍝      Identify bottommost cell--we'll always keep this in; O2 is indices[103]  F←⍟H[L;M][O2[1];O2[2]]                         ⍝      ln(flow accumulation at botttommost cell of core before expansion)[104]  S2[L;M]←S2[L;M]⌈S×2                            ⍝      seed cells (2 for original seed)[105]  :if (W[L;M][O2[1];O2[2]])≠LOOK 'lentic'        ⍝      if bottommost cell is not lentic,[106]     P←⌈(÷cellsize)×wetexpand[1]+(-/wetexpand[2 1])×(F-accumrange[1])÷-/accumrange[2 1] ⍝      distance to expand core downstream is a function of watershed area[107]     T←Q←O2[108] L10:P←P-(1+expandmult≠0)⊃1 (1+expandmult×1-X[L;M][T[1];T[2]])    ⍝      Repeat: subtract 1 or resistance, depending on expandmult[109]     →(P<0)/L11                                  ⍝         If we haven't gone too far yet,[110]     T←,E[L;M] NEXTFLOW Q[111]     →(∨/T=0)/L11                                ⍝            bail out if we hit the edge[112]     →(W[L;M][T[1];T[2]]=LOOK 'lentic')/L11      ⍝            or if we hit a lake[113]     →(W[L;M][T[1];T[2]]=LOOK 'dam')/L11         ⍝            or a dam[114]     →((⍟H[L;M][T[1];T[2]])>1+⍟H[L;M][O2[1];O2[2]])/L11 ⍝            or if we hit a bigger river[115]     S[Q[1];(Q←T)[2]]←1                          ⍝            include this cell in core[116]     →L10[117] L11:O←(⍴O)⍴0[118]  O[O2[1];(O2←Q)[2]]←1                           ⍝         Re-find bottommost cell[119]  :end[120]  S2[L;M]←S2[L;M]⌈S                              ⍝      seed cells (2 = core, 1 = expansion)[121]  C←O∨S^0≠E[L;M] UPFLOW ~S                       ⍝      find "edges"--cells in core that stuff flows into from outside[122]  C←INDICES C                                    ⍝      make list of indices[123]  V←(⍴S)⍴0[124]  :if (W[L;M][O2[1];O2[2]])=LOOK 'lentic'        ⍝      if it's a lake,[125]     P←multiplier                                ⍝         use standard multiplier[126]  :else                                          ⍝      else, for rivers,[127]     P←wetmultiplier[1]+(-/wetmultiplier[2 1])×(F-accumrange[1])÷-/accumrange[2 1]    ⍝      multiplier is a function of watershed area[128]  :end[129]  R2←1+P×(R-wresistrange[1])÷wresistrange[2]     ⍝   rescale time of flow into resistance[130] [131]  J←0[132]  dot←⍴⍞←⎕TCNL,(⍕I),' of ',(⍕⍴U),' cores, ',(⍕1↑⍴C),' cells' ⋄ FLUSH[133] L7:→((1↑⍴C)<J←J+1)/L8                           ⍝      For each "edge" cell,[134]  DOT[135]  V←V⌈(÷B)×WETSPREAD B (C[J;1]) (C[J;2]) (R2[L;M]) (E[L;M])   ⍝         Build kernel[136]  →L7[137] [138] L8:Z[L;M]←Z[L;M]⌈S⌈E[L;M] CORE_WATERSHED V S    ⍝      mask kernel so we only build upstream of core[139]  →L6[140]  :end[141] [142] L5:transparent←3                                ⍝Use max transparency mode[143]  (MVREP Z ((X=MV)∨Z=0)) WRITE 1⊃3⊃A             ⍝Save transparently, with all 0's set to missing[144]  ⎕←''[145]  :if which≡'aquatic'                            ⍝If aquatic cores,[146]     (MVREP S2 (S2=0)) WRITEI 2⊃3⊃A              ⍝   Write seeds[147]  :end[148]  →0[149] [150] [151] [152] what:auxiliary[153] type:standard[154] info:('value' 'land' '*flow' ('*',pathS,'wresist') 'fd8accum') ('') ('cores' 'seeds') (buffer⌈⌈bandwidth÷cellsize)       ⍝Source grid, settings table, result grid, and buffer size[155] check:CHECKVAR 'which systems slice expand toosmall multiplier bandwidth density barriers culverts buffer wetmultiplier accumrange wetexpand expandmult'    ∇