    ∇ A FINDPATHS S;N;U;M;I;D;block;X;O;V;override_pars;cpars;buffer;bankcrossings;crossscores;Q;cross;G;linkages;Y;linkgrids;npaths;wanderlust;drawpaths;bandwidths;search;multiplier;resist;masktocore;L;P;kernelpoints;res;density;J;communities;fc;K;F;W;R;T;Z;C;B;fromto;t;head;H;points;nc;time;momentum;E;units;score;scores;ss;f;fi;conduct;bandwidth;scale;bc;H2;conductance;Hx;set;scalepaths;sp;T2;I2;T3;Gx;I0;Sx;bl;p;Px;Co;mult;pc;pcx;H3[1]   ⍝Prepare tables for CAPS Critical Linkages II analysis[2]   ⍝Parameters:[3]   ⍝   units           'passages' for wildlife passage structures, 'development', or 'none' to just get conductance and importance[4]   ⍝                   for development scenarios.[5]   ⍝   targets         Target nodes[6]   ⍝   communities     Focal communities to use[7]   ⍝   bandwidths      List of one or more bandwidths to use.  The largest of these is used as the kernel bandwidth.[8]   ⍝                   One version of conduct, the conductance grid, is written for each bandwidth if conduct = yes.[9]   ⍝   kernelpoints    Number of points to build kernels from[10]  ⍝   npaths          Number of random low-cost paths to find between each pair of nodes[11]  ⍝   wanderlust      A parameter that determines how far RLCPs deviate from the least-cost path[12]  ⍝   momentum        strength and persistence for momentum (use 0 to turn momentum off)[13]  ⍝   fromto          list of from-node numbers and of to-node numbers to restrict run to, for testing[14]  ⍝                   For normal runs, use fromto = 0.  NOTE: these are indices into node lists,[15]  ⍝                   not actual node numbers (for now).  Make sure these all fall within the same task[16]  ⍝                   --you may need to increase block in metrics.par.[17]  ⍝   drawpaths       If yes, create coverage of paths (beware of using this with lots of paths--it gets wicked slow!)[18]  ⍝   notables        If yes, suppress writing text tables used for node & link importance and Critical Linkages II[19]  ⍝[20]  ⍝   scores          file with score formulas for settings variables (used only when units = 'passages', otherwise ignored)[21]  ⍝   conduct	        If 1, write conductance and irreplacability grids, skip them if 0.[22]  ⍝   scalepaths      Maximum number of paths per pair of nodes (one direction) wanted in spaths for cookie connectors (0 to skip this)[23]  ⍝                   *Note: don't run multiple bandwidths with scalepaths, or you'll get unexpected results![24]  ⍝Parameters from [connect]:[25]  ⍝   multiplier      multiplier on ecological distance for costs[26]  ⍝   search          search distance, in s.d.[27]  ⍝[28]  ⍝Inputs:[29]  ⍝    nodes          Integer grid with node # for each reserve polygon.  Converted from a shapefile with makenodes.aml.[30]  ⍝    nodes.txt      More information about reserve nodes.   Node #, centroid-x, centroid-y, reserve name, priority,[31]  ⍝                   include, and community (index into communities; used for Connectivity).[32]  ⍝    nodevalues.txt Values for nodes, with IEI-weighted size: mask, x, y, nodes, iei.[33]  ⍝    units          Integer grid with unit # for each contingent unit.   Converted from a polygon shapefile with[34]  ⍝                   makeunits.aml, or created by ROADBLOBS and makeroadunits.aml.[35]  ⍝    units.txt      More information about contingent units.  Unit #, centroid-x, centroid-y, unit name/id, maybe other stuff.[36]  ⍝    noderep.txt    Table with rows for nodes and columns for communities, giving proportional representation for each[37]  ⍝                   community.  Rows sum to 1.  Created by NODEREP.[38]  ⍝[39]  ⍝Results:[40]  ⍝    conduct<n>     Grid(s) with conductance, one for each of bandwidths[41]  ⍝ NOT USED   maxpaths<n>    Grid(s) with maxpaths (like conductance, but sums instead of max, for MAKECOOKIES), one for each bandwidth[42]  ⍝    spaths<n>      Grid(s) with scaled paths for cookie connectors (formerly maxpaths)[43]  ⍝    irreplace      Grid with irreplacability; ignores bandwidths[44]  ⍝    internode.txt  List of each node1 node2 for which edges exist.  Provides an index into edges files.[45]  ⍝    n1-n2edges.txt A separate table for each pair of nodes with an edge, corresponding to rows of internode.txt.  Filename[46]  ⍝                   is <node1>-<node2>edges.txt. These tables have the following items, tab-delimited:[47]  ⍝       edgeno      Edge index within this internode pair, from 1 to npaths[48]  ⍝       unit        contingent unit traversed by path (0 if no units in path)[49]  ⍝       distance    Distance (m) between pair of nodes[50]  ⍝       cost        cost for this contingent unit (if units = 'passages').  This is total cost for all cells in this unit[51]  ⍝                   traversed by the path.[52]  ⍝    <drawpaths>.txt, <drawpaths>f.txt, <drawpaths>t.txt[53]  ⍝                   Text files for drawpaths, if selected.  Use drawpaths.aml to create a vector coverage from these:[54]  ⍝                   &r drawpaths <drawpaths>.  Result will be shapefiles of from-points, to-points, and paths.  Ids for[55]  ⍝                   points and paths are ffftttppp, where f = from-node, t = to-node, and p = path.  Note that you'll get[56]  ⍝                   a mess if there are more than 999 nodes or paths.  There's a column for community too.[57]  ⍝B. Compton, 18 Oct 2012-14 Mar 2013[58]  ⍝14 Mar 2013: drop checks for connectivity--we're doing it a different way[59]  ⍝31 Oct 2013: bug--when only 1 bandwidth, didn't write conductance[60]  ⍝22 Nov 2013: don't use LOAD[61]  ⍝4 Dec 2013: pass header of crossings table and score column to SETTINGS[62]  ⍝11 Jul 2014: add units='none' and read bankcrossings as a vector mosaic[63]  ⍝22 Jul 2014: add irreplacability metric; 23 Jul: take max, not sum among internodes[64]  ⍝24 Jul 2014: round conductance a bit[65]  ⍝7 Nov 2014: write maxpaths for MAKECOOKIES[66]  ⍝20 Nov 2014: read large enough blocks around nodes to actually work properly (was reading buffered centroid, now reading buffered MER)[67]  ⍝7 Jan 2015: move reading ecological settings grids out of the community loop![68]  ⍝13-14 Jan 2015: add scalepaths to produce spaths for cookie connector, scaled so we always get something but not too much[69]  ⍝15 Jan 2015: use node value as well as path probability for scalepaths[70]  ⍝16 Jan 2015: Aargh! Needed to scale up Px to account for node values.  Use mult.[71]  ⍝⍝⍝*** 28 Jul 2015: TEMPORARY CHANGES FOR W2W CONDUCTANCE TEST ***⍝⍝⍝[72]  ⍝17 Jun 2016: add notables option[73]  [74]  [75]  [76]   time←2⍴⎕AI[2][77]   cpars←GETINFO 'connect'                        ⍝Construct call to CONNECT & read CONNECT's parameters[78]   READPARS 'connect'[79]   READPARS ME                                    ⍝Uses connectedness parameters by default, but can override them in [linkages][80]   :if 1≡≡3⊃A                                     ⍝If only one bandwidth, deal with nesting depth[81]      A[3]←⊂,A[3][82]   :end[83]   override_pars←'[connect]',⎕TCNL,(T⍳⎕TCNL)↓T←1↓EXTRACTPARS ME     ⍝Override CONNECT parameters with those set for FINDPATHS[84]   cpars[1]←⊂GRIDNAME 1⊃cpars[85]   cpars[4]←⌈(bandwidth←⌈/bandwidths←,bandwidths)×search÷cellsize   ⍝Bandwidth is max of supplied bandwidths[86]   buffer←0[87]  [88]   N←0 1 TABLE pathQ,'tables\nodes.txt'           ⍝List of all nodes[89]   T←0 1 TABLE pathQ,'tables\nodevalues.txt'      ⍝and get IEI-weighted size of each node[90]   nc←⌊.5+npaths×TABLE pathQ,'tables\noderep.txt' ⍝Read node community representation table and scale by npaths[91]   N[;5]←T[T[;4]⍳N[;1];5]                         ⍝which we'll use for node importance[92]   scale←npaths×MEAN 2↑N[⍒N[;5];5]                ⍝Scaling for conductance - all paths making full connection between two biggest nodes is 1.0[93]   mult←÷MEAN N[;5]÷scale                         ⍝Multiplier for spaths, to put them in same scale as P(connect)[94]   M←((⍳1↑⍴N)∊(⊃⊃S)+¯1+⍳2⊃⊃S)⌿N                   ⍝Nodes that we're doing in this thread[95]   M[;4]←(M[;4]≠¨'''') SLASHEACH M[;4]            ⍝Drop quotes from Arc[96]   fc←(LOOK¨fc),fc←1 0 TABLE pathI,communities    ⍝Read focal community table[97]   fc←((⊂'')⍴¨fc[;1]),fc                          ⍝Add 1st column with single class for community group[98]   fi←MV⍪((⊃,/⍴¨fc[;2])/fc[;1]),[1.5]⊃,/fc[;2]    ⍝Community remap index[99]  [100]  cross←TABLE pathM PATH crossscores             ⍝Get formula for crossing scores[101]  linkages←2                                     ⍝Call CONNECT as linkages subroutine, but don't use square kernels[102] [103]  :if units≡'passages'                           ⍝If doing passages,[104]     score←TABLE pathM PATH scores               ⍝   Get linkage scores[105]     ss←MATIN pathT PATH scales                  ⍝   Get original settings variable scales[106]  :end[107] [108]  N[T;4]←⍕¨N[T←(N[;4]≡¨⊂'')/⍳1↑⍴N;1]             ⍝Replace empty names[109]  M[T;4]←⍕¨M[T←(M[;4]≡¨⊂'')/⍳1↑⍴M;1][110]  fromto←(1+fromto≡0) ⊃ fromto ((⍳1↑⍴N) (⍳1↑⍴M))[111] ⍝ ⎕←'From-nodes:'[112] ⍝ ⎕←' ',' ',' ',(⎕PW-3) TELPRINT VTOM '.''.' TEXTREPL MTOV MIX N[1⊃fromto;4][113]  ⎕←'To-nodes:'[114]  ⎕←' ',' ',' ',(⎕PW-3) TELPRINT VTOM '.''.' TEXTREPL MTOV MIX M[2⊃fromto;4][115] [116] [117] ⍝pc←MATIN pathQ,'results\pathcount.txt'  ⍝⍝⍝*** TEST CODE FOR W2W CONDUCTANCE[118] [119]  points←0 8⍴0[120]  E←0 2⍴0[121]  I←0[122] L3:→((1↑⍴M)<I←I+1)/L13                          ⍝For each to-node I-----[123]  BREAKCHECK[124]  →(~I∊2⊃fromto)/L3[125]  LOG 'Processing to-node #',(⍕M[I;1]),', ',⊃M[I;4] ⋄ FLUSH[126] [127]  T←(FINDCELL M[I;7 10]),(⌽⌈(M[I;9 10]-M[I;7 8])÷cellsize),⌈(bandwidth×search)÷cellsize   ⍝   window in terms of cells: MER + buffer[128]  bc←((4⍴M[I;2 3])+¯1 ¯1 1 1×1+cellsize+⌈bandwidth×search) READVEC bankcrossings      ⍝   Read bank crossings table[129]  bc[1]←⊂(⊃bc)[;(⍳1↓⍴⊃bc)~((2⊃bc) COL 'terrestrial')][130] [131]  block←¯1,T[132]  X←READ 3⊃1⊃A                                   ⍝   Read land,[133]  O←ROUND 0 MVREP READ 1⊃1⊃A                     ⍝   read nodes grid[134]  :if units≡'none'[135]     V←(⍴O)⍴0[136]  :else[137]     V←0 MVREP READ 2⊃1⊃A                        ⍝   and units (unless units = 'none')[138]  :end[139]  →(0∊⍴Y←S '' INCLUDE (⍴X)⍴1)/L3                 ⍝   If all masked out, on to next node[140]  X←(fi[;1],0)[fi[;2]⍳X]                         ⍝   remap landcover to focal community groups[141]  Y←Y×O=M[I;1]                                   ⍝   Cells in this node[142]  :if conduct                                    ⍝   If writing conductivity and irreplacability grids,[143]     H2←(Hx←H←((⍴bandwidths),⍴X)⍴0)[1;;]         ⍝      create templates[144]  :end[145]  ⎕←'   (reading settings)' ⋄ FLUSH[146]  set←(cross (bc,⊂'terrestrial')) SETTINGS (2⊃A) 'anthro1' 'resist dist'  ⍝   Read ecological settings grids for natural and anthro groups[147]  Px←sp←((1↑⍴N),2)⍴0                             ⍝Lists of best paths for each from-node for scaling connectors and sum/count of path probabilities for each from-node[148]  [149] [150]  J←0[151] L4:→((1↑⍴fc)<J←J+1)/L12                         ⍝---For each focal community J-----[152]  BREAKCHECK[153]  T←(+/,Q←Y×X∊⊃fc[J;1])⍴0                        ⍝      Select random cells in focal community in this node to build kernels for and set mask[154]  →(0∊⍴T)/L4                                     ⍝      Skip this community if it doesn't exist in this node[155]  ⎕←⎕TCNL,'   Community: ',⊃fc[J;3] ⋄ FLUSH[156]  T[(kernelpoints⌊⍴T)?⍴T]←1[157]  Q←(⍴Q)⍴(,Q)\T[158]  linkgrids ← (X Q) set[159]  ⎕←'      (connect)' ⋄ FLUSH[160]  conductance←0[161]  cpars CONNECT S[162]  res←res÷⌈/,res[163]  res←100 2 LITTLEBUMPS res cpars bandwidth S    ⍝      add little kernel bumps so we don't wander in the end[164]  res←res÷⌈/,res                                 ⍝      scale kernel so maximum cell is 1.0[165]  res←MVREP res (X=MV)[166]  Q←0⍪(0,res,0)⍪0                                ⍝      and pad it[167] [168] [169] ⍝Convert kernel to n×8 matrix of relative probabilities[170]  P←(8,⍴Q)⍴0[171]  D←8 2⍴¯1 ¯1 ¯1 0 ¯1 1 0 ¯1 0 1 1 ¯1 1 0 1 1    ⍝      8 neighbors, in row-major order[172]  L←0[173] L5:→(8<L←L+1)/L6                                ⍝      For each neighbor,[174]  P[L;;]←D[L;1]⊖D[L;2]⌽Q                         ⍝         get value of each neighbor (1 = up to the left, 2 = up, and so on)[175]  →L5[176] L6:P←0 1 1↓0 ¯1 ¯1↓P                            ⍝      drop padding[177]  P←(~P∊0,MV)×T÷(⍴P)⍴+⌿T←wanderlust+(1-wanderlust)×(P-(⍴P)⍴⌊⌿P)÷(⍴P)⍴(⌈⌿P)-⌊⌿P       ⍝      range rescale probabilities[178]  :if wanderlust=0                               ⍝      If wanderlust is set to 0,[179]     P←P÷(⍴P)⍴+⌿P←P=(⍴P)⍴⌈⌿P                     ⍝         use least-cost path (ties will be resolved randomly)[180]  :end[181]  :if momentum≡0                                 ⍝      If we're not using momentum,[182]     P←+⍀¯1 0 0↓P                                ⍝         Only need 7 cutpoints; take cumulative sum so we can use 1++/?≥P[183]  :end[184]  W←(X×Y)=fc[J;1]                                ⍝      to-cells[185] [186]  ⎕←'Time: ',⍕⎕AI[2]-time[2] ⋄ time[2]←⎕AI[2][187]  ⎕←'      (nodes)' ⋄ FLUSH[188]   ⍝(MVREP res (X=MV)) WRITEBLOCK  (⊂pathQ,'working\res'),(block[2 3]-block[6]),(1+2⍴2×block[6]),0,2,1     ⍝For debugging......[189] [190]  K←0[191] L7:→((1↑⍴N)<K←K+1)/L4                           ⍝------For each from-node K-----[192]  BREAKCHECK[193]  →(~K∊1⊃fromto)/L7[194]  →((nc[K;J]=0)∨N[K;1]=M[I;1])/L7                ⍝         but not to-node, and not if this community isn't in from-node[195]  →(0=+/,res×O=N[K;1])/L7                        ⍝         and only if the kernel actually reaches the node[196]  →(0=+/,(O=N[K;1])^X∊fc[J;1])/L7                ⍝         and only if this community isn't cutoff in this node[197]  ⍝Z←(0,3+units≡'passages')⍴0[198]  ⎕←⎕TCNL,'      From-node #',(⍕N[K;1]),', ',(⊃N[K;4]),' (',(⍕K),' of ',(⍕1↑⍴N),')' ⋄ FLUSH[199]  H3←(⍴H2)⍴0[200]  Z←0 4⍴0[201] [202]  L←0[203] L8:→(nc[K;J]<L←L+1)/L11                         ⍝---------For each path L-----[204]  BREAKCHECK[205]  T←(+/B←,(O=N[K;1])^X∊fc[J;1])⍴0                ⍝            pick random start cell in focal community in from-node[206]  T[?⍴T]←1[207]  F←,INDICES (⍴O)⍴B\T[208]  →(0=res[F[1];F[2]])/L8                         ⍝            if starting point has no kernel value, skip it--we'll adjust when calculating P(c)[209]  DOT[210]  ⍝ TEST .5 .6 .75[211]  Q R ← P RPATH F W                              ⍝            build random low-cost path, returning grid and coordinate representations[212]  U←(1⌈⍴U)↑U←UNIQUENZ ,V×Q≠0                     ⍝            units traversed by path (or 0 if no units)[213]  (N[K;1]) (M[I;1]) ((N[K;1]×1E6)+(M[I;1]×1E3)+L++/nc[K;⍳J-1]) drawpaths F (R[''⍴1↑⍴R;]) (fc[J;1]) DRAWPATH R   ⍝            draw paths if appropriate (id is ffftttppp)[214] [215]  G←1⊃2⊃linkgrids[216]  :if units≡'passages'                           ⍝            If passage units,[217]     Q←(Q⌊1+(⌈/,Q)×V=0)×(⍴Q)⍴~B\~(T⍳T)=⍳⍴T←(B←,(Q≠0)^V≠0)/,V     ⍝            only allow 1 cell per road unit ###[218]  :end[219]  C←cellsize×+/,1+multiplier×(f←(2⊃2⊃linkgrids)[;2]×G[;F[1];F[2]]) EUDIST ((⍴t),1)⍴t←(,Q)/((1↑⍴G),×/1↓⍴G)⍴G    ⍝            Resistance values for focal cell I,J.  Focal cell is always 0 for anthro settings.[220]  :if U≡,0                                       ⍝               If no units in path,[221]     C←1 2⍴C,0                                   ⍝                  just return ∆cost = 0[222]  :else                                          ⍝               else,[223]     G←((⍴t),1)⍴t←(((1↑⍴G),×/1↓⍴G)⍴G)[;(,V)⍳U]   ⍝                  only care about costs of involved units (only want 1 cell per unit),[224]     D←1+multiplier×f EUDIST G                   ⍝                  original costs for units[225]     G←score ((⍳⍴U),[1.5]1) ((2⊃2⊃linkgrids)[;1]) ss ((2⊃2⊃linkgrids)[;3]) LINKAGEMOD G[226]     D←,D-1+multiplier×f EUDIST G                ⍝                  difference with modified cost[227]     C←C,[1.5]cellsize×D×+/U∘.=(t≠0)/t←,V×Q≠0    ⍝ **** IS THIS STILL RIGHT? (3/5/13) *****       distance, cost for each unit, in Rm (taking into account multiple cells traversed in unit *but must remove ### above)[228]  :end[229]  Z←Z⍪(L++/nc[K;⍳J-1]),(((⍴U),1)⍴U),C            ⍝            edge no, units traversed by path, prob (if development) or (distance,∆cost) (if passages)[230] [231]  :if conduct                                    ⍝            If writing conductance and irreplacability grids,[232]     ⍝pcx←1↑(pc[;2 3]^.= M[I;1],N[K;1])⌿pc[;4]    ⍝⍝⍝*** CONDUCTANCE MULTIPLIER FOR W2W CONDUCTANCE[233] [234]     T←(Q≠0)×~O∊M[I;1],N[K;1]                    ⍝            path presence, but mask from- and to-nodes from conductance[235]     H3←H3+(T÷npaths×2)⍝⍝⍝⍝⍝ ×pcx  ⍝⍝⍝***                            ⍝            irreplacability - number of paths, scaled by npaths×2, so a cell used by every path between pair of nodes = 1.0, summed within internode[236]     p←bandwidths GAUSS¨''⍴C                     ⍝            P(connect) for this path for each bandwidth[237]     ⍝⍝p←p×pcx   ⍝⍝⍝***[238]     D←(MEAN N[K,N[;1]⍳M[I;1];5])÷scale          ⍝            scaling for this path, proportional to mean node size[239]     H←H+↑(⊂T)×¨Co←p×D                           ⍝            conductance (linkage index), scaled by P(connect) and node sizes, such that maximum possible = 1[240]     Hx←Hx⌈↑(⊂T)×¨p×D×npaths                     ⍝            maxpaths is like conductance, but use max, not sum[241]     :if scalepaths≠0                            ⍝            if we're saving scaled paths,[242]       Px[K;]←Px[K;]+(Co←''⍴Co×mult),1           ⍝               Save sum and count of path probabilities including node values[243]       :if scalepaths>⍴T2←,⊃sp[K;1]              ⍝               and we don't yet have our quota for this from-node,[244]        :orif Co>⌊/T2                            ⍝               or this one is better than the worst one we have,[245]           I2←T2⍳⌊/scalepaths↑T2                 ⍝               the element we're replacing[246]           T2←(I2⌈⍴T2)↑T2[247]           T2[I2]←Co                             ⍝               save the probability (conductance; includes node values)[248]           sp[K;1]←⊂T2[249]           T3←(I2⌈⍴T2)↑⊃sp[K;2][250]           T3[I2]←⊂T                             [251]           sp[K;2]←⊂T3                           ⍝               and save the path[252]        :end[253]     :end[254]  :end[255]  →L8                                            ⍝            Next path L[256] [257] [258] L11:H2←H2⌈H3                                    ⍝      Take max (not sum) of irreplaceability among internodes[259]  →(notables∨0∊⍴Z)/L7                            ⍝      If we've built any paths between these nodes,[260]  head←''[261]  Z TMATAPPEND pathQ PATH 'tables\',(⍕N[K;1]),'-',(⍕M[I;1]),'edges.txt'    ⍝            Write edges file (no need to lock)[262]  E←E⍪N[K;1],M[I;1][263]  ⎕←'Time: ',⍕⎕AI[2]-time[2] ⋄ time[2]←⎕AI[2][264]  →L7                                            ⍝      Next from-node K[265]                                                 ⍝   Next community J[266] [267] L12:[268]  :if conduct                                    ⍝   If writing conductance grids,   ⊢[269]     bl←1↓block+0,¯1 ¯1 2 2 ¯1×block[6][270]     (MVREP H2 (X=MV)) WRITEBLOCK (⊂1⊃3⊃A),bl,3,1⍝      write irreplacability (transparently using max)[271] [272]     :if scalepaths≠0                            ⍝         if we're saving scaled paths,[273]        Gx←⌈scalepaths×((Px[;2]≠0)×÷/Px)*0.5     ⍝         goal for each from-node: scalepaths × square root of mean P(connect)[274]        Sx←(⍴X)⍴0                                ⍝         Scaled paths[275]        :for I0 :in ⍳1↑⍴Px                       ⍝         For each from-node,[276]           :if Gx[I0]=0[277]              :continue[278]           :end[279]           T←⍋⊃sp[I0;1]                          ⍝            Indices into best paths for this from-node,[280]           G←⊃⌈/(⍳⍴T)×(⊃sp[I0;2])[T]             ⍝            Best n paths, numbered 1...n[281]           Sx←Sx⌈(G≠0)×G+Gx[I0]-1                ⍝            Add # of paths we want, so Sx≥scalepaths gives us our goal, but we have other options[282]        :end         [283]        (MVREP Sx (X=MV)) WRITEBLOCK (⊂2⊃3⊃A),bl,3,0   ⍝         spaths writes transparently using max[284]     :end[285] [286]     :for Q :in ⍳⍴bandwidths                     ⍝      For each bandwidth, write conductance (transparently using sum)[287]        (MVREP (5 ROUND H[Q;;]) (X=MV)) WRITEBLOCK (⊂(Q+2)⊃3⊃A),bl,2,1                ⍝      conductance is additive[288]        (MVREP (5 ROUND Hx[Q;;]) (X=MV)) WRITEBLOCK (⊂(Q+2+⍴bandwidths)⊃3⊃A),bl,3,1   ⍝      maxpaths uses max[289]     :end[290]  :end[291]  →L3                                            ⍝Next to-node I[292] [293] L13:→(notables∨0∊⍴E)/L14[294]  E←E[⍋E;][295]  E←(∨/E≠0⍪¯1 0↓E)⌿E                             ⍝Remove duplicates from internodes (they're from multiple communities)[296]  E LOCKWRITE pathQ,'tables\internode',('_' NAME 'repname'),'.txt'       ⍝Write to internodes file[297] [298]  →(0≡drawpaths)/L14[299]  head←''[300]  points[;1 4 5] LOCKWRITE (pathQ,'results\pathsf.txt') ','[301]  points[;1 6 7] LOCKWRITE (pathQ,'results\pathst.txt') ','[302]  ⎕←⎕TCNL,'In Arc, &r drawpaths ',pathQ,'results\'[303] [304] L14:⎕←'Total time: ',⍕⎕AI[2]-time[1][305]  →0[306] [307] [308] [309] what:auxiliary[310] type:table[311] init:SINK 3 ⎕CMD 'del ',pathQ,'tables\*edges.txt'    ⍝Erase *edges.txt so we can safely append[312] init:head←'' ⋄ (0 0⍴'') TMATOUT (drawpaths≠0)/pathQ,'results\pathsf.txt'    ⍝(Re)create path files on start[313] init:head←'' ⋄ (0 0⍴'') TMATOUT (drawpaths≠0)/pathQ,'results\pathst.txt'[314] init:head←'' ⋄ (0 0⍴'') TMATOUT (drawpaths≠0)/pathQ,'results\paths.txt'[315] init:head←1↓⎕TCHT MTOV MATRIFY 'from to' ⋄ (⊂0 0⍴'') TMATOUT¨(⊂pathQ,'tables\internode'),¨('_' ALLNAMES 'FINDPATHS'),¨⊂'.txt'[316] info:(('*',pathQ,'source\nodes') ('*',pathQ,'source\units') 'land') ('settings') ((⊂pathQ,'results\irreplace'),(⊂pathQ,'results\spaths'),((⊂pathQ,'results\'),¨(⊂'conduct'),¨KNAMES bandwidths),((⊂pathQ,'results\'),¨(⊂'maxpaths'),¨KNAMES bandwidths)) 0 'include'      ⍝Source grid, settings table, result grid, buffer size, and include grid[317] [318] check:CHECKVAR 'units npaths wanderlust drawpaths kernelpoints communities fromto momentum scores bandwidths conduct scalepaths notables'    ∇