    ∇ A SAMPLEGROUPS S;loop;test;noread;grids;ffile;tilesize;L;X;grid;T;U;C;J;block;samples;Q;M;V;I;IJ;head;result;buffer;tilemapinclude;skiptilemap;E;N;dot[1]   ⍝Find sample points by class in target grid[2]   ⍝Parameters:[3]   ⍝   grid            name of source grid[4]   ⍝   result          name of result text file (results are class, x, y for each sample)[5]   ⍝   samples         number of samples per class[6]   ⍝   tilesize        size of tiles (in cells)[7]   ⍝   targets = '1:1' needs to be in parameters.par to run a single thread[8]   ⍝Source:[9]   ⍝   grid            class grid (e.g., landcover)[10]  ⍝Result:[11]  ⍝   result.txt      Text file of sample points with columns: class, x, y[12]  ⍝[13]  ⍝B. Compton, 18-19 Dec 2014 (from BENCH)[14]  [15]  [16]  [17]   READPARS ME[18]   buffer←0[19]  [20]  ⍝-----Pass 1: Count cells in each class by tile[21]   loop←test←noread←0 ⋄ grids←0 0⍴''              ⍝Silly junk for BLOCK, etc.[22]   ffile←'SAMPLEGROUPS (pass 1) ',⍕S[23]   BLOCK 2⍴tilesize[24]   SETTILE[25]  [26]   tilemapinclude←0[27]   skiptilemap←0                                  ⍝Don't let DEBUG sabotage this[28]   E←TILEMAP '' tilesize 0 0                      ⍝Get tilemap, building it if necessary.[29]   ⎕←'Running for ',(⍕+/E),' tiles' ⋄ FLUSH[30]  [31]  [32]   C←⍳0                                           ⍝Class list[33]   L←(0,+/E)⍴0                                    ⍝# of cells in each class [class × tile] ... don't know what classes exist yet[34]  [35]   LOG 'SAMPLEGROUPS, Pass 1: Counting cells in each class by tile...' ⋄ FLUSH[36]   N←0[37]  L1:→(~E[N←N+1])/L3                              ⍝Repeat: read blocks where there's data (1st time through tiles),[38]   BREAKCHECK ⋄ DOT[39]   X←READ GRIDNAME grid[40]   :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[41]      X←MVREP X ((READ mask)∊0,MV)                ⍝      read mask & set masked out cells to missing[42]   :end[43]   X←(,X≠MV)/,X                                   ⍝   remove missing values[44]   →(0∊⍴X)/L3                                     ⍝      If anything non-missing,[45]   U←UNIQUE X                                     ⍝   Unique classes in tile[46]   C←C,U~C                                        ⍝   add new classes[47]   L←((⍴C),1↓⍴L)↑L[48]  [49]   J←0[50]  L2:→((1↑⍴L)<J←J+1)/L3                           ⍝         Number of cells per community (vastly faster than ∘.=)[51]   L[J;+/N↑E]←+/X=C[J][52]   →L2[53]  L3:→(0≠NEXTBLOCK)/L1                            ⍝Until no more blocks[54]   ⎕←''[55]  [56]   L←⌊.5+L×⍉(⌽⍴L)⍴1⌊samples÷+/Q←L                 ⍝Number of points to sample per tile & class (proportional to availability)[57]  L4:→(^/0=T←1⌊¯1⌈(samples<+/Q)×samples-+/L)/L5   ⍝Repeat: correction factor - some are high or low due to rounding proportions[58]   L←0⌈L+(Q>L)⌊(?(⍴T)⍴1↓⍴Q)⌽T,((⍴T),¯1+1↓⍴Q)⍴0    ⍝   Correct where there are points available[59]   →L4                                            ⍝Until we've got what we want (as available)[60]  [61]  [62]  [63]  ⍝-----Pass 2: Pick x,ys for each tile[64]  L5:LOG 'SAMPLEGROUPS, Pass 2: Picking sample points...' ⋄ FLUSH[65]   M←((1↑⍴L),3,samples)⍴0                         ⍝Sampling points [classes × 3 (tile, x, y) × points per community][66]   V←+\0,0 ¯1↓L                                   ⍝Starting point (-1) for each community × tile[67]  [68]   ffile←'SAMPLEGROUPS (pass 2) ',⍕S              ⍝Reset block[69]   BLOCK 2⍴tilesize[70]  [71]   dot←N←0[72]  L6:→(~E[N←N+1])/L8                              ⍝For each tile (2nd time),[73]   I←+/N↑E[74]   BREAKCHECK ⋄ DOT[75]   →(^/0=L[;I])/L8                                ⍝   If any cells in tile,[76]   X←READ GRIDNAME grid                           ⍝         Read tile[77]   :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[78]      X←MVREP X ((READ mask)∊0,MV)                ⍝      read mask & set masked out cells to missing[79]   :end[80]  [81]   IJ←↓[1](⍉(⌽⍴X)⍴⍳1↑⍴X),[.5](⍴X)⍴⍳1↓⍴X           ⍝         Index matrix[82]   J←0[83]  L7:→((1↑⍴L)<J←J+1)/L8                           ⍝         For each class,[84]   →(L[J;I]=0)/L7                                 ⍝            If in tile,[85]   Q←(,X=C[J])/,IJ                                ⍝               indices for this class[86]   M[J;;V[J;I]+⍳L[J;I]]←⍉C[J],↑1 FINDPOINT¨Q[L[J;I]?⍴Q]    ⍝               sample points[87]   →L7[88]  L8:→(0≠NEXTBLOCK)/L6                            ⍝Next tile[89]  [90]  L9:head←1↓⎕TCHT MTOV MATRIFY 'class x y'[91]   M←((×/(⍴M)[1 3]),(⍴M)[2])⍴1 3 2⍉M[92]   M←(M[;1]≠0)⌿M[93]   M←M[⍋M;][94]   M TMATOUT pathR PATH result,(~'.'∊result)/'.txt'[95]  [96]   LOG 'SAMPLEGROUPS is done.'[97]   →0[98]  [99]  [100] [101] what:auxiliary[102] type:table[103] info:(grid) ('') ('') 0 ''                      ⍝Source grid, settings table, result grid, buffer size, and include grid[104] check:CHECKVAR 'grid result samples tilesize targets'    ∇