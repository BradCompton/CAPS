    ∇ A LAST_GOOD_MAKECORES S;bandwidth;B;buffer;I;X;W;C;Q;V;R;K;F;G;T;Z;D;U;Y;KK8;head;L;systems;slice;expand;toosmall;multiplier;density;which;M;transparent;dot;barriers;culverts;E;wresistrange;H;O;fd;N;wetmultiplier;accumrange;P;wetexpand;R2;O2;S2;expandmult;J;P2;sg[1]   ⍝Build buffered reserve cores for LCD using resistant kernel[2]   ⍝Input grids:[3]   ⍝   value           value grid (IEI or selection index)[4]   ⍝   land            landcover grid[5]   ⍝   cores           result grid[6]   ⍝the following are only used if which = 'aquatic':[7]   ⍝   flow            flow grid[8]   ⍝   wresist         time of flow aquaitc resistance[9]   ⍝   fd8accum        flow accumulation[10]  ⍝Parameters:[11]  ⍝   which           type of cores: 'terrestrial' or 'aquatic'[12]  ⍝   systems         text file listing names of systems to include (usually terrestrial.txt or aquatic.txt)[13]  ⍝   slice           include values > slice in patches[14]  ⍝   expand          number of cells to expand to eliminate small gaps (usually 1)[15]  ⍝   toosmall        drop tiny patches with this many cells or fewer[16]  ⍝   multiplier      multiplier on value for costs[17]  ⍝   wetexpand       how far (m) to expand stream cores downstream at (min, max) watershed size?[18]  ⍝   expandmult      multiplier for resistant expansion (set to 0 to do non-resistant expansion)[19]  ⍝   expandup        if true, expand upstream as well as down[20]  ⍝   wetmultiplier   multiplier for aquatic cores at (min, max) watershed size[21]  ⍝   bandwidth       default bandwidth (h, or s.d. of kernel), in meters[22]  ⍝   density         build kernels for every nth cell to speed things up[23]  ⍝   barriers        optional list of cover types to treat as absolute barriers, used to keep reserves from spanning highways[24]  ⍝   culverts        optional list of cover types representing culverts or dams, treated as barriers if adjacent to one of 'barriers'[25]  ⍝   wresistrange    range of wresist grid, used to scale resistance for aquatic cores[26]  ⍝   buffer          number of cells to buffer tiles - should be radius of largest core + bandwidth÷cellsize[27]  ⍝Results:[28]  ⍝   cores           reserve kernels[29]  ⍝   seeds           seed cores (aquatic only at the moment). 2 = core, 1 = expansion.[30]  ⍝B. Compton, 18-25 Jun 2014, from BUFFERCORES[31]  ⍝11 Jul 2014: expand stream cores downstream based on watershed area, and base multiplier on watershed area[32]  ⍝14 Jul 2014: don't expand into larger rivers; write seeds to help with evaluation[33]  ⍝22-23 Jul 2014: use resistance when expanding[34]  ⍝29 Jul 2014: don't expand aquatic cores downstream through dams[35]  ⍝8 Aug 2014: expand cores upstream as well as down[36]  ⍝21 Aug 2014: aquatic seeds in centerlines only, and clip enough so we don't cut off blobs because of extension[37]  ⍝22 Aug 2014: bug lost patches completely surrounded by development[38]  [39]  [40]  [41]   READPARS ME[42]   X←READ 1⊃1⊃A                                   ⍝Read value grid[43]   W←READ 2⊃1⊃A                                   ⍝And landcover[44]   Q←W∊LOOKNAMES barriers                         ⍝Set highways to missing so they'll get super-high resistance[45]   X←MVREP X (Q∨(W∊LOOKNAMES culverts)^FOCALMAX Q)⍝Set culverts and dams to missing if adjacent to highways[46]   Q←0 ⎕TCHT MATIN pathI PATH systems,(~'.'∊systems)/'.txt'[47]   Y←X×W∊(LOOKUP 0,Q)[;1]                         ⍝Set everything outside of selected systems in landcover to 0[48]   Y←Y≥slice                                      ⍝Take values ≥ slice[49]   Y←((Y≠0)^W≠MV)×expand BUFFER Y                 ⍝Buffer to merge fragments, but not across value = 0 or landcover = missing[50]   Y←FINDPATCH Y                                  ⍝Build patches (8-neighbor)[51]  [52]   Q←(Q≠0)/Q←,Y[53]   Q←Q[⍋Q][54]   B←Q≠0,¯1↓Q[55]   Q←(B/Q),[1.5]B pSUM (⍴B)⍴1                     ⍝Patch #, number of cells[56]   Y←Y×Y∊U←(Q[;2]>toosmall)/Q[;1]                 ⍝Drop tiny patches[57]   Y←MVREP Y ((W=MV)∨X=MV)                        ⍝Carry over missing cells in landcover or value[58]  [59]   B←1+⌈bandwidth÷cellsize                        ⍝Buffer; take 1 extra cell to deal with rounding[60]   D←(⍳1+2×B)-B+1                                 ⍝Maximum radius possible to travel[61]   KK8←8 2⍴¯1 0 1 0 0 ¯1 0 1 ¯1 ¯1 1 1 ¯1 1 1 ¯1  ⍝8-neighbor rule for FOCALMIN[62]   Z←(⍴X)⍴0[63]  [64]   I←0[65]   :if which≡'terrestrial'                        ⍝If terrestrial cores,[66]   dot←⍴⍞←'Building kernels for ',(⍕⍴U),' cores' ⋄ FLUSH[67]   R←1+multiplier×1-X                             ⍝   Rescale IEI/selection index into resistance[68]   R←1E6 MVREP R (Y=MV)                           ⍝   missing cells get resistance of a million[69]  L1:→((⍴U)<I←I+1)/L5                             ⍝   For each core,[70]   BREAKCHECK[71]   DOT[72]   L M ← B CLIP Y=U[I]                            ⍝      Clip to this core plus buffer[73]   C←C×(C≠0)^0=FOCALMIN C←0 MVREP Y[L;M]          ⍝      Edges of core[74]   V←(⍴C)⍴0[75]   S←20<+/,C=U[I]                                 ⍝      If core is small with few edge cells, don't skip any cells[76]  [77]   J←1[78]  L2:→(((1↑⍴C))<J←J+1)/L4                         ⍝      For each row,[79]   →(S^(J÷density)≠⌊J÷density)/L2                 ⍝         skip this row?[80]   K←1[81]  L3:→(((1↓⍴C))<K←K+1)/L2                         ⍝         For each column,[82]   →(S^(K÷density)≠⌊K÷density)/L3                 ⍝         skip this column?[83]   →((C[J;K]≠U[I]))/L3                            ⍝            If in edge of this core,[84]   F←((F>0)^F≤1↑⍴C)/F←J+D ⋄ G←((G>0)^G≤1↓⍴C)/G←K+D[85]   T←SPREAD B (F⍳J) (G⍳K) (R[L;M][F;G])           ⍝            Build kernel[86]   V[F;G]←V[F;G]⌈T÷B                              ⍝            Take max with core's result[87]   →L3[88]  [89]  L4:Z[L;M]←Z[L;M]⌈V                              ⍝      Take max of this core and running results[90]   →L1[91]  [92]   :else                                          ⍝Else, aquatic cores,[93]   E←READ 3⊃1⊃A                                   ⍝   Read flow grid[94]   R←READ 4⊃1⊃A                                   ⍝   and time of flow resistance[95]   H←READ 5⊃1⊃A                                   ⍝   and flow accumulation[96]   sg←1=READ 6⊃1⊃A                                ⍝   and stream centerlines[97]   S2←(⍴X)⍴0                                      ⍝   for writing seeds[98]   fd←(2*¯1+⍳8),8 2⍴0 1 1 1 1 0 1 ¯1 0 ¯1 ¯1 ¯1 ¯1 0 ¯1 1[99]   N←FINDPATCH W=LOOK 'lentic'                    ⍝   Identify all lakes[100]  Y←FINDPATCH Y⌈N∊T←(T≠0)/T←,N×Y≥1               ⍝   Light up entire lakes that our cores fall into & rebuild cores[101]  U←((U⍳U)=⍳⍴U)/U←(,Y≠0)/,Y                      ⍝   rebuild unique core list[102]  ⍞←'Building kernels for ',(⍕⍴U),' cores' ⋄ FLUSH[103] [104] L6:→((⍴U)<I←I+1)/L5                             ⍝   For each core,[105]  BREAKCHECK[106]  S←sg^Y=U[I]                                    ⍝      Select cells in core, centerlines only[107]  L M ← (B+wetexpand[2]) CLIP S                  ⍝      Clip to this core plus buffer plus max wetexpand (overkill, but should be safe)[108]  O2←(INDICES O←O=⌈/,O←H[L;M]×S←S[L;M])[1;]      ⍝      Identify bottommost cell--we'll always keep this in; O2 is indices[109]  F←⍟H[L;M][O2[1];O2[2]]                         ⍝      ln(flow accumulation at botttommost cell of core before expansion)[110]  S2[L;M]←S2[L;M]⌈S×2                            ⍝      seed cells (2 for original seed)[111] [112] ⍝Expand seeds to build full core[113]  :if (W[L;M][O2[1];O2[2]])≠LOOK 'lentic'        ⍝      if bottommost cell is not lentic,[114]     ⍝First, expand downstream[115]     P←P2←⌈(÷cellsize)×wetexpand[1]+(-/wetexpand[2 1])×(F-accumrange[1])÷-/accumrange[2 1] ⍝      distance to expand core up/downstream is a function of watershed area[116]     T←Q←O2[117] L10:P←P-(1+expandmult≠0)⊃1 (1+expandmult×1-X[L;M][T[1];T[2]])    ⍝      Repeat: subtract 1 or resistance, depending on expandmult[118]     →(P<0)/L11                                  ⍝         If we haven't gone too far yet,[119]     T←,E[L;M] NEXTFLOW Q[120]     →(∨/T=0)/L11                                ⍝            bail out if we hit the edge[121]     →(W[L;M][T[1];T[2]]=LOOK 'lentic')/L11      ⍝            or if we hit a lake[122]     →(W[L;M][T[1];T[2]]=LOOK 'dam')/L11         ⍝            or a dam[123]     →((⍟H[L;M][T[1];T[2]])>1+⍟H[L;M][O2[1];O2[2]])/L11 ⍝            or if we hit a bigger river[124]     S[Q[1];(Q←T)[2]]←1                          ⍝            include this cell in core[125]     →L10[126] L11:[127]     :if expandup[128]        S ← EXPANDUP P2 O O2 (X[L;M]) (E[L;M]×sg[L;M]) (W[L;M]) (H[L;M]) S            ⍝         Now expand upstream[129]     :end[130]     O←(⍴O)⍴0[131]     O[O2[1];(O2←Q)[2]]←1                        ⍝         Re-find bottommost cell (depends on downstream, but not upstream, expansion)[132]  :end[133] [134]  S2[L;M]←S2[L;M]⌈S                              ⍝      seed cells (2 = core, 1 = expansion)[135]  C←O∨S^0≠E[L;M] UPFLOW ~S                       ⍝      find "edges"--cells in core that stuff flows into from outside[136]  C←INDICES C                                    ⍝      make list of indices[137]  V←(⍴S)⍴0[138]  :if (W[L;M][O2[1];O2[2]])=LOOK 'lentic'        ⍝      if it's a lake,[139]     P←multiplier                                ⍝         use standard multiplier[140]  :else                                          ⍝      else, for rivers,[141]     P←wetmultiplier[1]+(-/wetmultiplier[2 1])×(F-accumrange[1])÷-/accumrange[2 1]    ⍝      multiplier is a function of watershed area[142]  :end[143]  R2←1+P×(R-wresistrange[1])÷wresistrange[2]     ⍝   rescale time of flow into resistance[144] [145]  J←0[146]  dot←⍴⍞←⎕TCNL,(⍕I),' of ',(⍕⍴U),' cores, ',(⍕1↑⍴C),' cells' ⋄ FLUSH[147] L7:→((1↑⍴C)<J←J+1)/L8                           ⍝      For each "edge" cell,[148]  DOT[149]  V←V⌈(÷B)×WETSPREAD B (C[J;1]) (C[J;2]) (R2[L;M]) (E[L;M])   ⍝         Build kernel[150]  →L7[151] [152] L8:Z[L;M]←Z[L;M]⌈S⌈E[L;M] CORE_WATERSHED V S    ⍝      mask kernel so we only build upstream of core[153]  →L6[154]  :end[155] [156] L5:transparent←3                                ⍝Use max transparency mode[157]  (MVREP Z ((X=MV)∨Z=0)) WRITE 1⊃3⊃A             ⍝Save transparently, with all 0's set to missing[158]  ⎕←''[159]  :if which≡'aquatic'                            ⍝If aquatic cores,[160]     (MVREP S2 (S2=0)) WRITEI 2⊃3⊃A              ⍝   Write seeds[161]  :end[162]  →0[163] [164] [165] [166] what:auxiliary[167] type:standard[168] info:('value' 'land' '*flow' ('*',pathS,'wresist') 'fd8accum' 'streams') ('') ('cores' 'seeds') (buffer⌈⌈bandwidth÷cellsize)       ⍝Source grid, settings table, result grid, and buffer size[169] check:CHECKVAR 'which systems slice expand toosmall multiplier bandwidth density barriers culverts buffer wetmultiplier accumrange wetexpand expandmult expandup'    ∇