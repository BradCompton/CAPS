    ∇ Z←W NEW_TILEMAP G;X;F;Q;B;REST;I;J;noread;ifchat;Y;V;T;dot;L;M;A;U;C;H;E;tilemaprecover;S;N;O;K[1]   ⍝Tracks empty tiles (size, buffer, maskgroup in 2 3 4⊃⍵) in for include grid 1⊃⍵ and current mask grid to save runtime; ignore mask if ⍺[2]   ⍝Globals:[3]   ⍝   tilemap         Filename to use; if '' turn off this facility[4]   ⍝   tilemapinclude  If yes, use the include grid, if no, assume it's all 1s[5]   ⍝   altmask         If not empty, this is the alternative mask name (used for jointmask from CSE_SCENARIOS)[6]   ⍝   block           Assumes BLOCK/READ have already been called for current situation[7]   ⍝On first call for a particular grid/tile/buffer, the grid will be scanned[8]   ⍝to look for empty blocks; results are saved in tilemap database.  On subsequent[9]   ⍝runs, database is used.  Delete tilemap.txt to reset database (duh).[10]  ⍝Returns binary vector corresponding to blocks in landscape.[11]  ⍝maskgroup (⍵[4]) is interpreted as follows:[12]  ⍝  > 0      indicates which bit of the mask grid is used for the mask.[13]  ⍝  = 0      all positive cells in the grid are considered unmasked[14]  ⍝  = ¯1     all cells > ¯1 are considered unmasked (zero + positive integers)[15]  ⍝  = MV     only MV cells are considered masked (in all of the above MV cells are also masked)[16]  [17]  ⍝B. Compton, 16-19 Nov 2010[18]  ⍝7 Dec 2010: Screen out blocks that are all missing, but include zeros--need this for BARRIERS.  Sigh.[19]  ⍝3 Feb 2011: Allow alternate grid names, with default of include.  Back to excluding zeros, because BARRIERS can use land.[20]  ⍝4 Apr 2011: Strip path from grid name[21]  ⍝16 Jun 2011: bug - restart blocks at 0,0[22]  ⍝21 Jun 2011: don't read if only 1 block[23]  ⍝22 Jun 2011: use local grid server to prevent bogging down[24]  ⍝27 Oct 2011: don't replace include grid with stripped version--then it can't find it if it's somewhere funny[25]  ⍝19 Jan 2012: keep full path of reference grid, in case of differing extents[26]  ⍝8 Feb 2012: oops--match case when looking up grid name!; restore block (I wish APL had leaky localization!)[27]  ⍝10 Jul 2012: respect the mask!  *** Note: if you change the mask, you'll have to delete tilemap.txt![28]  ⍝20 Aug 2012: attempt to read the whole grid at once with FASTBLOCKMAP.  4x+ speedups.[29]  ⍝21 Aug 2012: include bitmask group in tilemap file (* all old blockmap files are obsolete!)[30]  ⍝24 Aug 2012: rename from BLOCKMAP; add tilemapinclude; store mask grid too; exclude negative mask elements; lock directory; new maskgroup interpretations[31]  ⍝4 Sep 2012: ignore mask if ⍺[32]  ⍝5 Sep 2012: Aaargh! Was exiting before releasing lock.[33]  ⍝27 Sep 2012: unlock tilemap directory if there's an error[34]  ⍝14 Jan 2013: a couple of minor bugs involving tilemapinclude and mask[35]  ⍝18 Feb 2013: I had mask grid condition switched(?!)[36]  ⍝28 Feb 2013: when setting ⎕ELX, clear RETURNLOCK so it only gets called once[37]  ⍝14 Jun 2013: call CONFIG before getting a lock[38]  ⍝26 Jul 2013: add altmask; 12 Aug 2013: don't fail if it doesn't exist[39]  ⍝1 Aug 2013: don't try to use mask grid if mask = ''[40]  ⍝20 Aug 2013: If using altmask, it gets full status as mask grid[41]  ⍝21 Nov 2013: completely revise locking scheme to keep from piling up TILEMAPs[42]  ⍝3 Jan 2014: use LOCKFILE/UNLOCKFILE[43]  ⍝9 Jan 2014: add recovery from crashes so tilemap.txt isn't screwed up[44]  ⍝28 Jan 2014: recover properly when calling TILEMAPRECOVER[45]  [46]  [47]  [48]   ⍎(0=⎕NC'W')/'W←0'[49]   Z←1 ⋄ U←0[50]   →(0=⎕NC'tilemap')/0[51]   →((~0∊⍴blocks)∨0∊⍴tilemap)/0                       ⍝If tilemap facility is turned off (or selected blocks turned on), just exit[52]  [53]   ⍎(0∊⍴⊃G[1])/'G[1]←⊂1 GRIDNAME ''include'''         ⍝Default grid is include[54]   G←4↑G,0[55]   G[1]←'' (1⊃G)[tilemapinclude+1]                    ⍝If tilemapinclude = no, include grid is blank[56]   T←'mask' ⋄ ⍎(0≠⎕NC'altmask')/'T←(1+0≠⍴altmask)⊃''mask'' altmask'[57]   M←(~W)/GRIDNAME T                                  ⍝Mask grid (if used; set it to nothing in inputs.par to not use it ... or use ⍺=1)[58]   X←''[59]  [60]   F←pathP PATH tilemap[61]   A←(~cluster)∨≡/FRDBL¨TOLOWER¨pathA F               ⍝If doing a cluster run and writing to a path other than Anthill, we'll have to lock[62]  L10:[63]   :if ~A[64]      H←LOCKFILE (1+-(⌽F)⍳'\')↓F                      ⍝   get a lock[65]   :end[66]   →(~IFEXISTS F)/L1                                  ⍝If tilemap exists,[67]   X←NREAD F                                          ⍝   Read it[68]   Q←FRDBL¨↓VTOM TOLOWER ⎕TCHT FIRSTCOL X             ⍝   grid names[69]   B←Q≡¨⊂TOLOWER FRDBL 1⊃G                            ⍝   matches[70]   B←B^(⊂TOLOWER M)≡¨TOLOWER¨FRDBL¨↓VTOM ⎕TCHT FIRSTCOL REST    ⍝   mask grid[71]   B←B^G[2]=⎕FI ' ' MTOV VTOM ⎕TCHT FIRSTCOL REST     ⍝   block size matches[72]   B←B^G[3]=⎕FI ' ' MTOV VTOM ⎕TCHT FIRSTCOL REST     ⍝   buffer size[73]   B←B^G[4]=⎕FI ' ' MTOV VTOM ⎕TCHT FIRSTCOL REST     ⍝   maskgroup (0 means no mask or not in a group)[74]   →(~1∊B)/L1                                         ⍝   If found,[75]   Z←(B⌿VTOM REST)[1;]                                ⍝      get binary vector (take 1st occurence by some error there are multiples)[76]   :if (10↑Z)≡'working...'                            ⍝      If tilemap is being built by another task,[77]      :if ~A                                          ⍝         if not writing to Anthill path,[78]         UNLOCKFILE H                                 ⍝            return the lock[79]      :end[80]      ⍞←(~U)/'Waiting for another thread to build tilemap for',(⍕G),'(',NOW,')...',⎕TCNL ⋄ FLUSH[81]      U←1[82]      T←⎕DL 60                                        ⍝         sleep for a minute[83]      →L10                                            ⍝         and try again[84]   :end[85]   Z←⎕FI((2×⍴Z)⍴1 0)\Z                                ⍝      decode it & return[86]   →L9[87]  [88]  L1:X←X,⎕TCNL,(C←⊃,/((⊂M),⍕¨G)[2 1 3 4 5],¨⎕TCHT),'working...' ⍝Else, we'll have to build tilemap. Write 'working...' to tilemap.txt[89]   X NWRITE F[90]   :if ~A                                             ⍝   and return the lock[91]      UNLOCKFILE H[92]   :end[93]  [94]  [95]   tilemaprecover ← A F C ⎕ELX[96]   ⎕ELX←'TILEMAPRECOVER ⋄ ⎕ERROR ⎕DM'                 ⍝   Set error trapping to recover if we crash while building the tile map[97]  [98]   L←block                                            ⍝   If only 1 block[99]   →(∨/block[6 7]≠1)/L5[100]  V←1 1⍴1[101]  →L4[102] [103] L5:ifchat←noread←0[104]  block[4 5]←0                                       ⍝      Reset to start of blocks[105] ⍝ ⎕←'Building tilemap library for',(tilemapinclude)/' grid ',(1⊃G),','),' tile size ',(⍕2⊃G),', buffer ',(⍕3⊃G),', and mask group ',(⍕4⊃G),' (',(⍕block[6]),' x ',(⍕block[7]),' tiles)' ⋄ FLUSH[106]  Q←('grid ',1⊃G) ('mask ',M) ('tile size ',⍕2⊃G) ('buffer ',⍕3⊃G) ('mask group ',⍕4⊃G)[107]  Q←(tilemapinclude,(~0∊⍴M),1 1,0≠4⊃G)/Q[108]  ⎕←'Building tilemap library for ',(ONETWOMANY Q),' (',(⍕block[6]),' x ',(⍕block[7]),' tiles)' ⋄ FLUSH[109] [110]  →(~0∊⍴V←M FASTTILEMAP G)/L4                        ⍝   If fast version fails (because grid is too big), resort to old block-by-block version,[111]  V←block[6 7]⍴0[112] [113] [114] ⎕ELX←'⎕DM' ⍝******************** TEMP *****************[115] ⍝Now figure out how many tiles we can read at once. I think we don't care how many panes read read across--we have to do it some time.  ------------------------[116]  N←⌊(⌊10E6÷block[1])÷block[2]                       ⍝   Shoot for 10M cells.  This is how many tiles we can read.[117]  ⎕←'Reading ',(⍕N⌊(⍴V)[2]),' tiles at a time (',(⍕(⍴V)[1]×⌈(⍴V)[2]÷N),' passes)...' ⋄ FLUSH[118] [119]  I←0[120] L2:→(block[6]<I←I+1)/L4                             ⍝      For each row of tiles,[121] ⍝ ⍞←'[',(FRDBL 2⍕100×I÷block[6]),'%]' ⋄ FLUSH[122]  J←0[123] L3:→(0∊⍴O←J+⍳N⌊block[7]-J)/L6                       ⍝         For each set of column tiles,[124]  block[5]←J+1                                       ⍝            starting column tile[125]  J←J+⍴O[126]  BREAKCHECK[127]  DOT[128]  S←THISBLOCK[1 2],(block[1 2]×1,⍴O),block[3]        ⍝            Starting row, col, size of block, buffer (THISBLOCK results)[129]  :if tilemapinclude                                 ⍝            If tilemapinclude = yes,[130]     Y←READBLOCK (⊂pathG PATH 1⊃G),S                 ⍝               read wide block of include grid[131]     Y←~Y∊0,MV                                       ⍝               included cells[132]  :else[133]     Y←1[134]  :end[135] [136]  :if ~W∨0∊⍴M                                        ⍝               If using mask grid,[137]     Q←READBLOCK (⊂pathG PATH M),S                   ⍝                  read wide block of mask grid[138]     ⍎(G[4]=MV)/'Q←Q≠MV'                             ⍝            if G[4]=MV, everything but MV is in[139]     Y←Y^Q>0-G[4]=¯1                                 ⍝            mask is true if positive; include 0 G[4]=¯1[140]     Q←0⌈0 MVREP Q[141]     :if ~(G[4]∊0 ¯1 MV)∨~∨/,Y                       ⍝            If using maskbits and there's anything in mask,[142]        Y←Y^(⊖((G[4]⍴2)⊤Q))[G[4];;]                  ⍝               apply them[143]     :end[144]  :end[145] [146]  Y←∨⌿Y                                              ⍝            Collapse out rows[147]  K←0[148] L7:→((⍴O)<K←K+1)/L3                                 ⍝            For each tile (have to loop b/c of buffers),[149]  V[I;O[K]]←∨/Y[((K-1)×block[2])+⍳block[2]+2×S[5]]   ⍝               This tile is in if any data in it[150]  →L7[151] [152] L6:block[4]←block[4]+1                              ⍝   Increment tile row[153]  →L2[154] [155] [156] L4:⎕←⎕TCNL,'Tile map:'[157]  ⎕←' ',' ',' ',1 0⍕V[158]  ⎕←'' ⋄ FLUSH[159] ⎕←'Time: ',⍕⎕AI[2]-TTT[160] [161]  G[1]←⊂1⊃G                                          ⍝Strip path from grid name (a little dangerous?)[162]  block←L                                            ⍝Restore block to its original value[163] [164]  ⎕ELX←4⊃tilemaprecover                              ⍝We're good--turn off error trapping[165]  :if ~A[166]     H←LOCKFILE (1+-(⌽F)⍳'\')↓F                      ⍝Get the lock again[167]  :end[168]  X←VTOM ⎕TCNL,NREAD F                               ⍝Read the file again[169]  I←((⊂C)≡¨↓X[;⍳⍴C])⍳1                               ⍝Find our line[170]  Q←C,1 0⍕Z←,V[171]  X←((1↑⍴X),(1↓⍴X)⌈⍴Q)↑X                             ⍝Replace it[172]  X[I;]←(1↓⍴X)↑Q[173]  X←1↓MTOV X[174]  X NWRITE F                                         ⍝And write it[175] [176] L9:→A/0                                             ⍝If writing to a path other than Anthill,[177]  UNLOCKFILE H                                       ⍝   unlock directory    ∇