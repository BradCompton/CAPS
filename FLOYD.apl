    ∇ Z←R FLOYD X;I;J;K;Q;err;D[1]   ⍝Floyd-Warshall: find highest-probability (⍺[1]=0) / shortest distance (⍺[1]=1) paths in graph ⍵ (optionally round to ⍺[2] digits)[2]   ⍝Diagonals are 1; distances with no edges should be 0[3]   ⍝Source: http://compprog.wordpress.com/2007/11/15/all-sources-shortest-path-the-floyd-warshall-algorithm/[4]   ⍝Runs APL version if aplc=1, or C version if aplc=2[5]   ⍝B. Compton, 17 Dec 2012[6]   ⍝1 Apr 2013: replace with clever parallel version from PC (March 2008); round to ⍺ digits for speed-up[7]   ⍝9 Apr 2013: incorporate Edi's C++ version (16-32x faster!)[8]   ⍝11 Apr 2013: add as_distances option; rename from FLOYDP[9]   [10]  [11]  [12]   ⍎(0=⎕NC'R')/'R←0 ¯1'           ⍝Default is use probabilities, no rounding[13]   D R ← 2↑R,¯1                   ⍝Distance and rounding[14]   ⍎(R≠¯1)/'X←R ROUND X'[15]  [16]   →(aplc=1)/L0                   ⍝If C version,[17]   →(3=⎕NC'FLOYDc')/L1            ⍝   If not loaded,[18]   Q←⎕EX 'FLOYDc'[19]   ⎕ERROR REPORTC 'DLL I4←CAPS_LIB.floyd_warshall(I4,*F8←,I4)' ⎕NA 'FLOYDc'[20]  [21]  L1:Z←X[22]   err Z ← FLOYDc (1↑⍴X) X D[23]   ⎕ERROR REPORTC err[24]   ⍎(R≠¯1)/'Z←R ROUND Z'[25]   →0[26]  [27]  L0:⎕ERROR (D=1)/'FLOYD not implemented for distances in APL (easy enough to do if you need it)'[28]  L2:Z←X                          ⍝Else, use clever parallel APL version of Floyd-Warshall algorithm to find stepping-stone probabilities[29]   X←X⌈X⌈.×X[30]   ⍎(R≠¯1)/'Z←R ROUND Z'[31]   →(~Z≡X)/L2[32]   →0[33]  [34]  [35]  ⍝Standard looping version. It's considerably slower.[36]  ⍝ Z←X[37]  ⍝ K←0[38]  ⍝L11:→((1↑⍴Z)<K←K+1)/0            ⍝For each intermediate vertex,[39]  ⍝ I←0[40]  ⍝L12:→((1↑⍴Z)<I←I+1)/L11          ⍝   For each row,[41]  ⍝ J←0[42]  ⍝L13:→((1↓⍴Z)<J←J+1)/L12          ⍝      For each column,[43]  ⍝ →((Z[I;K]×Z[K;J])≤Z[I;J])/L13   ⍝         If higher probability using this path,[44]  ⍝ Z[I;J]←Z[I;K]×Z[K;J][45]  ⍝ →L13    ∇