    ∇ A MAKENODES S;cores;select;X;N;buffer;nodesize;slice;Q;B;C;L;head;transparent;I[1]   ⍝Pre-process data for FINDPATHS, creating nodes from binary or continuous grids (e.g. from TCORES)[2]   ⍝Creates CLII path and subpaths if necessary[3]   ⍝Parameters:[4]   ⍝   cores       name of grid with cores[5]   ⍝   select      name of grid with selection index (or IEI). Use '' for binary cores and set slice to 0.5.[6]   ⍝   slice       threshold for cores[7]   ⍝   nodesize    radius of largest node, from centroid, in km[8]   ⍝Results (in pathQ, CLII path):[9]   ⍝   <path>\source\[10]  ⍝	   nodes            Integer grid with node # for each reserve polygon.[11]  ⍝   <path>\tables\[12]  ⍝      nodes.txt        More information about reserve nodes.   Node #, centroid-x,[13]  ⍝                       centroid-y, reserve name, priority, include, min-x, min-y, max-x, max-y.[14]  ⍝      nodevalues.txt	Values for nodes, with IEI-weighted size: mask, x, y, nodes, iei[15]  ⍝Node numbers are (tile # × 10,000) + node within tile[16]  ⍝B. Compton, 9-10 Jul 2014[17]  ⍝26 Oct 2014: allow binary cores[18]  ⍝28 Oct 2014: don't get burned by rounding errors when taking slice[19]  ⍝19-20 Nov 2014: get MER for FINDPATHS; use pathQ instead of resultpath; create CLII folders if they don't exist yet[20]  ⍝15 Dec 2014: Ugh! I fucked up nodevalues.txt in last change.[21]  [22]  [23]  [24]   READPARS ME[25]   buffer←4⊃A[26]   N←X←0 MVREP READ GRIDNAME cores                ⍝Read cores grid[27]   :if ~select≡''[28]      N←0 MVREP READ GRIDNAME select              ⍝   Read selection index/IEI; missing → 0[29]   :end[30]   X←FINDPATCH (2 ROUND X)≥slice                  ⍝Slice to get cores and find patches[31]   Q←(,X),(,⍉(⌽⍴X)⍴⍳1↑⍴X),(,(⍴X)⍴⍳1↓⍴X),[1.5],N   ⍝Patch, row, col, IEI[32]   Q←(Q[;1]≠0)⌿Q[33]   Q←Q[⍋Q;][34]   B←Q[;1]≠0,¯1↓Q[;1][35]   C←(B/Q[;1]),(B pMEAN Q[;2 3]),B pSUM Q[;4]     ⍝Patch #, patch centroid, IEI-weighted size[36]   C←((^/C[;2 3]>buffer)^^/C[;2 3]<((1↑⍴C),2)⍴(⍴X)-buffer)⌿C   ⍝Only want patches with centroid that falls in tile proper[37]   X←MVREP X ((X=0)∨~X∊C[;1])                     ⍝Drop patches with centroid outside of tile[38]   C[;2 3]←↑1 FINDPOINT¨↓C[;2 3]                  ⍝Centroids in terms of points[39]   C←((1↑⍴C),8)↑C[40]  [41]   I←0[42]  L1:→((1↑⍴C)<I←I+1)/L2                           ⍝For each node,[43]   C[I;5 6 7 8]←(⊃,/1 FINDPOINT¨↓⍉↑⌽¨2↑¨¯1⌽¨CLIP X=C[I;1])[1 4 3 2]  ⍝   find MER[44]   →L1[45]  [46]  L2:C[;1]←(L←C[;,1],(⍳1↑⍴C)+block[11]×1E4)[;2]   ⍝Node number translation[47]   X←(L[;2],MV)[L[;1]⍳X]                          ⍝Translate node numbers in grid[48]   MAKEDIR pathQ,'source\'[49]   MAKEDIR pathQ,'results\'[50]  [51]   transparent←1[52]   (⌊X) WRITEI pathQ,'source\nodes'               ⍝Write node id grid as integer[53]   (C[;⍳3],(⊂''),C[;4],1,C[;5 6 7 8]) LOCKWRITE pathQ,'tables\nodes.txt'[54]   (1,C[;2 3 1 4]) LOCKWRITE pathQ,'tables\nodevalues.txt'[55]   →0[56]  [57]  [58]  what:data prep[59]  type:standard[60]  init:MAKEDIR pathQ,'tables\' ⋄ head←1↓⎕TCHT MTOV MATRIFY 'id centroid-x centroid-y name importance include min-x min-y max-x max-y' ⋄ (0 0⍴'') TMATOUT pathQ,'tables\nodes.txt'[61]  init:head←1↓⎕TCHT MTOV MATRIFY 'mask x y nodes iei' ⋄ (0 0⍴'') TMATOUT pathQ,'tables\nodevalues.txt'[62]  info:('') ('') ('') (⌈nodesize×1E3÷30) ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[63]  check:CHECKVAR 'cores select slice'[64]  check:CHECKGRIDEXISTS GRIDNAME cores[65]  check:CHECKGRIDEXISTS GRIDNAME select    ∇