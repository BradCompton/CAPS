    ∇ A FIXCRACKS S;buffer;X;I;J;head;Z;V;input;result;T;L;K;C;Q;M[1]   ⍝Find cracks in roads (thanks to Arc's blindness to perfect diagonals) & fix them[2]   ⍝Source:[3]   ⍝   source\<input>      One of: roadtraffic, roads, trains[4]   ⍝   source\roadlines.txt or trainlines.txt     Roadlines or trainlines text file, from makeroads.aml[5]   ⍝Results:[6]   ⍝   source\<result>     Rename this to replace original if it looks good[7]   ⍝   working\cracks.txt  Text file of x,y points of cracks[8]   ⍝After running for roads → roads2 and roadtraffic → roadtraffic2, need to run fixroadcracks.aml[9]   ⍝to reconcile them.[10]  ⍝Finally, rename roads2, roadtraffic2, and trains2 to replace originals[11]  ⍝B. Compton, 22 Jun 2015[12]  [13]  [14]  [15]   READPARS ME[16]   buffer←4⊃A[17]  [18]   X←READ 1⊃A                                 ⍝Read traffic/roads/trains[19]  [20]   :if (T←STRIP input)≡'roadtraffic'[21]      V←X                                     ⍝   traffic has 0 off-roads, increasing traffic.  V is 0, increasing for bigger for all[22]      M←'roadlines.txt'[23]   :elseif T≡'roads'[24]      V←0 MVREP (6-X) (X=MV)                  ⍝   roads are MV off-roads, decreasing class[25]      M←'roadlines.txt'[26]   :elseif T≡'trains'[27]      V←X≠MV                                  ⍝   treat trains as binary[28]      M←'trainlines.txt'[29]   :else[30]      ⎕ERROR 'Input must be one of roadtraffic, roads, or trains'[31]   :end[32]  [33]   L←READVEC pathS PATH M                     ⍝Read roadlines.txt/trainlines.txt[34]   L←(1⊃L)[;(2⊃L) COL 'x1 y1 x2 y2'][35]  [36]   Z←0 3⍴0                                    ⍝Log points of cracks[37]   I←0[38]  L1:→((¯1+1↑⍴X)<I←I+1)/L3                    ⍝For each row but last,[39]   J←0[40]  L2:→((¯1+1↓⍴X)<J←J+1)/L1                    ⍝   For each column but last,[41]   K←0[42]   :if ∨/V[I;J+0 1]≠0                         ⍝      If UL or UR of 2x2 is a road cell,[43]      :if (^/V[I;J]>V[I+1;J],V[I;J+1])^^/V[I+1;J+1]>V[I+1;J],V[I;J+1]  ⍝         If UL and LR are both > UR and LL,[44]      :andif X[I;J]=X[I+1;J+1]                ⍝This could be a crack[45]         K←1                              [46]      :end [47]      :if (^/V[I;J+1]>V[I;J],V[I+1;J+1])^^/V[I+1;J]>V[I;J],V[I+1;J+1] ⍝         If UR and LL are both > UL and LR,[48]      :andif X[I;J+1]=X[I+1;J][49]         K←2[50]      :end [51]      →(K=0)/L2                               ⍝      If we have a potential crack,[52]      C←1 FINDPOINT I J+.5                    ⍝         Centerpoint of crack[53]      Q←((^/L[;1 2]≥((1↑⍴L),2)⍴C-2000)^^/L[;3 4]≤((1↑⍴L),2)⍴C+2000)⌿L     ⍝         Nearby road/train line segments   [54]      S←(C[1]+¯10 10),[1.5]C[2]               ⍝         20 m horizontal line at crack (to account for generalization)[55]      →(0∊⍴S CROSSPOINT Q)/L2                 ⍝         If a road crosses our centerpoint,[56]      Z←Z⍪(1 FINDPOINT I,J+K=1),'UL' 'UR'[K]  ⍝            We have a crack![57]      X[I;J+K=1]←X[I;J+K=2]                   ⍝            Fix crack[58]   :end[59]   →L2[60]  [61]  L3:X WRITEI 3⊃A[62]   head←1↓⎕TCHT MTOV MATRIFY 'x-coord y-coord corner'[63]   Z LOCKWRITE pathW,'cracks.txt'[64]   →0[65]  [66]  [67]  [68]  what:data prep[69]  type:standard[70]  init:head←1↓⎕TCHT MTOV MATRIFY 'x-coord y-coord corner' ⋄ (0 0⍴'') TMATOUT pathW,'cracks.txt'[71]  info:(pathS PATH input) ('') (pathS PATH result) (1) 'luwet'      ⍝Source grid, settings table, result grid, buffer size, and include grid[72]  check:CHECKVAR 'input result'    ∇