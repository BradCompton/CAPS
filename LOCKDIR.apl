    ∇ Z←A LOCKDIR P;W;R;W;R;N;L;T;I;C;X;M;V[1]   ⍝Lock cluster run for thread, maxid, weight, and bonus ⍵ and directory ⍺ (default = pathA)[2]   ⍝This function "locks" a directory by creating a series of lock files.[3]   ⍝if those files already exist it assumes the directory is locked by someone else[4]   ⍝and waits for them to disapear.  Because it might be possible for multiple processes to[5]   ⍝create a file simulatiously each thread has a series of pauses that is unique to it.[6]   ⍝Global:[7]   ⍝   pathA   cluster path to lock[8]   ⍝Arguments:[9]   ⍝   ⍵[1] = thread       id of the current thread[10]  ⍝   ⍵[2] = timeout      time in seconds beyond which it assumes a collision has occured and resets the locks[11]  ⍝                       if 0, than never reset; default = 3600 (1 hour)[12]  ⍝   ⍵[3] = bonus lock   include one extra random lock for testing; default = 0[13]  ⍝   ⍵[4] = pause wait   wait between pauses; default = 0.1[14]  ⍝   ⍵[5] = n pauses     number of pauses between keys = (keys-1); default = 4[15]  ⍝   ⍵[6] = n threads    number of threads; default = threadlimit[16]  ⍝Globals:[17]  ⍝   pathA               default cluster path; used if not passed in ⍺[18]  ⍝   name                computer name[19]  ⍝Result:[20]  ⍝   wait time           total wait time (Seconds)[21]  ⍝   collision count     count of how many times the lock file existed when the prior lock file didn't[22]  ⍝   reset count         count of how many times it reset the locks (because of a timeout specified by maxwait)[23]  ⍝B. Compton, 8-11 Apr 2011, from E. Plunkett, lock.dir()[24]  ⍝11 Apr 2011: Drop unnecessary IFEXISTS calls[25]  ⍝14 Apr 2011: Add call to TIMEOUT, pass in path, change parameter order and defaults. 9 Jan 2014: delete TIMEOUT - we don't use it any more[26]  ⍝2 Jun 2011: Write computer.thread to lock files.  14 Jun 2011: also date.  20 Jul 2011: and 'APL'[27]  ⍝23 Aug 2011: Don't be so quick to give Waiting for lock message when sleeping[28]  ⍝1 May 2012: oh!  Recreate stuff to write to lock file within loop so it's not stale![29]  ⍝12 Mar 2013: maxthreads → threadlimit (this function is deprecated)[30]  [31]  [32]   OBSOLETE VERSION[33]  [34]  [35]  ⍝⍞←'→ Getting a lock...' ⋄ FLUSH[36]   ⍎(0=⎕NC'A')/'A←pathA'[37]   ⍎(0=⎕NC'threadlimit')/'threadlimit←625'[38]   P←6↑P,(⍴,P)↓0 3600 0 .1 4,threadlimit           ⍝Defaults[39]   threadlimit←P[6][40]   X←CALCPAUSES P[1 6 5 4]                        ⍝Get number of pauses[41]   W←R←0                                          ⍝Total wait time, count of resets[42]   N←(P[5]+⍴X)⍴0                                  ⍝Number of pauses (one more pause than lock), not counting bonus[43]   M←0[44]   ⍎(0=⎕NC'name')/'name←GETNAME'[45]  [46]  L1:V←name,'.',(⍕P[1]),', ',NOW,' (APL)'         ⍝Computer name and thread, date and time, system[47]   →(V FILECREATE L←A,'lock1')/L3                 ⍝Create 1st lock file.  If we fail,[48]   ⍎(0=⎕NC'slept')/'slept←0'[49]   ⍞←(~M←~slept^W≥30)/'Waiting for lock (',L,')...',⎕TCNL ⋄ FLUSH     ⍝   Don't give this message until we've waited for at least 30 seconds[50]   slept←slept^M                                  ⍝   reset slept flag if we've displayed a message[51]   M←1[52]   →(~(P[2]≠0)^W>P[2])/L2                         ⍝   If we'll have waited longer than timeout,[53]  ⍝ R←R+A TIMEOUT (⊂name),P[1 2]                   ⍝      start timeout procedure to recover from file locking crash[54]   W←0                                            ⍝      and reset total wait time[55]   →L1                                            ⍝      dive back in without waiting[56]  L2:W←W+⎕DL 0 3 UNIFORM 1                        ⍝   Now wait 0 to 3 seconds[57]   →L1[58]  [59]  L3:I←C←0                                        ⍝Else, Reset collision flag[60]  L4:→((⍴X)<I←I+1)/L5                             ⍝For each lock in sequence,[61]   T←⎕DL X[I]                                     ⍝   Wait for pause[62]   →(V FILECREATE L←A,'lock',⍕I+1)/L4             ⍝   Create lock file.  If successful, next[63]   N[I]←N[I]+C←1                                  ⍝   Else, collision[64]   →L1                                            ⍝      back to square one[65]  [66]  L5:→(~P[3])/L6                                  ⍝If bonus lock[67]   T←⎕DL 0 3 UNIFORM 1                            ⍝   Sleep 0 to 3 seconds[68]   →(~V FILECREATE L←A,'lock',⍕2+⍴X)/L7           ⍝   Create bonus lock file.  If successful,[69]  L6:Z←(ROUND W),N,R                              ⍝      return wait time, # of collisions, # of resets[70]  ⍝⎕←'got it.' ⋄ FLUSH[71]   →0                                             ⍝      and we're done[72]  L7:N[1+⍴X]←N[1+⍴X]+C←1                          ⍝   Else, we have a collision[73]   →L1                                            ⍝      Back to square one    ∇