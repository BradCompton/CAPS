    ∇ A LOTICCORELENGTHS S;buffer;exclude;loop;test;noread;grids;ffile;tilesize;tilemapinclude;skiptilemap;E;N;X;C;P;U;P2;Q;B;Y;Z;head;acores;T;R[1]   ⍝Get lengths of aquatic cores[2]   ⍝Parameters:[3]   ⍝   acores              name of aquatic cores grid to use (ecosystem or combo both work)[4]   ⍝   targets = '1:1'     needs to be in parameters.par to run a single thread[5]   ⍝Runs as a CAPS metric, but only uses one thread.  It'll be fastest if you set host = 'w00'.[6]   ⍝B. Compton, 14 Jul 2016 (from ACORESTATS)[7]   [8]   [9]   [10]   READPARS ME[11]   buffer←4⊃A[12]   exclude←''[13]   loop←test←noread←0 ⋄ grids←0 0⍴''              ⍝Silly junk for BLOCK, etc.[14]   ffile←'ACORESTATS '[15]   BLOCK (2⍴tilesize←1000),buffer[16]   SETTILE[17]  [18]   tilemapinclude←0[19]   skiptilemap←0                                  ⍝Don't let DEBUG sabotage this[20]   E←TILEMAP '' tilesize 0 0                      ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[21]   ⎕←'Running LOTICCORELENGTHS on ',(⍕+/E),' tiles' ⋄ FLUSH[22]   Z←0 2⍴0[23]   R←'Running LOTICCORELENGTHS for ',acores,' ',NOW,⎕TCNL[24]  [25]   N←0[26]  L1:→(~E[N←N+1])/L2                              ⍝Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[27]   BREAKCHECK [28]   DOT[29]   X←0 MVREP READ 1⊃1⊃A                           ⍝   Read aquatic cores[30]   C←1=READ 2⊃1⊃A                                 ⍝   Stream centerlines[31]   X←C×X                                          ⍝   only want centerlines[32]   P←FINDPATCH X≠0                                ⍝   find patches[33]   P←P×P∊UNIQUE (,X∊1 2 11 12 13 14)/,P           ⍝   only keep patches that contain lotic cores[34]   [35]   Y←(buffer,block[2],((1↓⍴X)-buffer+block[2]))/(buffer,block[1],((1↑⍴X)-buffer+block[1]))⌿3 3⍴⍳9  ⍝   ids for 9 tiles; 5 is focal tile[36]   Q←(,Y),[1.5],P                                 ⍝   tile, patch[37]   Q←Q[⍋Q;][38]   B←∨/Q≠¯1 0↓0⍪Q[39]   Q←(B⌿Q),B pSUM Q[;2]                           ⍝   tile, patch, count in tile & patch[40]   Q←(Q[;2]≠0)⌿Q                                  ⍝   drop 0 patches in tiles[41]   Q←Q[⍋Q[;2];][42]   B←Q[;2]≠¯1↓0,Q[;2]                             ⍝   unique patches[43]   U←((Q[;1]=5)^Q[;3]=(B pSUM (⍴B)⍴1)/B pMAX Q[;3])/Q[;2]       ⍝   patches with the most cells in tile 5, the center tile[44]   P←P×P∊U                                        ⍝   keep only the winners (includes ties)[45]   U←(U≠0)/U←UNIQUE (,P[1,1↑⍴P;]),,P[;1,1↓⍴P]     ⍝   patches that reach edges--will flag these as too big[46]   :if 0≠⍴U[47]      R←R,⎕←⎕TCNL,'Warning! Patches ',(⍕U),' reach edges in tile ',(⍕block[4]),',',⍕block[5] ⋄ FLUSH[48]   :end[49]   [50]   Q←(,P≠0)/,P[51]   Q←Q[⍋Q][52]   B←Q≠¯1↓0,Q[53]   Q←(B/Q),[1.5]B pSUM (⍴B)⍴1                     ⍝   patch, count[54]   Z←Z⍪Q[55]   [56]  L2:→(0≠NEXTBLOCK)/L1                            ⍝   Until no more tiles[57]   [58]   Z[;2]←Z[;2]×30÷1000                            ⍝Convert size to km[59]   head←1↓⎕TCHT MTOV MATRIFY 'core km'[60]   Z TMATOUT acores,'_corelength.txt'[61]   [62]   R←R,⎕TCNL,⎕←(⍕T),' cores less than 1 km, ',(⍕ROUND 100×(T←+/Z[;2]<1)÷1↑⍴Z),'%'[63]   R←R,⎕TCNL,⎕←(⍕T),' cores less than 2 km, ',(⍕ROUND 100×(T←+/Z[;2]<2)÷1↑⍴Z),'%'[64]   R←R,⎕TCNL,⎕←(⍕T),' cores less than 5 km, ',(⍕ROUND 100×(T←+/Z[;2]<5)÷1↑⍴Z),'%'[65]   R←R,⎕TCNL,⎕←(⍕T),' cores less than 10 km, ',(⍕ROUND 100×(T←+/Z[;2]<10)÷1↑⍴Z),'%'[66]  [67]   R NWRITE acores,'_corelength_log.txt'[68]   [69]   [70]   ⎕←''[71]   LOG 'LOTICCORELENGTHS is done.' ⋄ FLUSH[72]   →0[73]  [74]  [75]  what:auxiliary[76]  type:table[77]  info:(acores 'streams') ('') ('') 1000 ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[78]  check:CHECKVAR 'acores targets'    ∇