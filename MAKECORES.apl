    ∇ A MAKECORES S;bandwidth;B;buffer;I;X;W;C;Q;V;R;K;F;G;T;Z;D;U;Y;KK8;head;L;systems;slice;expand;toosmall;multiplier;density;which;M;transparent;dot;barriers;culverts;E;wresistrange;H;O;fd;N;wetmultiplier;accumrange;P;expanddown;R2;O2;S2;expandmult;J;P2;sg;buf;S3;W2;H2;E2;X2;sg2;lentic;dams;Y2;expandup;logistic;updownsize;lakeresist;O3[1]   ⍝Build buffered reserve cores for LCD using resistant kernel[2]   ⍝Input grids:[3]   ⍝   value           value grid (IEI or selection index)[4]   ⍝   land            landcover grid[5]   ⍝   cores           result grid[6]   ⍝the following are only used if which = 'aquatic':[7]   ⍝   flow            flow grid[8]   ⍝   wresist         time of flow aquaitc resistance[9]   ⍝   fd8accum        flow accumulation[10]  ⍝Parameters:[11]  ⍝   which           type of cores: 'terrestrial' or 'aquatic'[12]  ⍝   systems         text file listing names of systems to include (usually terrestrial.txt or aquatic.txt)[13]  ⍝   slice           include values > slice[1] in patches; slice[2] is used for lakes[14]  ⍝   expand          number of cells to expand to eliminate small gaps (usually 1)[15]  ⍝   toosmall        [1] drop tiny patches with this many cells or fewer; [2] for aquatic cores, drop streams with fewer than this many cells[16]  ⍝   multiplier      multiplier on value for costs[17]  ⍝   expanddown      how far (m) to expand stream cores downstream at (min, max) watershed size?[18]  ⍝   expandup        how far (m) to expand stream cores upstream at (min, max) watershed size?  Use 0 to not expand upstream.[19]  ⍝   expandmult      multiplier for resistant expansion (set to 0 to do non-resistant expansion)[20]  ⍝   accumrange      range of ln(d8flowaccum) across the region (use 5.8 20)[21]  ⍝   updownsize      if true, stop upstream/downstream expansion when stream size jumps a lot[22]  ⍝   wetmultiplier   multiplier for aquatic cores at (min, max) watershed size[23]  ⍝   bandwidth       default bandwidth (h, or s.d. of kernel), in meters[24]  ⍝   density         build kernels for every nth cell to speed things up[25]  ⍝   logistic        inflection & scaling factor to use for resistance (use 0 for no logistic function)[26]  ⍝   barriers        optional list of cover types to treat as absolute barriers, used to keep reserves from spanning highways[27]  ⍝   culverts        optional list of cover types representing culverts or dams, treated as barriers if adjacent to one of 'barriers'[28]  ⍝   lakeresist      additional resistance (in cells) to use for lentic when doing aquatic expansion (use 1E6 to treat lakes as barriers)[29]  ⍝   wresistrange    range of wresist grid, used to scale resistance for aquatic cores[30]  ⍝   buffer          number of cells to buffer tiles - should be radius of largest core + bandwidth÷cellsize[31]  ⍝Results:[32]  ⍝   cores           reserve kernels[33]  ⍝   coresS          seed cores (aquatic only at the moment). 2 = core, 1 = expansion, 3 = lakes.[34]  ⍝   coresW          river-width seed cores[35]  ⍝B. Compton, 18-25 Jun 2014, from BUFFERCORES[36]  ⍝11 Jul 2014: expand stream cores downstream based on watershed area, and base multiplier on watershed area[37]  ⍝14 Jul 2014: don't expand into larger rivers; write seeds to help with evaluation[38]  ⍝22-23 Jul 2014: use resistance when expanding[39]  ⍝29 Jul 2014: don't expand aquatic cores downstream through dams[40]  ⍝8 Aug 2014: expand cores upstream as well as down[41]  ⍝21 Aug 2014: aquatic seeds in centerlines only, and clip enough so we don't cut off blobs because of extension[42]  ⍝22 Aug 2014: bug - lost patches completely surrounded by development[43]  ⍝25 Aug 2014: clip after extensions are done[44]  ⍝26-28 Aug 2014: don't restrict to centerlines for lakes; use toosmall[2] to screen combined aquatic seeds; write river-width seeds[45]  ⍝29 Aug 2014: only expand up into centerlines; was building random-sized blob![46]  ⍝9 Sep 2014: OMG: don't call bloody LOOK inside of loops!  It reads synonyms.par![47]  ⍝15-16 Sep 2014: add slice[2] for lentic[48]  ⍝17 Sep 2014: use land, not value grid for MVs, thanks to change in selection index[49]  ⍝29 Sep 2014: split expandup/expanddown, and add biggerok[50]  ⍝8 Oct 2014: add logistic resistance scaling for terrestrial cores[51]  ⍝9 Oct 2014: change biggerok to updownsize, going both directions[52]  ⍝15 Oct 2014: also use logistic resistance for aquatic cores (both for extensions and blobs)[53]  ⍝16 Oct 2014: add lakeresist[54]  ⍝21 Oct 2014: treat non-seed lentic extensions as lotic when dropping for toosmall[2][55]  ⍝23 Oct 2014: expand up from expansion too to get upstream from downstream expansion[56]  [57]  [58]  [59]  ⍝OBSOLETE. SPLIT INTO TCORES AND ACORES.[60]  [61]  [62]   READPARS ME[63]   lentic←LOOK 'lentic'[64]   dams←LOOK 'dam'[65]   X←READ 1⊃1⊃A                                   ⍝Read value grid[66]   W←READ 2⊃1⊃A                                   ⍝And landcover[67]   Q←W∊LOOKNAMES barriers                         ⍝Set highways to missing so they'll get super-high resistance[68]   X←MVREP X (Q∨(W∊LOOKNAMES culverts)^FOCALMAX Q)⍝Set culverts and dams to missing if adjacent to highways[69]   Q←0 ⎕TCHT MATIN pathI PATH systems,(~'.'∊systems)/'.txt'[70]   Y←X×W∊(LOOKUP 0,Q)[;1]                         ⍝Set everything outside of selected systems in landcover to 0[71]   Y2←Y≥(slice←2↑,slice,0)[1]                     ⍝Take values ≥ slice[1][72]  [73]   :if which≡'aquatic'                            ⍝If aquatic cores,[74]      Y2←Y2×W≠lentic                              ⍝   drop our lentic slices[75]      Y2←Y2∨(W=lentic)^Y≥slice[2]                 ⍝   and use slice[2] for lentic[76]   :end[77]  [78]   Y←((Y2≠0)^W≠MV)×expand BUFFER Y2               ⍝Buffer to merge fragments, but not across value = 0 or landcover = missing[79]   Y←FINDPATCH Y                                  ⍝Build patches (8-neighbor)[80]  [81]   Q←(Q≠0)/Q←,Y[82]   Q←Q[⍋Q][83]   B←Q≠0,¯1↓Q[84]   Q←(B/Q),[1.5]B pSUM (⍴B)⍴1                     ⍝Patch #, number of cells[85]   Y←Y×Y∊U←(Q[;2]>(toosmall←2⍴toosmall)[1])/Q[;1] ⍝Drop tiny patches[86]   Y←MVREP Y ((W=MV)∨X=MV)                        ⍝Carry over missing cells in landcover or value[87]  [88]   buf←1+⌈bandwidth÷cellsize                      ⍝Buffer; take 1 extra cell to deal with rounding[89]   D←(⍳1+2×buf)-buf+1                             ⍝Maximum radius possible to travel[90]   KK8←8 2⍴¯1 0 1 0 0 ¯1 0 1 ¯1 ¯1 1 1 ¯1 1 1 ¯1  ⍝8-neighbor rule for FOCALMIN[91]   Z←(⍴X)⍴0[92]  [93]   I←0[94]   :if which≡'terrestrial'                        ⍝If terrestrial cores,[95]   dot←⍴⍞←'Building kernels for ',(⍕⍴U),' cores',MB ⋄ FLUSH[96]   R←RESIST 1-X                                   ⍝   We'll rescale IEI/selection index into resistance[97]   R←1E6 MVREP R (Y=MV)                           ⍝   missing cells get resistance of a million[98]  L1:→((⍴U)<I←I+1)/L5                             ⍝   For each core,[99]   BREAKCHECK[100]  DOT[101]  L M ← buf CLIP Y=U[I]                          ⍝      Clip to this core plus buffer[102]  C←C×(C≠0)^0=FOCALMIN C←0 MVREP Y[L;M]          ⍝      Edges of core[103]  V←(⍴C)⍴0[104]  S←20<+/,C=U[I]                                 ⍝      If core is small with few edge cells, don't skip any cells[105] [106]  J←1[107] L2:→(((1↑⍴C))<J←J+1)/L4                         ⍝      For each row,[108]  →(S^(J÷density)≠⌊J÷density)/L2                 ⍝         skip this row?[109]  K←1[110] L3:→(((1↓⍴C))<K←K+1)/L2                         ⍝         For each column,[111]  →(S^(K÷density)≠⌊K÷density)/L3                 ⍝         skip this column?[112]  →((C[J;K]≠U[I]))/L3                            ⍝            If in edge of this core,[113]  F←((F>0)^F≤1↑⍴C)/F←J+D ⋄ G←((G>0)^G≤1↓⍴C)/G←K+D[114]  T←SPREAD buf (F⍳J) (G⍳K) (R[L;M][F;G])         ⍝            Build kernel[115]  V[F;G]←V[F;G]⌈T÷buf                            ⍝            Take max with core's result[116]  →L3[117] [118] L4:Z[L;M]←Z[L;M]⌈V                              ⍝      Take max of this core and running results[119]  →L1[120] [121]  :else                                          ⍝Else, aquatic cores,[122] [123]  E←READ 3⊃1⊃A                                   ⍝   Read flow grid[124]  R←READ 4⊃1⊃A                                   ⍝   and time of flow resistance[125]  H←READ 5⊃1⊃A                                   ⍝   and flow accumulation[126]  sg←1=READ 6⊃1⊃A                                ⍝   and stream centerlines[127]  S2←(⍴X)⍴0                                      ⍝   for writing seeds[128]  fd←(2*¯1+⍳8),8 2⍴0 1 1 1 1 0 1 ¯1 0 ¯1 ¯1 ¯1 ¯1 0 ¯1 1[129]  N←FINDPATCH W=lentic                           ⍝   Identify all lakes[130]  Y←FINDPATCH Y⌈N∊T←(T≠0)/T←,N×Y≥1               ⍝   Light up entire lakes that our cores fall into & rebuild cores[131]  Y←Y×sg∨N≠0                                     ⍝   only want centerlines for rivers; all cells for lakes[132]  U←((U⍳U)=⍳⍴U)/U←(,Y≠0)/,Y                      ⍝   rebuild unique core list[133]  ⍞←'Building seeds for ',(⍕⍴U),' cores',MB ⋄ FLUSH[134] [135] ⍝----- 1st pass: build cores -----[136] L6:→((⍴U)<I←I+1)/L51                            ⍝   For each core,[137]  BREAKCHECK[138]  DOT[139]  L M ← (⌈(⌈/expanddown,expandup)÷cellsize) CLIP S←Y=U[I]   ⍝      Clip to cells in this core plus max expansion buffer[140]  S←S[L;M][141]  O2←(INDICES O←O=⌈/,O←H[L;M]×S)[1;]             ⍝      Identify bottommost cell--we'll always keep this in; O2 is indices[142]  F←⍟H[L;M][O2[1];O2[2]]                         ⍝      ln(flow accumulation at botttommost cell of core before expansion)[143]  S2[L;M]←S2[L;M]⌈S×2                            ⍝      seed cells (2 for original seed)[144]  W2←W[L;M] ⋄ H2←H[L;M] ⋄ E2←E[L;M] ⋄ X2←X[L;M]  ⍝      make clips of landcover, flowaccum, flow direction, and values[145] [146] ⍝Expand seeds to build full core[147]  :if (W2[O2[1];O2[2]])≠lentic                   ⍝      if bottommost cell is not lentic,[148]     ⍝First, expand downstream[149]     P←P2←⌈(÷cellsize)×expanddown[1]+(-/expanddown[2 1])×(F-accumrange[1])÷-/accumrange[2 1] ⍝      distance to expand core downstream is a function of watershed area[150]     T←Q←O2[151] L10:P←P-(1+expandmult≠0)⊃1 (expandmult RESIST 1-X2[T[1];T[2]])    ⍝      Repeat: subtract 1 or resistance, depending on expandmult[152]     →(P<0)/L11                                  ⍝         If we haven't gone too far yet,[153]     T←,E2 NEXTFLOW Q[154]     →(∨/T=0)/L11                                ⍝            bail out if we hit the edge[155]     →(0>P←P-lakeresist×W2[T[1];T[2]]=lentic)/L11⍝            subtract additional resistance for lakes[156]     →(W2[T[1];T[2]]=dams)/L11                   ⍝            or a dam[157]     →(updownsize[2]^(⍟H2[T[1];T[2]])>1+⍟H2[O2[1];O2[2]])/L11  ⍝            or if we hit a bigger river (if updownsize)[158]     S[Q[1];(Q←T)[2]]←1                          ⍝            include this cell in core[159]     →L10[160] L11:[161]     :if 0≠+/expandup                            ⍝      if expanding upstream too,[162]        P←P2←⌈(÷cellsize)×expandup[1]+(-/expandup[2 1])×(F-accumrange[1])÷-/accumrange[2 1] ⍝      distance to expand core upstream is a function of watershed area[163]        sg2←sg[L;M][164]        S ← S EXPANDUP P2 O2                     ⍝         Now expand upstream (EXPANDUP treats several locals here as global) from bottom-most cell of slice[165]        O3←(INDICES T=⌈/,T←H[L;M]×S)[1;]         ⍝         Bottommost cell of expansion[166]        S ← S EXPANDUP P2 O3                     ⍝         And again from bottom-most cell of expansion[167]     :end[168]     O←(⍴O)⍴0[169]     O[O2[1];(O2←Q)[2]]←1                        ⍝         Re-find bottommost cell (depends on downstream, but not upstream, expansion)[170]  :end[171] [172]  S2[L;M]←S2[L;M]⌈S                              ⍝      seed cells (2 = core, 1 = expansion)[173]  →L6[174] [175] ⍝----- 2nd pass: build kernels for cores we're keeping -----[176] L51:Y←FINDPATCH sg^S2≠0                         ⍝   Build patches on centerlines for each lotic core (can include lentic extensions)[177]  Q←(Q≠0)/Q←,Y[178]  Q←Q[⍋Q][179]  B←Q≠0,¯1↓Q[180]  Q←(B/Q),[1.5]B pSUM (⍴B)⍴1                     ⍝   Patch #, number of cells[181]  Y←Y×Y∊(Q[;2]>toosmall[2])/Q[;1]                ⍝   Drop tiny patches of lotic (plus lentic when in extensions) smaller than toosmall[2][182]  Y←Y⌈T×(⌈/,Y)+FINDPATCH T←(N≠0)^S2=2            ⍝   and bring in patches for seed lakes[183]  U←((U⍳U)=⍳⍴U)/U←(U≠0)/U←,Y                     ⍝   Unique patches[184]  S2←(S2×Y≠0)⌈3×(N≠0)^S2=2                       ⍝   kept seeds (1 = extension, 2 = seed lotic, 3 = seed lentic)[185] [186]  ⍞←⎕TCNL,'Building kernels for ',(⍕⍴U),' cores',MB ⋄ FLUSH[187] [188]  I←0[189] L52:→((⍴U)<I←I+1)/L5                            ⍝   For each core,[190]  BREAKCHECK[191]  DOT[192]  S←Y=U[I]                                       ⍝      Select cells in core[193]  L M ← buf CLIP S                               ⍝      Clip to this core plus buffer[194]  S←S[L;M][195]  O2←(INDICES O←O=⌈/,O←H[L;M]×S)[1;]             ⍝      Identify bottommost cell--we'll always keep this in; O2 is indices[196] [197]  C←O∨S^0≠E[L;M] UPFLOW ~S                       ⍝      find "edges"--cells in core that stuff flows into from outside[198]  C←INDICES C                                    ⍝      make list of indices[199]  V←(⍴S)⍴0[200]  :if (W[L;M][O2[1];O2[2]])=lentic               ⍝      if it's a lake,[201]     P←multiplier                                ⍝         use standard multiplier[202]  :else                                          ⍝      else, for rivers,[203]     F←⍟H[L;M][O2[1];O2[2]]                      ⍝         ln(flow accumulation at botttommost cell of core before expansion)[204]     P←wetmultiplier[1]+(-/wetmultiplier[2 1])×(F-accumrange[1])÷-/accumrange[2 1]    ⍝      multiplier is a function of watershed area[205]  :end[206]  R2←P RESIST (R-wresistrange[1])÷wresistrange[2]⍝   rescale time of flow into resistance[207] [208]  J←0[209]  dot←⍴⍞←⎕TCNL,(⍕I),' of ',(⍕⍴U),' cores, ',(⍕1↑⍴C),' cells',MB ⋄ FLUSH[210] L7:→((1↑⍴C)<J←J+1)/L8                           ⍝      For each "edge" cell,[211]  DOT[212]  V←V⌈(÷buf)×WETSPREAD buf (C[J;1]) (C[J;2]) (R2[L;M]) (E[L;M])   ⍝         Build kernel[213]  →L7[214] [215] L8:Z[L;M]←Z[L;M]⌈S⌈E[L;M] CORE_WATERSHED V S    ⍝      mask kernel so we only build upstream of core[216]  →L52[217]  :end[218] [219] L5:transparent←3                                ⍝Use max transparency mode[220]  (MVREP Z ((W=MV)∨Z=0)) WRITE 3⊃A               ⍝Save transparently, with all 0's set to missing[221]  ⎕←''[222]  :if which≡'aquatic'                            ⍝If aquatic cores,[223]     (MVREP S2 (S2=0)) WRITE (3⊃A),'s'           ⍝   Write seeds[224]     S3←MIXRIVER S2                              ⍝   fill in off-cenerline cells for seeds[225]     S3←S3-(S2=0)^S3=2                           ⍝   all filled-out river cells count as expansion[226]     (MVREP S3 (S3=0)) WRITE (3⊃A),'w'           ⍝   Write full-river seeds[227]  :end[228]  →0[229] [230] [231] [232] what:auxiliary[233] type:standard[234] info:('value' 'land' '*flow' ('*',pathS,'wresist') 'fd8accum' 'streams') ('') ('cores') (buffer⌈⌈bandwidth÷cellsize)       ⍝Source grid, settings table, result grid, and buffer size[235] check:CHECKVAR 'which systems slice expand toosmall updownsize multiplier bandwidth density barriers culverts buffer wetmultiplier accumrange expanddown expandmult expandup logistic lakeresist'    ∇