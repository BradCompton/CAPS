    ∇ A BUFFERCORES S;M;bandwidth;contours;B;buffer;N;I;X;W;C;E;Q;V;R;J;K;F;G;T;Z;D;H;U;Y;KK8;multiplier;coretable;head;resist;search;L;O[1]   ⍝Buffer BioMap 2 cores using resistant kernel[2]   ⍝⍺ = (landcover grid, core grid, IEI grid) (settings) (result grid) (buffer)[3]   ⍝Parameters:[4]   ⍝   coretable   table of cores from makecores.aml[5]   ⍝   multiplier  multiplier on contrast to get resistance[6]   ⍝   bandwidth   bandwidth (h) in m[7]   ⍝   search      search distance in s.d.[8]   ⍝   resist      resistance value by cover type[9]   ⍝   skip        only build kernels for every nth cell to speed things up[10]  ⍝   cellsize    cell size (m)[11]  ⍝Create core grid with buildcoretable.aml[12]  ⍝Writes finish.aml to finish off results (requires smooth.aml and kill.aml)[13]  ⍝B. Compton, 4-8 Feb 2010[14]  ⍝22 Mar 2010: inside of cores excluded from percentiles, gets 1 (health care finally passed last night!)[15]  ⍝24 Mar 2010: don't skip if poly is small; alignment problems; lap properly[16]  ⍝1 Apr 2010: get the quantiles right![17]  ⍝4 Oct 2010: left behind by landcover revolution; would need to update to use INCLUDE, etc.[18]  [19]  [20]  [21]   READPARS ME[22]  [23]   M←0 1 TABLE coretable                              ⍝Read core table[24]   N←TOLOWER MATRIFY head[25]   V←LOOKUP resist                                    ⍝Get resistance values set by cover type, not IEI[26]  [27]   I←0[28]  L1:→((1↑⍴M)<I←I+1)/L5                               ⍝For each core,[29]   BREAKCHECK[30]   ⎕←'   Core #',⍕M[I;1] ⋄ FLUSH[31]   W←M[I;N MATIOTA MATRIFY 'xmin ymin xmax ymax'][32]   W[3 2 1 4]←(FINDCELL W[1 2]),FINDCELL W[3 4]       ⍝   Convert MER to cells and rearrange into upper left R,C, lower right[33]   W[3 4]←1+W[3 4]-W[1 2]                             ⍝   Upper left, number of cells[34]  [35]   H←''⍴((H=0)/bandwidth),H←M[I;N MATIOTA 'bandwidth']⍝   Bandwidth for this core[36]   B←1+⌈H×search÷cellsize                             ⍝   buffer for this core; take 1 extra cell to deal with rounding[37]  [38]   X←READBLOCK (⊂pathG PATH FRDBL 1⊃1⊃A),W,B          ⍝   Read landcover,[39]   C←0 MVREP READBLOCK (⊂pathG PATH FRDBL 2⊃1⊃A),W,B  ⍝   cores,[40]   E←0 MVREP READBLOCK (⊂pathG PATH FRDBL 3⊃1⊃A),W,B  ⍝   and IEI[41]   E←MVREP E (X=MV)                                   ⍝   if landcover is nodata, make sure IEI is too[42]   X←MVREP X (E=MV)                                   ⍝   and vice-versa[43]   KK8←8 2⍴¯1 0 1 0 0 ¯1 0 1 ¯1 ¯1 1 1 ¯1 1 1 ¯1      ⍝   8-neighbor rule for FOCALMIN[44]   C←C×~(0=FOCALMIN C)^E=0                            ⍝   Push core edges off of roads so cores don't run over them from slight misalignment[45]   C←C×~(0=FOCALMIN C)^E=0[46]   Y←C×(C≠0)^0=FOCALMIN C                             ⍝   Edges of cores[47]  [48]   Z←(⍴X)⍴0[49]   U←1+multiplier×1-E                                 ⍝   rescale IEI into resistance[50]   R←(V⍪1)[V[;1]⍳X;2]                                 ⍝   Cover type-based resistance[51]   R←1E6 MVREP R (X=MV)                               ⍝   Missing cells get resistance of a million[52]   R←(R×R≠1)+U×R=1                                    ⍝   If cover type resistances are supplied, these take precedence[53]   D←(⍳1+2×B)-B+1                                     ⍝   Maximum radius possible to travel[54]   L←(+/,E=M[I;1])≥50                                 ⍝   If poly is small, don't skip any cells[55]  [56]   J←B[57]  L2:→(((1↑⍴X)-B)<J←J+1)/L4                           ⍝   For each row,[58]   →(L^(J÷skip)≠⌊J÷skip)/L2                           ⍝      skip this row?[59]   BREAKCHECK[60]   K←B[61]  L3:→(((1↓⍴X)-B)<K←K+1)/L2                           ⍝      For each column,[62]   →(L^(K÷skip)≠⌊K÷skip)/L3                           ⍝      skip this column?[63]   →((Y[J;K]≠M[I;1]))/L3                              ⍝         If in edge of this core,[64]   F←J+D ⋄ G←K+D[65]   T←SPREAD B (F⍳J) (G⍳K) (R[F;G])                    ⍝         Build kernel[66]   Z[F;G]←Z[F;G]⌈T                                    ⍝         Take max with result[67]  ⍝ Z[F;G]←Z[F;G]⌈(X[F;G]≠MV)×(T≠0)×ZDENSITY search-T÷H⍝         Rescale & take max with result - SCALING IS UNNECESSARY AND VERY SLOW[68]   →L3[69]  [70]  L4:Z←MVREP Z (X=MV)                                 ⍝   cells off of edge of landcover ← nodata[71]   Z←Z×C≠M[I;1]                                       ⍝   inside of core gets zero--we don't want to count it in percentiles[72]   →(^/,Z∊MV,0)/L1                                    ⍝   if we actually got a kernel out of it,[73]   O←MV×Z∊0,MV[74]   Q←(~Q∊0,MV)/Q←,Z[75]   contours←contours[⍋contours][76]   Z←(0,⌽contours)[1++/(-Z)∘.≤(contours÷100) QTILE -Q]⍝      by percentiles[77]   Z←MVREP (MVREP Z (Z=0)) (O=MV)                     ⍝      all 0's and MVs get MV[78]   Z←(Z×C≠M[I;1])+C=M[I;1]                            ⍝      inside of cores get 1[79]   →(~IFEXISTS pathR,(3⊃A),'\')/L6                    ⍝      If already have some results,[80]   Q←READBLOCK (⊂3⊃A),(W[1 2]-B),W[3 4]+2×B[81]   →(^/,Q=MV)/L6[82]   Z←MVREP ((1E6 MVREP Q)⌊1E6 MVREP Z) ((Q=MV)^Z=MV)  ⍝      merge them nicely[83]  L6:Z WRITEBLOCK (3⊃A),((W[1 2]-B),W[3 4]+2×B),0,1[84]   →L1[85]  [86]  L5:X←('/* finshcores.aml - automatically generated by BUFFERCORES ',NOW) OVER ''[87]   X←X OVER 'grid'[88]   Q←(3⊃A),¨C←⍕¨contours[89]   X←X OVER '&r kill ',⊃,/(Q,Q,¨'a'),¨' '             ⍝Get rid of previous results[90]   X←X OVER MIX Q,¨'a',¨(⊂' = gridpoly(setnull(',pathR,(3⊃A),' > '),¨C,¨⊂', 1))'[91]   X←X OVER 'q'[92]   X←X OVER MIX (⊂'&r smooth '),¨Q,¨(⊂'a '),¨Q[93]   X←X OVER '&r kill ',⊃,/(Q,¨'a'),¨' '               ⍝and intermediate results[94]   (1↓MTOV X) NWRITE pathR PATH 'finish.aml'          ⍝Write out finish.aml[95]   ⎕←'Contour grids written to ',pathR,'.  Finish off by in Arc with:'[96]   ⎕←'   &r finish'[97]   →0[98]  [99]  what:other (BioMap 2)[100] type:standard[101] info:('land' 'coregrid' 'iei') ('') ('morecores') (⌈bandwidth×search÷cellsize)       ⍝Source grid, settings table, result grid, and buffer size[102] check:CHECKVAR 'bandwidth multiplier search contours skip'[103] check:CHECKCOVER 'resist'    ∇