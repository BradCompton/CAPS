    ∇ MAKEWATERSHEDS;L;luwet;F;flow;KK8;Q;fd;A;d8accumni;C;T;pythonpath;buffer;P;subwater;tiny;R;B;S;I;Z;head;N;mask;J;block;W;U;excl;luwet2;flow2;result;M;tr;dslland;JJ;F1[1]   ⍝Replacement for makebigwatersheds.aml, which can't run for whole LCC landscape[2]   ⍝Parameters:[3]   ⍝   luwet = 'luwet'         Land use/wetlands[4]   ⍝   dslland = 'dslland'     Final land cover (for TR)[5]   ⍝   flow = 'flow'           D8 flow grid[6]   ⍝   d8accumni = 'd8accumni' D8 flow accumulation without inflows or precip (data size)[7]   ⍝   subwater = 600 2000     Subwatershed thresholds (km^2). Thresholds are:[8]   ⍝       1. small            Minimum local area of a subwatershed[9]   ⍝       2. big              Threshold area to force a subwatershed (big must be > small×2)[10]  ⍝       3. more             An optional list of more thresholds to split mainstems[11]  ⍝   tiny = 100              Tiny watershed threshold (km^2)[12]  ⍝   result = ''             Name of result text file, default = 'bigwatersheds.txt' (change this when running for TR watersheds)[13]  ⍝   tr = no                 Set to 1 when running for tidal restrictions[14]  ⍝Sources:[15]  ⍝   luwet                   Land use/wetlands[16]  ⍝   flow                    Flow grid[17]  ⍝   d8accumni               d8 flow accumulation grid, no inflows--only flow accumulation within masked area[18]  ⍝   mask                    Required!  (For TR, this should be a mask of only areas where DEM < 5 m or so[19]  ⍝Results:[20]  ⍝   pathT\bigwatersheds.txt     watershed what x-coord y-coord xmin ymin xmax ymax[21]  ⍝   tinyTR                  grid if tiny outflows, from TR runs only[22]  ⍝**** Note: grid names must be base grid names, not mosaic names, as Python can't work with mosaics, and[23]  ⍝     grid names are passed to it.  Make sure you don't use _m names in inputs.par!  Supply grid names without[24]  ⍝     paths as parameters; paths must be in inputs.par.[25]  ⍝**** Note: to run for tidal restriction watersheds, set subwater = 1E9 1E10, result = 'trbigwatersheds.txt', [26]  ⍝     and set mask (in inputs.par) to coastclip.[27]  ⍝**** Also, not doing anything for buildwatershedtable4csb.aml?[28]  ⍝**** NOTE: Thanks to Horrible ESRI, this must be run on the same machine as pathW[29]  ⍝[30]  ⍝**** WHEN RUNNING FOR TIDAL RESTRICTIONS,[31]  ⍝     Set tr = yes[32]  ⍝         subwater = 1E12 1E13[33]  ⍝         result = 'TRbigwatersheds.txt'[34]  ⍝         [inputs.par] mask   trmask[35]  ⍝[36]  ⍝Goes to some effort to delete spurious outflows, created when flowlines cross land/wetlands below subtidal[37]  ⍝[38]  ⍝→→→→ You MUST clear the contents of pathW before running! ←←←←←[39]  ⍝[40]  ⍝B. Compton, 14 Feb-8 Mar 2014[41]  ⍝2-4 Sep 2014: read parameters up front so it's okay to change parameter files for other work during a run[42]  ⍝30 Sep 2015: fix ugly little bug: was using original flow, not masked flow, which hung up on loops in ocean[43]  ⍝5 Jan 2016: allow setting result file name so I can run a version for TR.[44]  ⍝6 Jan 2016: and make mask work properly! Create temporary masked flow grid and stitch it.[45]  ⍝19 Jan 2016: update comments to properly reflect run for TR[46]  ⍝22 Jan 2016: changes to work properly for TR - what a fucking data disaster the subtidal classes are.[47]  ⍝25 Jan 2016: the struggle continues...[48]  ⍝6 May 2016: I've got a great idea: be consistent with the TR mask!  Use UGLYMASK.[49]  ⍝2-9 Aug 2016: TR flailing[50]  ⍝   Did I break this for non-tr use? I hope not!  (It worked for regular watersheds as of 19 Apr 2016)[51]  ⍝11-12 Aug 2016: finally get it right for TR? I think this will work for regular watersheds.[52]  ⍝15 Aug 2016: stretch MERs to make sure outflows are included!  And write grid of tiny TR watersheds.[53]  ⍝23 Aug 2016: drop upper, not lower spurious outflows when they fall on the same flowline[54]  [55]  [56]  [57]   INIT[58]   READPARS ME[59]   luwet2←GRIDNAMENS pathG PATH luwet[60]   luwet←GRIDNAME pathG PATH luwet[61]   flow2←GRIDNAMENS pathS PATH flow[62]   flow←GRIDNAME pathS PATH flow[63]   ⎕←'---> Mask = ',mask,' <---'[64]   mask←GRIDNAME pathG PATH mask[65]   d8accumni←GRIDNAME pathS PATH d8accumni[66]   excl←(LOOKUP 1,[1.5]FRDBL¨↓',' MATRIFY exclude)[;1][67]   result←(1+0∊⍴result) ⊃ result 'bigwatersheds.txt'[68]   result←result,(0∊⍴STRIPEXT result)/'.txt'[69]   ⎕←'--- Okay to change parameter files now ---' ⋄ FLUSH[70]  [71]   N←((.5×⍴N),2)⍴N←FRDBL¨↓MATRIFY 'l00 x: w00 z: w01 y:'[72]   N←⊃(N⍪⊂'')[N[;1]⍳⊂TOLOWER GETNAME;2],''[73]   ⎕ERROR (~N≡2↑pathW)/'This program must be run on the same machines as pathW (=',pathW,')'[74]  [75]   BLOCK 2000 2000,buffer←100                     ⍝Buffer of 100 to help with spurious outflows[76]   C←(block[1 2]+2×buffer)⍴1                      ⍝Make core mask[77]   C[(⍳buffer),(1+1↑⍴C)-⍳buffer;]←0 ⋄ C[;(⍳buffer),(1+1↓⍴C)-⍳buffer]←0[78]  [79]   SETTILE[80]   KK8←8 2⍴¯1 0 1 0 0 ¯1 0 1 ¯1 ¯1 1 1 ¯1 1 1 ¯1[81]   fd←(2*¯1+⍳8),8 2⍴0 1 1 1 1 0 1 ¯1 0 ¯1 ¯1 ¯1 ¯1 0 ¯1 1 [82]   subwater tiny ← subwater tiny×1E6÷cellsize*2   ⍝Convert from km^2 to cells[83]  [84]   ⎕←'Step 1. Finding outflows...' ⋄ FLUSH[85]   Z←0 4⍴0[86]  L1:⎕←'Tile ',(⍕block[4]),',',(⍕block[5]),' of ',(⍕block[6]),',',(⍕block[7]),'...' ⋄ FLUSH[87]   :if tr                                         ⍝WHILE there are tiles, if doing tidal restrictions,[88]      →(^/,M←(READ mask)∊0,MV)/L2                 ⍝   done if nothing in mask in this tile--it's not coastal[89]      L←READ dslland                              ⍝   For TR, use DSLland, because we need subtidal sheltered[90]      →(^/,L=MV)/L2[91]      M←(~M)∨~L∊excl                              ⍝   Mask at this point is TR mask + everything but subtidal, so we can find outflow points[92]      M←EXPAND EXPAND EXPAND (L≠MV)^M             ⍝   expand mask[93]      L←MVREP L (~M)                              ⍝   Exclude anything that's masked out - this removes border rivers[94]   :else[95]      L←READ luwet                                ⍝   Use luwet for regular run[96]     →(^/,L=MV)/L2[97]     L←MVREP L (~EXPAND EXPAND EXPAND (L≠MV)^~(L∊excl)^(READ mask)∊0,MV)      ⍝   Exclude anything that's masked out - this removes border rivers [98]   :end [99]   →(^/,L=MV)/L2[100] [101]  F1←F←READ flow[102]  A←READ d8accumni                               ⍝   Read data-sized flowaccum[103]  F←MVREP F (L∊MV)                               ⍝   Flow grid gets same missing as land + mask[104] [105]  Q←F DOWNFLOW F=MV                              ⍝   Outflows are where streams flow into nodata cells[106]  :if tr                                         ⍝   If doing TR,[107]     T←(Q≠0)^(tiny⌈1)>Q×A                        ⍝      outflows are also where flow dries up    [108]     T WRITEI pathG PATH 'tinyTR'                ⍝      write grid of tiny TR watersheds [109]  :end[110]  Q←(~L∊MV)^Q∨T^~F DOWNFLOW T←A≥tiny             ⍝   but they're also where flow accumulation dries up (thanks to misalginment errors in building data)[111]  Q←Q^(⍴Q)↑C                                     ⍝   Don't want any in buffer[112] [113] ⍝Now find subwatersheds[114]  R←(~B←A>subwater[2])^A≥subwater[1]             ⍝   Right size is between thresholds[115]  S←R^F DOWNFLOW B                               ⍝   subwatersheds are right size & flow into big[116] [117]  :for L :in 2↓subwater                          ⍝   For each 'more' threshold,[118]     S←(T←S)∨B^(F≠MV)^0=F UPFLOW B←A≥L           ⍝      subwatersheds are cells above threshold with such cells flowing in[119]     ⍞←(T≠0)/'   ',(⍕T←(+/,S)-+/,T),' mainstems split at threshold ',(⍕ROUND L÷1E6÷cellsize*2),⎕TCNL ⋄ FLUSH[120]  :end[121]  S←S^(⍴S)↑C                                     ⍝   Don't want any subwatersheds in buffer either[122] [123]  Q←S∨(tiny⌈1)≤Q×A                               ⍝   Throw away all tiny watersheds, keeping big ones, plus all subwatersheds[124]  →(^/,Q=0)/L2                                   ⍝   If any watersheds/subwatersheds,[125] [126]  P←((,Q)/,⍉(⌽⍴Q)⍴⍳1↑⍴Q),[1.5](,Q)/,(⍴Q)⍴⍳1↓⍴Q   ⍝      Convert outflows to points[127]  ⎕←'   ',(⍕1↑⍴P),' outflows found' ⋄ FLUSH[128]  Q←(1+(,Q)/,S),P,(,Q)/,A                        ⍝      table: full=1 or sub=2, x, y, local flow accumulation[129] [130]  I←¯1+(Q←Q[⍒Q[;1];])[;1]⍳1                      ⍝      Sort subwatersheds to the top, and find first full watershed[131]  B←(1↑⍴Q)⍴1[132] L3:→((1↑⍴Q)<I←I+1)/L4                           ⍝      For each full watershed,[133]  JJ←1 2⍴J←Q[I;2 3][134] L5:J←F1 NEXTFLOW J                              ⍝         flow down from outflow, using original flow grid without nodata blanked out[135]  →(0∊J)/L3                                      ⍝         until we reach the edge[136]  :if ∨/,JJ^.=2 1⍴J                              ⍝         Bail out if there's a loop in the flow grid (there are still goddamn loops!)[137]     ⎕←'*** Loop in flow grid! ***' ⋄ FLUSH[138]     →L3                            [139]  :end[140]  JJ←JJ⍪J[141]  B[I]←B[I]^~∨/,((Q[;1]≠2)⌿Q[;2 3])^.=2 1⍴J      ⍝         when multiple outflows fall on same flowline, keep lowermost (but don't count subwatersheds!)[142] ⍝ B←B^(Q[;1]=2)∨,Q[;2 3]∨.≠2 1⍴J                 ⍝         wiping out all spurious downstream outflows (but not subwatersheds!) we find[143]  →L5[144] [145] L4:⍞←(0∊B)/'   ',(⍕+/~B),' spurious outflows removed.',⎕TCNL ⋄ FLUSH[146]  Q←B⌿Q                                          ⍝Remove spurious outflows[147]  Z←Z⍪Q[;1],(↑1 FINDPOINT¨↓Q[;2 3]),Q[;4]        ⍝Convert to points and add to results[148] [149] L2:→(0≠NEXTBLOCK)/L1                            ⍝Until done with tiles[150] [151] [152]  ⎕←'Step 2. Writing outflow table...' ⋄ FLUSH[153]  Z←Z[⍋Z[;4];⍳3]                                 ⍝Sort subwatersheds, smallest to largest so they run in the right order when nested. Drop area.[154]  Z←Z[⍒Z[;1];]                                   ⍝and put subwatersheds ahead of full watersheds[155] [156]  Z←(⍳1↑⍴Z),Z                                    ⍝Add watershed ids to watershed table[157]  head←1↓⎕TCHT MTOV MATRIFY 'watershed what x-coord y-coord'[158]  Z TMATOUT pathW PATH result[159] [160] ⍝ ⎕←'Step 2a. Stitching masked flow grid...' ⋄ FLUSH[161] ⍝ Q←pathW,'flow_m'[162] ⍝ 1 ⎕CMD ⎕←'   ',rpath,' ',rcodepath,'do.stitch.RData --sdi --args ',Q      ⍝Call R and Python to stitch masked flow grid[163] [164]  ⎕←'Step 3. Delineating watersheds...' ⋄ FLUSH[165]  'wsheds' 1 GENERATEPOINTS Z[;1 3 4]            ⍝Create shapefile of watershed points via AML[166]  ⎕←'Delineating ',(⍕1↑⍴Z),' watersheds in Python...this will take a long, long time...' ⋄ FLUSH[167]  C←T←STRIPDRIVE pythonpath[168]  C←C OVER 'cd ',(⍴T)↓pythonpath[169]  C←C OVER 'delineatewatershedsscript.py ',flow2,' ',(pathW,'wsheds.shp'),' ',pathW,' ',luwet2,' watersheds wsheds_id'[170]  1 ⎕CMD ⎕←'   ',1↓'&' MTOV C                            ⍝Build watersheds in Python[171] [172] [173]  ⎕←'Step 4. Making a mosaic from watersheds...' ⋄ FLUSH[174]  Q←(pathW,'watersheds'),' ',pathW,'watersheds_m'[175]  1 ⎕CMD ⎕←'   ',rpath,' ',rcodepath,'do.makemosaic.RData --sdi --args ',Q      ⍝Call R and Python to make a mosaic from results[176] [177] [178]  ⎕←'Step 5. Finding MERs for watersheds...' ⋄ FLUSH[179]  BLOCK 3000 3000,buffer←0[180]  SETTILE[181]  Z←Z,(((1↑⍴Z),2)⍴⌊/⍳0),((1↑⍴Z),2)⍴⌈/⍳0          ⍝   add MER columns to result[182] [183] [184] L6:⎕←'Tile ',(⍕block[4]),',',(⍕block[5]),' of ',(⍕block[6]),',',(⍕block[7]),'...' ⋄ FLUSH[185]  W←READ pathW,'watersheds_m'                    ⍝Read tile of watersheds[186]  →(^/,W=MV)/L8[187]  M←~(READ mask)∊0,MV[188]  :if tr[189]     M←EXPAND EXPAND EXPAND (MV≠READ luwet)^M    ⍝      mask (formerly UGLYMASK, which didn't work)[190]  :end[191]  W←MVREP W (~M)                                 ⍝   mask watersheds (need this for TR)[192]  U←(Z[;1]∊W)/Z[;1]                              ⍝   unique watersheds in tile[193] [194]  I←0[195] L7:→((⍴U)<I←I+1)/L8                             ⍝   for each watershed in tile,[196]  Q←⊃,/(1↑¨Q),¯1↑¨Q←CLIP W=U[I]                  ⍝      min row, min col, max row, max col[197]  Q←⊃,/1 FINDPOINT¨↓2 2⍴Q[3 2 1 4]               ⍝      min X,Y, max X,Y in map units[198]  Z[J;5 6]←Z[J←Z[;1]⍳U[I];5 6]⌊Q[1 2]            ⍝      keep running min and max as we go through tiles[199]  Z[J;7 8]←Z[J;7 8]⌈Q[3 4][200]  Z[J;5 6 7 8]←(Z[J;5 6]⌊Z[J;3 4]),Z[J;7 8]⌈Z[J;3 4] ⍝      and make sure outflow is included![201]  →L7[202] [203] L8:→(0≠NEXTBLOCK)/L6                            ⍝Until we're done with tiles[204] [205] L9:Z←(Z[;5]≠⌊/⍳0)⌿Z                             ⍝Drop watersheds that were masked out[206]  head←1↓⎕TCHT MTOV MATRIFY 'watershed what x-coord y-coord xmin ymin xmax ymax'[207]  Z TMATOUT T←pathT PATH result[208]  ⎕←'----- MAKEWATERSHEDS is done. Results are in ',T,' -----' ⋄ FLUSH[209] [210]  Q←(×/Z[;7 8]-Z[;5 6])÷cellsize*2[211]  Q←+⌿Q∘.≥T←0,2E6×⍳8[212]  Q←(T÷1E6),[1.5]Q-1↓Q,0[213]  ⎕←''[214]  ⎕←'≥ Size' ''⍪'(millions' 'Number of'⍪'of cells)' 'watersheds'⍪Q[215]  :if Q[1↑⍴Q;2]>0[216]     ⎕←'*** Watersheds larger than 16 million cells definitely can''t be processed.'[217]  :end    ∇