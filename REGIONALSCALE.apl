    ∇ REGIONALSCALE S;M;W;X;Z;I;Y;Q;E;V;K;L;G;O;P;T;dot;head;R;H;I;C;J;B;N;missing;F;U[1]   ⍝Regional version of POSTSCALE when run using REGIONALPOST[2]   ⍝Do benchmark-based post-processing by region current tile for target communties in scenario 2⊃⍺[3]   ⍝Parameters:[4]   ⍝   ⍵[1]    1 for metrics or 2 for iei[5]   ⍝   ⍵[2]    scenario name[6]   ⍝Globals:[7]   ⍝   grid        name of landcover[8]   ⍝   postmetrics names of metrics, corresponds to columns of weights (except 1st)[9]   ⍝   weights     table of grid code, community weights[10]  ⍝   names       names of community classes, corresponds to rows of weights[11]  ⍝   gradient    yes if doing gradient post-processing[12]  ⍝   source      path to raw metrics; default = pathR[13]  ⍝   results     path to post results (default = pathE,'scaled\')[14]  ⍝   regionpath  path to region grids[15]  ⍝   region      if called from regionalpost, contains regionmap name and region[16]  ⍝   savescaled  if yes, write scaled metrics to disk[17]  ⍝   futuregrids list of stressor grids to treat as 0 in initial timestep. *** Note: you must set [caps] timestep accordingly when using futuregrids[18]  ⍝Source:[19]  ⍝   landcover, metrics (or iei/other indices)[20]  ⍝Results:[21]  ⍝   scaled metrics/indices[22]  ⍝[23]  ⍝Results are placed in results + optional scenario name[24]  ⍝Dropped aspatial summaries, IEI_I, and index (resil vs. intactness) from POSTSCALE[25]  ⍝B. Compton, 20-22 Mar 2014 (from POSTSCALE)  The first day of spring! What a long, long winter it's been...[26]  ⍝22 Apr 2014: add savescaled[27]  ⍝6 Jan 2015: add futuregrids[28]  ⍝20 Feb 2015: use inputs_metrics.par for metric name replacement (can't use inputs.par thanks to collisions)[29]  ⍝22-23 Feb 2015: minor bugs in future grids[30]  [31]  [32]  [33]   E S ← 2↑S,⊂''[34]   P←results,((~0∊⍴⍕S)/(⍕S),'\')[35]   W←E⊃weights (weights[;,1],1)                   ⍝Weights for metrics (E=1) or IEI (otherwise)[36]   M←,E⊃postmetrics (⊂'iei',gradient/'_g')        ⍝If E=1, do metrics, if E=2, do IEI[37]   missing←0 3⍴0[38]   F←FRDBL¨↓TOLOWER MATRIFY futuregrids           ⍝Grids available only for future timesteps. Omit if timestep=0.[39]  [40]   ⎕←'Post-processing ',(E⊃'metrics' 'IEI'),' for ',(⍕⍴names),' target communities',((~0∊⍴S)/' (scenario=',(⍕S),')'),' using ',(⍕⍴M),' metrics...'[41]   X←READ GRIDNAME pathG PATH grid,⍕S             ⍝Read landcover[42]   →(0∊⍴T←'*' INCLUDE X)/0                        ⍝apply mask and exclude. Bail if empty.[43]   X←X×T                                          ⍝set masked cells to 0[44]  [45]   :if ~'full'≡2⊃region                           ⍝If we're doing regions,[46]      R←,READ GRIDNAME regionpath PATH 2⊃region   ⍝   Read regionmap[47]      H←(~R∊0,MV)/R[48]      H←H[⍋H][49]      H←(H≠0,¯1↓H)/H                              ⍝   Unique regions in tile[50]   :else[51]      R←(×/⍴X)⍴H←,1[52]   :end[53]  [54]   C←(⍴H)⍴0[55]   :for I :in ⍳⍴H                                 ⍝For each region in tile, read benchmark files[56]      C[I]←⊂MATIN (benchpath,(0∊⍴benchpath)/pathE),'benchmark',(⍕E),'_',(2⊃region),'_',(⍕H[I]),(gradient/'g'),'.csv'[57]   :end[58]  [59]   Z←(+/G←,X∊W[;1])⍴0                             ⍝Result, target community cells only[60]   I←0[61]  L1:→((⍴M)<I←I+1)/L4                             ⍝For each metric,[62]   BREAKCHECK[63]   DOT[64]   L←,X∊(O←O\((O←0≠W[;I+1])/W[;1])∊X)/W[;1]       ⍝   selection vector: cells in communities that use this metric[65]   →(~∨/L)/L1                                     ⍝   If no communities in this tile for this metric, bail out[66]   Q←E⊃(source,I⊃M) (P,(2⊃region),'\rawiei',gradient/'_g')  ⍝   Metric file or raw iei[67]   :if U←(timestep=0)^(⊂TOLOWER I⊃M)∊F            ⍝   If this grid is only available in the future, and this is timestep 0,[68]      N←(⍴L)⍴0 ⋄ V←1                              ⍝      stressor metric, all zero[69]   :else[70]      N←,READ ⊃(⊃,/IFGRIDEXISTS¨T)/T←(⊂0 'inputs_metrics') GRIDNAME¨(⊂Q),¨S ''   ⍝   Read block of metric result or IEI (scenario metric if it exists, otherwise just base name)[71]      V←'negative'≡GETDIRECTION I⊃M               ⍝   Reverse metric?[72]   :end[73]   Y←(⍴N)⍴0[74]   J←0[75]  [76]  L2:→((⍴H)<J←J+1)/L3                             ⍝   For each region in tile,[77]   B←L\H[J]=L/R                                   ⍝      selection vector for this region, corresponds to grids[78]   →(~∨/B)/L2                                     ⍝      if any cells in region,[79]   Y←Y+B\RESCALE_METRICS (B/,X) (B/N) (O/W[;1]) (((TOUPPER (J⊃C)[;2])≡¨TOUPPER¨M[I])⌿J⊃C) V (E≤1)   ⍝         Rescale (use zero-pushing on metrics phase)[80]   →L2[81]  [82]  L3:[83]   :if (~U)^savescaled∨E=2                        ⍝   If saving scaled metrics or this is IEI,[84]      ((⍴X)⍴MVREP Y (~L)) WRITE P PATH (2⊃region),'\',(I⊃M),⍕S    ⍝      write scaled metric (unless it's a future grid at current timestep)[85]   :end[86]   →(E=2)/L1                                      ⍝   If doing metrics,[87]   Z←Z+(G/L)\(L/Y)×W[W[;1]⍳L/,X;I+1]              ⍝      weight metric and add to running IEI[88]   →L1[89]  [90]  L4:⎕←''[91]   :if ~E=2                                       ⍝If doing metrics,[92]      Z←(⍴X)⍴(MV×~G)+G\Z                          ⍝   expand to full grid[93]      Z WRITE P PATH (2⊃region),'\rawiei',(gradient/'_g'),S   ⍝   write raw iei[94]   :end    ∇