    ∇ CLUSTERMODEL K;S;C;N;X;V;S_;head;M_;C_;W;landcover;Q;I;Y;D;R;B;T;Z;L;J;M;index;A;framework[1]   ⍝Build cluster model file for gradient post-processing (step 4)[2]   ⍝Source:[3]   ⍝   post\samplesettings.txt             sampled settings variables (from SAMPLESETTINGS)[4]   ⍝   post\settingsclusters<n>.txt        cluster medoids (from cluster.settings())[5]   ⍝   settings.par                        table of settings and weights[6]   ⍝   postmodel.par                       community models[7]   ⍝   landcover.par                       cover class table[8]   ⍝Parameters:[9]   ⍝   none[10]  ⍝Result:[11]  ⍝   model\clustermodel<n>.par           model for each cluster to use in post-processing[12]  ⍝   community-cluster<n>-summary.csv    summary of number of clusters, 90% clusters, and pure clusters for each community[13]  ⍝   post\cluster<n>-community.txt       frequencies of communities in each cluster[14]  ⍝   post\cluster<n>-community-pct.csv   percentages of communities in each cluster, for looking at in Excel[15]  ⍝B. Compton, 16 Nov 2011[16]  ⍝10 Jan 2012: deal with possible index row in postmodel.par[17]  ⍝3 Feb 2012: don't expect community column in settingsclusters.txt[18]  ⍝6 Feb 2012: loop over scales[19]  [20]  [21]  [22]   ⍎(0=⍴K←,K)/'K←10 100 1000'[23]   framework←'caps'[24]   SETPATHS[25]   INIT[26]  [27]   S←TABLE 'settings'                         ⍝Get table of settings variables[28]   S_←FRDBL¨↓',' MATRIFY head[29]   M←TABLE 'postmodel'                        ⍝And community models[30]   M_←FRDBL¨↓',' MATRIFY head[31]   index←(¯1+1↓⍴M)⍴⊂'iei'                     ⍝default index is IEI[32]   →(~'index'≡TOLOWER ⊃M[1;1])/L1             ⍝If index is supplied,[33]   index←TOLOWER 1↓M[1;]                      ⍝   return list of indices[34]   M←1 0↓M                                    ⍝   and drop it from weights[35]   M[;1↓⍳1↓⍴M]←NUMBERS M[;1↓⍳1↓⍴M]            ⍝   it will have prevented conversion to numeric in MATIN, so do it now[36]  L1:A←TABLE pathE PATH 'samplesettings.txt'  ⍝And sampled settings variables[37]  [38]  [39]   J←0[40]  L2:→((⍴K)<J←J+1)/L7                         ⍝For each scale,[41]   C←TABLE pathE PATH 'settingsclusters',(⍕K[J]),'.txt'⍝   read clusters[42]   C_←FRDBL¨↓',' MATRIFY head[43]  [44]   W←S[S[;1]⍳1↓C_;S_⍳⊂'dist']                 ⍝   Settings weights corresponding to columns of C and A[45]   W←W÷(+/W*2)*.5                             ⍝   Rescale so maximum distance = 1[46]   X←A[47]   X[;1↓⍳1↓⍴X]←X[;1↓⍳1↓⍴X]×(0 ¯1+⍴X)⍴W        ⍝   Rescale sampled settings variables (so they match those in clusters)[48]  [49]   D←⍉(1,0 ¯1+⍴C)⍴0 1↓C                       ⍝   Settings in clusters[50]  [51]   landcover←¯1 TABLE landcoverpar[52]   Q←LOOKUP (⍳1↑⍴M),M[;,1]                    ⍝   Index community names in model[53]   N←Q[;1],0 1↓M[Q[;2];]                      ⍝   Model table is community class, model[54]  [55]   N[;1↓⍳1↓⍴N]←Q÷⍉(⌽⍴Q)⍴+/Q←0⌈0 1↓N           ⍝   Community weights in terms of proportion.  All weights forced to ≥0[56]  [57]   Y←(1↑⍴X)⍴0[58]  [59]  ⍝Assign the samples to clusters[60]   I←0[61]  L3:→((1↑⍴X)<I←I+1)/L4                       ⍝   For each sample,[62]   R←,(1↓X[I;]) EUDIST D                      ⍝   Get ecological distance from sample to each cluster[63]   Y[I]←1↑(R=⌊/R)⌿C[;1]                       ⍝         Pick closest cluster (in case of ties, earlier cluster #s win)[64]   →L3[65]  [66]  ⍝Build (and write) cluster × community table[67]  L4:Q←Y,X[;,1]                               ⍝   Cluster, community[68]   B←∨/Q≠0⍪¯1 0↓Q←Q[⍋Q;][69]   Q←(B⌿Q),B pSUM (⍴B)⍴1                      ⍝   Frequencies[70]   Q[;2]←N[;1]⍳Q[;2][71]   V←((1↑⍴C),1+1↑⍴N)⍴0                        ⍝   Clusters × communities (last community is garbage community - those not in model)[72]   V←0 ¯1↓V SCATR (Q[;1 2]) (Q[;3])           ⍝   Cluster × communtiy frequency table[73]  [74]   head←'cluster',⊃,/⎕TCHT,¨landcover[landcover[;1]⍳N[;1];2][75]   (C[;1],V) TMATOUT pathE,'cluster',(⍕K[J]),'-community.txt'[76]  [77]   V←V÷⍉(⌽⍴V)⍴1⌈T←+/V                         ⍝   Proportional representation of communities in each cluster[78]   head←'cluster,n,majority,max',⊃,/',',¨L←landcover[landcover[;1]⍳N[;1];2][79]   Q←(L←L[1++/^\V<⍉(⌽⍴V)⍴⌈/V]),2 ROUND BLANK 100×(⌈/V),V[80]   (C[;1],T,Q) CMATOUT pathE,'cluster',(⍕K[J]),'-community-pct.csv'    ⍝   Write version for looking at in Excel[81]  [82]  [83]  ⍝Now make community summary table[84]   T←((landcover[;2]∊L)/landcover[;2])⍳L      ⍝   Sort by community order[85]   Q←T,L,(∨/V=1),[1.5]∨/V≥.9[86]   Q←Q[⍋Q[;1];][87]   B←Q[;1]≠¯1↓0,Q[;1][88]   Q←(B⌿Q[;2]),(B pSUM (⍴B)⍴1),(B pSUM Q[;4]),[1.5]B pSUM Q[;3][89]   head←'community,clusters,90% clusters,pure clusters'[90]   Q CMATOUT pathE,'community-cluster',(⍕K[J]),'-summary.csv'[91]  [92]  [93]   Z←((1↑⍴C),1↓⍴N)⍴0[94]  ⍝Now build community model for each cluster[95]   I←0[96]  L5:→((1↑⍴C)<I←I+1)/L6                       ⍝   For each cluster[97]   Z[I;]←C[I;1],+⌿(⍉(⌽0 ¯1+⍴N)⍴V[I;])×0 1↓N   ⍝      Blended model based on community representation in each cluster[98]   →L5[99]  [100] L6:head←'Cluster',⊃,/⎕TCHT,¨1↓M_[101]  (((⊂'index'),index)⍪1 ROUND Z[;1],100×0 1↓Z) TMATOUT pathI PATH 'clustermodel',(⍕K[J]),'.par'[102] [103]  ⎕←'Results written to clustermodel',(⍕K[J]),'.par, cluster',(⍕K[J]),'-community.txt, cluster',(⍕K[J]),'-community-pct.txt, and community',(⍕K[J]),'-cluster-summary.txt.'[104]  →L2[105] [106] L7:⎕←'CLUSTERMODEL is done.'    ∇