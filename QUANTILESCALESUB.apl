    ∇ QUANTILESCALESUB A;X;Q;M;I;T;R;block;loop;test;grids;ffile;L;J;K;head;noread;H;Qu;Y;V;Z;D;U;buffer;missing;E;N;tilemapinclude;dot;exclude;skiptilemap;B;S;strata;G;O[1]   ⍝Subroutine of QUANTILESCALE and SCRIPT_QUANTILE.  Rescale source grid by quantiles, stratified by stratify grid[2]   ⍝Arguments:[3]   ⍝   1⊃A = source & strata grids[4]   ⍝   3⊃A = result[5]   ⍝   4⊃A = buffer[6]   ⍝Global variables:[7]   ⍝   nodata          vector of values in strata grids to treat as missing[8]   ⍝   reverse         if yes, take complement of result[9]   ⍝   integerize      if yes, results are integers from 0 to 100 instead of floating point 0-1[10]  ⍝   zeropush        if yes, use zero-pushed quantiles (zeros are excluded from quantiles, then reincluded as 0)[11]  ⍝   retainzeros     if yes, zeros are included in quantiles, but all cells corresponding to 0 input are set to 0[12]  ⍝   includemissing  if 1, nodata cells in target grid where mask and/or stratification grids are nonmissing are treated as zeros[13]  ⍝   samples         number of samples per strata × quantile (1E4 is fairly stable)[14]  ⍝   quantiles       number of quantiles (100 for percentiles)[15]  ⍝   tilesize        size of tiles (in cells)[16]  ⍝Note: When running for multiple strata grids, a temporary strata index working\strataindex is created. Okay[17]  ⍝to delete it after running. Runs with multiple strata are considerably slower.[18]  ⍝WARNING WARNING WARNING: if you run with one stratum, values are expected to run from 1 to # of classes.  If they include, say, 99,999, [19]  ⍝this will day many days to run! Reclassify the grid first![20]  ⍝B. Compton, 2 and 19-20 May 2014 (from BENCH and POSTSCALE)[21]  ⍝26 May 2014: consistently skip include grid[22]  ⍝27 May 2014: work right no with strata grid; get last INCLUDE right[23]  ⍝28 May 2014: use tilemap to vastly speed up first pass when run multiple times[24]  ⍝19 Jun 2014: add includemissing for use with MAKECORES[25]  ⍝8 Jul 2014: don't let excluded communities wreck havoc![26]  ⍝10 Sep 2014: put strataindex in temporary path![27]  ⍝18 Sep 2014: never skip TILEMAP call, even in debugging; add REPATH for calls from SCRIPT[28]  ⍝22 Sep 2014: add retainzeros[29]  ⍝26 Sep 2014: remove calls to INCLUDE--they aren't right, because input grid isn't landcover!  Pull guts from QUANTILESCALE.[30]  ⍝22 Dec 2014: when building strata index, ignore cells with missing target cells for big speed-up, I think[31]  ⍝24 Feb 2014: bug! wasn't writing strata index if nothing new in it![32]  ⍝8 Feb 2016: 7.5x speedup of lookup of combined strata in index---which crashes when many items with LIMIT ERROR[33]  ⍝9 Feb 2016: new approach to speedup: make index once and use it twice. Not super-fast, but robust and much faster than before (better than 2x speedup)[34]  [35]  [36]  [37]  ⍝-----Pass 1: Count cells in each strata by tile & build strata index if necessary[38]   buffer←4⊃A[39]   exclude←''[40]   loop←test←noread←0 ⋄ grids←0 0⍴''              ⍝Silly junk for BLOCK, etc.[41]   ffile←'QUANTILESCALE (pass 1) '[42]   BLOCK 2⍴tilesize[43]   SETTILE[44]  [45]   tilemapinclude←0[46]   skiptilemap←0                                  ⍝Don't let DEBUG sabotage this[47]   E←TILEMAP '' tilesize 0 0                      ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[48]   ⎕←'Running for ',(⍕+/E),' tiles' ⋄ FLUSH[49]   LOG 'QUANTILESCALE, Pass 1: Counting cells in each strata by tile'[50]  [51]   :if 1=≡1⊃A[52]      A[1]←⊂A[1],⊂''[53]   :end[54]  [55]   :if 0∊⍴strata←1↓1⊃A                            ⍝If no stratification grid,[56]   :orif ^/0=⊃,/⍴¨strata[57]      strata←''[58]      H←,1                                        ⍝   just one stratum[59]   :elseif 1=⍴strata                              ⍝Else, if one stratification grid,[60]      H←⍳(1 GRIDDESCRIBE S←2⊃1⊃A)[9]              ⍝   describe strata grid to get maximum value - we'll assume strata are ⍳max[61]      ⎕ERROR (1000<⍴H)/'There are more than 1000 classes in strata grid ',S,' - classes should be consecutive integers'[62]   :else                                          ⍝Else, mulitple stratification grids[63]      LOG '   Building stratification index'[64]      H←⍳0                                        ⍝   we know nothing yet, so have no strata[65]      D←(0,⍴strata)⍴0                             ⍝   set up empty strata index, corresponding to H[66]      S←pathI PATH 'strataindex'                  ⍝   name of temporary strata grid[67]   :end[68]  [69]   L←((⍴H),×/block[6 7])⍴0                        ⍝Number of cells in each strata × tile[70]   N←0[71]  L1:→(~E[N←N+1])/L3                              ⍝Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[72]   BREAKCHECK ⋄ DOT[73]   Y←READ 1⊃1⊃A                                   ⍝   Read target grid to get missing values[74]   :if includemissing                             ⍝   If includemissing,[75]      Y←0 MVREP Y                                 ⍝      treat nodata cells in target as 0[76]   :end[77]   :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[78]      Y←MVREP Y (~G←~(READ mask)∊0,MV)            ⍝      read mask and drop cells from target[79]   :end[80]  [81]   :if 0=⍴strata                                  ⍝   If no stratification grid,[82]      X←(⍴Y)⍴1                                    ⍝      all cells are in stratum 1[83]   :elseif 1=⍴strata                              ⍝   Else, if one stratification grid,[84]      X←READ 2⊃1⊃A                                ⍝      read stratum grid[85]   :else                                          ⍝   Else, mulitple stratification grids[86]      Q←((⍴Q),⍴strata)↑((⍴Q),1)⍴Q←,X←READ 1⊃strata⍝      Read 1st grid[87]      :for I :in 1↓⍳⍴strata                       ⍝      For each subsequent strata grid,[88]         Q[;I]←,READ I⊃strata                     ⍝         read it[89]      :end[90]      O←(↓D)⍳↓Q                                   ⍝      Index grid in strata index (this line is very slow--we do it once and use it twice)[91]      O[(O=1+1↑⍴D)/⍳⍴O]←0[92]      U←((O=0)^(,Y≠MV)^^/~Q∊MV,nodata)⌿Q          ⍝      Drop all cells that have any missing strata or target and any that are already in the index[93]      →(0∊⍴U)/L14                                 ⍝      Bail out if no cells in this stratum (but still write index!!)[94]      U←U[⍋U;][95]      :if ~0∊⍴U                                   ⍝      If we've picked up any new combinations,[96]         D←D⍪(∨/U≠0⍪¯1 0↓U)⌿U                     ⍝      Add unique combinations of strata = strata index[97]         O[(O=0)/⍳⍴O]←(↓D)⍳↓(O=0)⌿Q               ⍝      and add them to index[98]         O[(O=1+1↑⍴D)/⍳⍴O]←0[99]      :end[100]     H←⍳1↑⍴D                                     ⍝      Extend strata list[101]     L←((⍴H),1↓⍴L)↑L                             ⍝      Extend cell count[102] L14:X←(⍴X)⍴(MV,H)[O+1]                          ⍝      Index grid for all strata combined [103]     X WRITEI S                                  ⍝      Write index grid[104]  :end[105]  X←MVREP X (Y=MV)[106]  X←(M←,(~X∊MV)^G)/,X[107]  →(0∊⍴X)/L3                                     ⍝   If anything non-missing,[108] ⍝ L[;block[4];block[5]]←+⌿X∘.=W[;1]             ⍝      (done in loop, below)[109]  J←0[110] L2:→((1↑⍴L)<J←J+1)/L3                           ⍝      Number of cells per stratum (vastly faster than ∘.=)[111]  L[J;block[5]+block[7]×block[4]-1]←+/X=H[J][112]  →L2[113] L3:→(0≠NEXTBLOCK)/L1                            ⍝   Until no more tiles[114] [115]  ⎕←''[116]  L←(T←∨/L≠0)⌿L                                  ⍝Drop strata don't exist in any tiles in grid[117]  H←T/H[118]  L←⌊.5+L×⍉(⌽⍴L)⍴1⌊samples÷+/Q←L                 ⍝Number of points to sample per tile & stratum (proportional to availability)[119] L4:→(^/0=T←1⌊¯1⌈(samples<+/Q)×samples-+/L)/L5   ⍝   Repeat: correction factor - some are high or low due to rounding proportions[120]  L←0⌈L+(Q>L)⌊(?(⍴T)⍴1↓⍴Q)⌽T,((⍴T),¯1+1↓⍴Q)⍴0    ⍝      Correct where there are points available[121]  →L4                                            ⍝   Until we've got what we want (as available)[122] [123] [124] ⍝-----Pass 2: Pick x,ys for each tile & sample data[125] L5:LOG 'QUANTILESCALE, Pass 2: Sampling data'[126]  M←((1↑⍴L),3,samples)⍴0                         ⍝   Sampling points [strata × 3 (tile, x, y) × points per stratum][127]  R←(⍴M)[1 3]⍴MV                                 ⍝   Samples for this metric - pad with MVs[128]  V←+\0,0 ¯1↓L                                   ⍝   Starting point (-1) for each community × tile[129] [130]  Qu←(0,⍳quantiles-1)÷quantiles                  ⍝   Quantiles[131]  ffile←'QUANTILESCALE (pass 2) '                ⍝   Reset block[132]  BLOCK 2⍴tilesize[133]  I←dot←0[134] L6:→((1↓⍴L)<I←I+1)/L9                           ⍝   For each tile (2nd time),    --- For each tile ---[135]  →(^/0=L[;I])/L8                                ⍝      If any strata cells in tile,[136]  BREAKCHECK ⋄ DOT[137] [138]  Y←READ 1⊃1⊃A                                   ⍝         Read target grid[139]  :if includemissing                             ⍝         If includemissing,[140]     Y←0 MVREP Y                                 ⍝            treat nodata cells in target as 0[141]  :end[142]  :if 0=⍴strata                                  ⍝         If no stratification grid,[143]     X←(⍴Y)⍴1                                    ⍝            all cells are in stratum 1[144]  :else                                          ⍝         Else, one or more stratification grids[145]     X←READ S                                    ⍝            Read tile of strata grid[146]  :end[147]  X←MVREP X ((X∊nodata)∨Y=MV)                    ⍝   Get missing values in target grid and values in 'nodata'[148]  :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[149]     X←X×~(READ mask)∊0,MV                       ⍝      read mask and apply it[150]  :end[151]  J←0[152] L7:→((1↑⍴L)<J←J+1)/L8                           ⍝         For each stratum,[153]  →(L[J;I]=0)/L7                                 ⍝            If in tile,[154]  Q←(,X=H[J])/,Y                                 ⍝            All points in target grid in this strata[155]  R[J;V[J;I]+⍳L[J;I]]←Q[L[J;I]?⍴Q]               ⍝            Sample however many random points we want[156]  →L7[157] L8:T←NEXTBLOCK[158]  →L6                                            ⍝   Next tile[159] [160] L9:⎕←''[161]  R←7 ROUND R                                    ⍝Excess digits trash zero-pushing[162]  Z←H,0,0,7 ROUND↑(⊂Qu zeropush) QTILEZ¨↓R       ⍝Benchmark table [;1] = community, [;2 3] = not used, [;4..P[2]+2] = quantile (all zeros pushed into 1st group)[163] [164] [165] ⍝-----Pass 3: Rescale target grid[166] L10:loop←test←noread←0 ⋄ grids←0 0⍴''           ⍝Silly junk for BLOCK, etc.[167]  ffile←'QUANTILESCALE (pass 3) '                ⍝Reset block[168]  BLOCK 2⍴tilesize[169]  missing←0 3⍴0                                  ⍝   For compatability with RESCALE_METRICS[170]  LOG 'QUANTILESCALE, Pass 3: Rescaling target grid'[171] [172]  I←dot←0[173] L11:→((1↓⍴L)<I←I+1)/L13                         ⍝For each tile (3rd time),    --- For each tile ---[174]  →(^/0=L[;I])/L12                               ⍝   If any strata cells in tile,[175]  BREAKCHECK ⋄ DOT[176]  Y←READ 1⊃1⊃A                                   ⍝      Read target grid[177]  :if includemissing                             ⍝      If includemissing,[178]     Y←0 MVREP Y                                 ⍝         treat nodata cells in target as 0[179]  :end[180]  :if 0=⍴strata                                  ⍝      If no stratification grid,[181]     X←(⍴Y)⍴1                                    ⍝         all cells are in stratum 1[182]  :else                                          ⍝      Else, one or more stratification grids[183]     X←READ S                                    ⍝         Read tile of strata grid[184]  :end[185]  :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[186]     X←MVREP X ((READ mask)∊0,MV)                ⍝      read mask and apply it[187]  :end[188]  Q←(K←,(~X∊MV,nodata)^Y≠MV)/,X                  ⍝   Drop missing cells in both grids[189]  Y←K/,Y[190]  B←(~retainzeros)∨Y≠0                           ⍝   if retainzeros, zeros in input grid are set to zero[191]  Y←B×RESCALE_METRICS Q Y H Z reverse zeropush   ⍝   rescale target[192]  :if integerize                                 ⍝   If integerize,[193]     Y←⌊.5+Y×100                                 ⍝      turn into integers from 1-100[194]     ((⍴X)⍴(MV×~K)+K\Y) WRITEI REPATH 3⊃A        ⍝      and write scaled metric[195]  :else                                          ⍝   Else,[196]     ((⍴X)⍴(MV×~K)+K\Y) WRITE REPATH 3⊃A         ⍝      keep as floating, and write scaled metric[197]  :end[198] L12:T←NEXTBLOCK                                 ⍝      Next tile[199]  →L11[200] [201] L13:⎕←''    ∇