    ∇ Z←O BLOCKREPS S;block;N;C;P;T;gridname;framework;tilebits;⎕RL[1]   ⍝Build reps for CAPS block metric given name of include grid ⍵[1], tile size ⍵[2], buffer ⍵[3], maskgroup ⍵[4], start subtask ⍵[5] and n subtasks ⍵[6] and override parameters in ⍺[2]   ⍝Global:[3]   ⍝   blocks     selected blocks to run for[4]   ⍝   tilebits    (from override_pars): name of a file with bit vector used to select tiles, used by D8LOOP[5]   ⍝B. Compton, 23 May 2011, from BLOCKRUN[6]   ⍝16 Jan 2012: left argument has override pars to support temporary directory[7]   ⍝23 Jan 2012: push override_pars into INIT_S; new scheme[8]   ⍝21 Aug 2012: pass maskgroup to TILEMAP[9]   ⍝18 Dec 2013: add tilebits[10]  ⍝27 Jan 2014: use SETTILE instead of noread←1 nonsense; 31 Jan: I left a stray READ[11]  ⍝5 Sep 2014: optionally passed subset of subtasks to generate for task splitting[12]  ⍝5 Apr 2018: make sure block # and total number of blocks are correct when splittasks is true[13]  [14]  [15]  [16]   framework←'caps'[17]   ⍎(0=⎕NC'O')/'O←'''''[18]   S←6↑S,0 0[19]   INITO O[20]   BLOCK (2⍴S[2]),S[3]                    ⍝Build blocks[21]   SETTILE[22]  [23]   N←block[6 7]                           ⍝Number of blocks in grid[24]   C←(,⍉(⌽N)⍴⍳N[1]),[1.5](×/N)⍴⍳N[2][25]   Z←((1↑⍴C),⍴Z)⍴Z←12↑block               ⍝Left arg to run = block[26]   Z[;4 5]←C[27]   Z←(TILEMAP (⊂GRIDNAME 1⊃S),S[2 3 4])⌿Z ⍝Use TILEMAP facility to drop empty blocks from run[28]  [29]   :if 0≠⎕NC 'tilebits'                   ⍝If tilebits passed via override_pars[30]      Z←(⎕FI NREAD tilebits)⌿Z            ⍝   select tiles to run[31]   :elseif (0≠2⊃S)^~0∊⍴blocks             ⍝else, if blocks supplied, run only for these blocks (unless 1 block metric)[32]      Z←Z[(T≤1↑⍴Z)/T←(↓Z[;4 5])⍳↓((⌊.5×⍴,blocks),2)⍴blocks;][33]      LOG ((⍴T)>1↑⍴Z)/⎕TCNL,'*** WARNING: One or more blocks in blocks = ',(⍕,blocks),' out of range. ***'[34]   :elseif (S[6]≠0)^S[6]<1↑⍴Z             ⍝else, if splitting tasks,[35]      :if scram^0≠⎕NC'scramblesubtasks'   ⍝   If scrambling subtasks,[36]      :andif scramblesubtasks[37]         ⎕RL←1                            ⍝      set fixed random seed so it always comes out the same[38]         Z←Z[(1↑⍴Z)?1↑⍴Z;]                ⍝      and scramble subtasks[39]      :end[40]      Z←(S[5],0)↓Z                        ⍝      and take appropriate subset of subtasks[41]      Z←((S[6]⌊1↑⍴Z),1↓⍴Z)↑Z[42]   :end[43]  [44]   Z[;11]←Z[;5]+Z[;7]×Z[;4]-1             ⍝block[11] is block #[45]   Z[;12]←×/Z[1;6 7]                      ⍝New block[12] is total number of blocks...it's not simple any more    ∇