    ∇ A MOVEPOOLSLC S;buffer;X;C;V;D;R;T;Q;B;reach;roads;I;P;G;K;J;Y;E;Z;pool;avoid;head;N;poolpoints;roadvectors[1]   ⍝Find vernal pools that fell on road cells, and move them to non-road cells in the right direction[2]   ⍝Implemented as a CAPS metric[3]   ⍝Must run makemovepools.aml first to prepare vector data (which is loaded once kept in workspace; use CLEAR to delete it)[4]   ⍝Parameters:[5]   ⍝   buffer  number of extra cells to read around edges; limits how far pools can move.  Probably 1 or 2[6]   ⍝   reach   meters beyond block to look for road segments; keeps roads with both endpoints outside of block[7]   ⍝   roads   classes to treat as roads (include railroads & culverts).  Done the old-fashioned way for the sake of kernel pools[8]   ⍝B. Compton, 11 Feb 10[9]   ⍝21 May 2010: use LOCKWRITE[10]  ⍝9 Dec 2010: split off from CAPS version; this version uses integrated land cover[11]  ⍝TEST BLOCK: 20,30[12]  [13]  [14]  [15]   READPARS ME[16]   buffer←B←4⊃A[17]   ⍞←'Reading vector data...' ⋄ FLUSH[18]   poolpoints←MATIN path,'project\pools.txt'              ⍝   potential vernal pools[19]   T←(MATIN path,'project\roads.txt')[;⍳4]                ⍝   road + trains together; don't care about classes[20]   roadvectors←T⍪(MATIN path,'project\trains.txt')[;⍳4][21]   ⎕←'done' ⋄ FLUSH[22]  [23]   X←READ pathG PATH 1⊃A                                ⍝Read landcover[24]   C←(1 ¯1×cellsize÷2)+FINDPOINT block[1 2]×block[4 5]-1  ⍝Upper left corner of block in map coordinates[25]   C←C,C+cellsize×1 ¯1×(⍴X)-2×buffer                      ⍝and lower right corner[26]   D←C+¯1 1 1 ¯1×reach                                    ⍝Expand block by reach (= longest road vector)[27]   V←((poolpoints[;2]≥C[1])^(poolpoints[;2]≤C[3])^(poolpoints[;3]≥C[4])^poolpoints[;3]≤C[2])⌿poolpoints       ⍝Pools in block[28]   Q←(roadvectors[;1]≥D[1])^(roadvectors[;1]≤D[3])^(roadvectors[;2]≥D[4])^roadvectors[;2]≤D[2]                ⍝Roads in block[29]   R←(Q∨(roadvectors[;3]≥D[1])^(roadvectors[;3]≤D[3])^(roadvectors[;4]≥D[4])^roadvectors[;4]≤D[2])⌿roadvectors[30]  [31]   G←(↑FINDCELL¨↓V[;2 3])-¯1+((1↑⍴V),2)⍴THISBLOCK[1 2]    ⍝Locations of PVPs in grid[32]   P←((X SCATI G+buffer)∊roads)/⍳1↑⍴V                     ⍝Pools that fall on roads[33]   Z←((⍴P),2)⍴0[34]   J←↓8 2⍴¯1 ¯1 ¯1 0 ¯1 1 0 ¯1 0 1 1 ¯1 1 0 1 1[35]   I←0[36]  L2:→((⍴P)<I←I+1)/L3                                     ⍝For each pool that falls on a road,[37]   BREAKCHECK[38]   K←↑J+¨⊂FINDCELL V[P[I];2 3]                            ⍝   Eight neighbors (row-major order)[39]   K←↑FINDPOINT¨↓K                                        ⍝   Centerpoints of 8 neighbors[40]   Y←∨/↑((⊂2 2)⍴¨↓K,8 2⍴V[P[I];2 3]) CROSS¨⊂R             ⍝   1 for cells across the road[41]   Q←(X SCATI ↑buffer+J+¨⊂G[P[I];])∊roads,avoid           ⍝   1 for road cells[42]   E←(+/(K-8 2⍴V[P[I];2 3])*2)*.5                         ⍝   distance from pool to each cell center[43]   E←(⌊/(E≠0)/E)=E←(~Y∨Q)×E                               ⍝   closest cell center not in a grid road cell nor across vector road[44]   Z[I;]←1 2↑E⌿K                                          ⍝   that's our new vp point (if there is one)[45]   →L2[46]  [47]  [48]  L3:X←X SCATR ((∨/Z≠0)⌿buffer+(↑FINDCELL¨↓Z)-¯1+((1↑⍴Z),2)⍴THISBLOCK[1 2]) pool   ⍝add new pools to landcover[49]   X WRITEI pathR PATH 3⊃A[50]   →(0∊⍴Z)/0[51]  [52]   (V[P;],Z) LOCKWRITE pathR PATH 'movedpools.txt'        ⍝Write new points to movedpools.txt[53]   →0[54]  [55]  what:other (kernel pools)[56]  type:standard[57]  info:('land') ('') ('movedpools') (buffer) 'land'     ⍝Source grids, settings table, result grid, and buffer size[58]  check:CHECKVAR 'reach roads pool avoid'[59]  check:CHECKVAR 'buffer'[60]  init:head←1↓⎕TCHT MTOV MATRIFY 'pvp_number x-coord y-coord new-x new-y' ⋄ (0 0⍴'') TMATOUT pathR PATH 'movedpools.txt' ⍝(Re)create points file on start[61]  init:LOG '--->>> Run FINISHMOVEPOOLS when finished <<<---'    ∇