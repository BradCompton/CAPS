    ∇ Z←E READBLOCKC_WITH_FRAGMENTS GP;G;P;D;L;D_;T;I;V;H;Q;head;C;mingrids;B;R;W;⎕ELX;lock;wait;A;S;U;N;cacheok;iscached;cacheinplace;copying;F[1]   ⍝Get block from grid 1⊃⍵, with optional grid description ⍺; potentially using caching[2]   ⍝   ⍵[1]    grid path & name[3]   ⍝   ⍵[2 3]  starting row & column[4]   ⍝   ⍵[4 5]  nrows & ncols[5]   ⍝   ⍵[6]    buffer in cells (default = 0)[6]   ⍝   ⍵[7]    nocache - okay to cache grid? (default = 0)[7]   ⍝Optionally passed grid description ⍺[8]   ⍝This version manages the local grid cache. Caching is initialized on each machine with CACHEINIT[9]   ⍝B. Compton, 16 Sep 2013[10]  ⍝30 Sep 2013: optionally passed grid description[11]  ⍝1 Oct 2013: finish this off, after a long hiatus on the Allagash[12]  ⍝21 Oct 2013: oops. Set sourcedate to the grid's modification date, not caching date.  Gay marriages in NJ today; Christie drops appeals.[13]  ⍝21 Nov 2013: format xll and yll to a whole lot of digits in cache directory; 25 Nov: and cellsize[14]  ⍝25 Nov 2013: call FILEINFO separately for grid and cache drive[15]  ⍝3 Dec 2013: save cached directory while we still have the lock; throw an error if it takes longer than 10 minutes for another thread to copy a grid to the cache[16]  ⍝9 Dec 2013: suppress caching if global caching = 0; 19 Dec: and, or, it's all the same...isn't it?[17]  ⍝6 Feb 2014: Deal properly with lock-releasing ⎕ELX from call to GETCACHEDIR; check here for multitiled grids so we don't copy them to the cache[18]  ⍝11 Mar 2014: unlock before ⎕ERROR, though error-handling should catch it anyway[19]  ⍝1 Apr 2014: tell MAKEDIR not to get a second lock on cache--we already have the right one[20]  ⍝1 May 2014: wait 30 min instead of 10 for grid to be copied by another thread[21]  ⍝28 Aug 2014: oops! was double-counting existing cache when figuring out whether to delete grids from cache.[22]  ⍝18 Nov 2014: oops! check for grid×10 being too big was wrong, turning off caching when cache was full![23]  ⍝21 Nov 2014: add cachewait[24]  ⍝2 Dec 2014: Nov 18th change broke check for cached grid too big (Reva's funeral today)[25]  ⍝4 Dec 2014: redo cache size checking & grid deletion to give much-needed clarification (and test it)[26]  ⍝12 Aug 2015: I broke caching with a new directory on 18 Nov 2014, and finally found it when we replaced a bad drive!; 17 Aug 2015: oops[27]  ⍝19 May 2016: MAJOR REWRITE for hashed caches[28]  [29]  [30]  [31]   mingrids←10                            ⍝Minimum number of grids in cache (mingridcapacity)[32]   wait←30                                ⍝Number of minutes to wait for grid to be copied to cache by another thread before giving error...10 min was too short[33]   G←TOLOWER 1⊃GP ⋄ P←6↑1↓GP[34]   :if 0≠⎕NC'noread'[35]      →noread/1↑⍴Z←0 0⍴''[36]   :end[37]  [38]  [39]  ⍝-----PART I: figure out caching, copy grid if necessary-----[40]  [41]   GETCACHECONFIG[42]   [43]   W←0                                                ⍝Wait count, for copying[44]   :if cacheok←cache[1]^caching^~P[6]                 ⍝If caching is on and not suppressed for this grid,[45]      V←FILEINFO G,'\'                                ⍝   Get grid size & make sure it exists[46]      ⎕ERROR (0∊⍴V)/'Source grid ',G,' does not exist'[47]      →((⊂2↑2⊃cache) FIND ⊂2↑G)/L1                    ⍝   If grid is on same drive as cache, cache-in-place[48]      D L lock A ← GETCACHEDIR 0                      ⍝   Get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[49]      D D_ ← D                                        ⍝   grid cache directory & header[50]      I←1↑D[;D_ COL 'source'] FINDI G                 ⍝   find grid in directory[51]   [52]      :if iscached←0≠I←1↑D[;D_ COL 'source'] FINDI G  ⍝   If grid is in directory,[53]         :while D[I;D_ COL 'status']≡'copying'        ⍝      While waiting for grid to be copied by another thread,[54]            UNLOCKFILE lock                           ⍝         return lock & throw error[55]            CACHEWAIT A[56]            :if wait<T←(⎕TS ELAPSED PARSEDATE ⊃D[I;D_ COL 'cachedate'])÷60      ⍝Wait 30 minutes for grid to copy[57]               ⎕ERROR 'Error: grid ',G,' cached on ',GETNAME,' has had ''copying'' status for ',(⍕⌊T),' minutes'[58]            :end                                 ⍝         else, wait for copy[59]            :if 1=W←W+1[60]               ⎕←'--> Waiting for grid ',G,' to be copied to cache (',NOW,')...' ⋄ FLUSH[61]            :end[62]            T←⎕DL 30                              ⍝         wait 30 seconds[63]            D L lock A ← GETCACHEDIR 0                      ⍝   Get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[64]            D D_ ← D                                        ⍝   grid cache directory & header[65]         :end[66]  [67]         :if ~(PARSEDATE ⊃D[I;D_ COL 'sourcedate'])≡PARSEDATE 2⊃V     ⍝      If grid is stale,[68]            iscached←0[69]            D[I;D_ COL 'source status']←⊂'expired'    ⍝   Cached grid is out of date--we'll deleted it on next frisk[70]         :end[71]      :end[72]      :if ~iscached                                   ⍝   If grid isn't in cache,[73]         :if MULTITILE G                              ⍝      If multitiled grid,[74]            UNLOCKFILE lock                           ⍝         return lock & throw error[75]            CACHEWAIT A[76]            ⎕ERROR 'Error: grid ',G,' is a multitiled ESRI grid - it can''t be read'[77]         :end[78]  [79]         D←D⍪0                                        ⍝      add grid to index[80]         D[I←1↑⍴D;D_ COL 'source status']←G 'copying'[81]         D D_ PUTCACHEDIR G[82]         UNLOCKFILE lock                              ⍝      return cache index lock[83]         CACHEWAIT A[84]          [85]         A←⎕AI[2]                                     ⍝      Start cachewait timer[86]         lock←LOCKFILE GETNAME,' cache'               ⍝      Get a lock on cacheinfo[87]         copying←1[88]         [89]         S←cache[3]⌊(U←+/D[;D_ COL 'size'])+(FILEINFO 2⊃cache)[3]-cache[4]   ⍝      Space available for cache (maxsize MIN used + free - minfree)[90]         :if (V[1]×mingrids)>S                        ⍝      If (grid×10) is too big to fit in empty cache[91]            copying←cacheok←0                         ⍝         suppress caching[92]         :else                                        ⍝      else[93]            :if 0<Q←(V[1]+U)-S                        ⍝         If we're requesting too much space [overage = (used + grid) - available],[94]               :if ~0 0 FRISKCACHE V[1]⌈cache[6]×1000 ⍝            FRISKCACHE to delete a bunch of grids and make space[95]                  copying←cacheok←0                   ⍝            If FRISKCACHE fails, suppress caching[96]               :end          [97]            :end[98]            :if copying                               ⍝      If we're copying the grid,[99]               Q←,0 MATIN F←(2⊃cache),'index\cacheinfo.txt' ⍝         read cacheinfo[100]              Q[1]←SOMETHING OR OTHER[101]              Q[2]←Q[2]+1                            ⍝         increment cache id[102]              ((⍕Q[1]),⎕TCNL,⍕Q[2]) NWRITE F         ⍝         write cacheinfo[103]              C←GETCACHEPATH G[104]           :end[105]           UNLOCKFILE lock                           ⍝         return cache index lock[106]           CACHEWAIT A[107] [108]           :if copying                               ⍝      If we're copying the grid (2nd time),[109]              TRACK '   [READBLOCKC copying grid ',G,' to cache, ',NOW,']'[110]              SETCACHE 1                             ⍝         use local grid server to copy grid[111]              ACTIVATECONNECTION[112]              G GRIDCOPY H                           ⍝         copy grid to the cache[113]              TRACK '   [READBLOCKC has copied grid ',G,' to cache, ',NOW,']'[114]           :end[115] [116]           D L lock A ← GETCACHEDIR G                ⍝      Get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[117]           D D_ ← D                                  ⍝      grid cache directory & header[118]           I←1↑D[;D_ COL 'source'] FINDI G           ⍝      find grid in directory[119] [120]           :if copying                               ⍝      If we're copying the grid (3rd time),[121]              D[I;D_ COL 'cache status']←C 'ready'   ⍝         update cache location and status[122]           :else                                     ⍝      else,[123]              D←(I≠⍳1↑⍴D)⌿D                          ⍝         remove this grid from index[124]              D D_ PUTCACHEDIR G                     ⍝         write cache index[125]              UNLOCKFILE lock                        ⍝         return cache index lock[126]              CACHEWAIT A[127]           :end[128]        :end[129]     :end       [130]  :end[131]  [132]       [133]  ⍝-----PART II: read block-----[134]  :if cacheok                            ⍝If caching, read block from cache,[135]     Q←1↓'/' MTOV T[⍳5⌊1↑⍴T←NOW OVER '/' MATRIFY Q←⊃D[I;D_ COL 'reads'];][136]     D[I;D_ COL 'reads']←⊂Q              ⍝    Update access timestamps[137]     head←1↓⎕TCHT MTOV D_[138] ⍝    D[;D_ COL 'xll yll cellsize']←FMTALL D[;D_ COL 'xll yll cellsize']    ⍝   Format xll, yll, and cellsize with a zillion digits[139]     D D_ PUTCACHEDIR G                  ⍝   Write directory[140]     UNLOCKFILE lock                     ⍝   Unlock[141]     CACHEWAIT A[142] [143] L1: SETCACHE 1                          ⍝   Read from local grid server (entry for cache-in-place)[144]     ACTIVATECONNECTION[145]     TRACK '   [READBLOCKC reading ',G,', cached or cache-in-place version]'[146]     H←⊃D[I;D_ COL 'cache']              ⍝   Cached grid name[147]     :if 0=⎕NC 'E'                       ⍝   Read from the grid (pass grid info if we already have it)[148]        Z←∆READBLOCK (⊂H),P[149]     :else[150]        Z←E ∆READBLOCK (⊂H),P[151]     :end[152]  :else                                  ⍝Else, read from grid server[153]     ⎕ERROR (MULTITILE G)/'Error: grid ',G,' is a multitiled ESRI grid - it can''t be read'[154]     SETCACHE 0                          ⍝   turn off reading from local grid server[155]     ACTIVATECONNECTION[156]     TRACK '   [READBLOCKC reading ',G,', uncached]'[157]     Z←∆READBLOCK (⊂G),P                 ⍝   and read the block normally[158]  :end[159]        [160]        [161]  →0[162] [163] [164] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[165] [166] [167] [168]     I←1↑D[;D_ COL 'source'] FINDI G             ⍝   find grid in directory[169]     :if I≠0                                     ⍝   If it's present,[170]        :if D[I;D_ COL 'status'] FIND 'copying'  ⍝      If grid is currently being copied to cache,[171]           :if wait<T←(⎕TS ELAPSED PARSEDATE ⊃D[I;D_ COL 'cachedate'])÷60      ⍝Wait 30 minutes for grid to copy[172]              UNLOCKFILE lock                    ⍝         return lock[173]              CACHEWAIT A[174]              ⎕ERROR 'Error: grid ',G,' cached on ',GETNAME,' has had ''copying'' status for ',(⍕⌊T),' minutes'[175]           :else                                 ⍝         else, wait for copy[176]              :if 1=W←W+1[177]                 ⎕←'--> Waiting for grid ',G,' to be copied to cache (',NOW,')...' ⋄ FLUSH[178]              :end[179]           :end[180]           UNLOCKFILE lock                       ⍝         return lock[181]           CACHEWAIT A[182]           T←⎕DL 30                              ⍝         wait 30 seconds[183]           →L1                                   ⍝         and try again[184]        :end[185]        :if (PARSEDATE ⊃D[I;D_ COL 'sourcedate'])≡PARSEDATE 2⊃V[186]           →L2                           ⍝   If grid date matches cache exactly, we're good to read from cache[187]        :end[188]     :else                               ⍝   else,[189]        D←D⍪0                            ⍝      add to directory[190]        D[I←1↑⍴D;D_ COL 'source']←⊂G[191]     :end[192] [193] ⍝Grid is not cached or not up to date. Add it to the cache.[194]     :if C←(⊂2↑2⊃cache)FIND ⊂2↑G         ⍝   If cache is same drive as source,[195]        D[I←1↑⍴D;D_ COL 'cache']←⊂G      ⍝      cache-in-place[196]        TRACK '   [READBLOCKC caching ',G,' in place]'[197]        →L2[198]     :end[199]     :if 0<Q←(V[1]+U)-S                 ⍝   If we're requesting too much space [overage = (used + grid) - available],[200]        B←(⊂'ready')≡¨D[;D_ COL 'status']                        ⍝      Only 'ready' grids--not 'copying' or 0 (this pending grid) can be deleted[201]        R←⍋↑MEAN¨PARSEDATE¨¨↓¨'/' MATRIFY¨B/D[;D_ COL 'reads']   ⍝      Sort mean read date, oldest to newest[202]        B←B\(1,¯1↓Q>+\(B/D[;D_ COL 'size'])[R])[⍋R]              ⍝      These are the grids to delete from the cache[203]        TRACK '   [READBLOCKC deleting cached grids ',(2↓⊃,/(⊂', '),¨B/D[;D_ COL 'cache']),']'[204]        RDIR¨STRIPPATH¨B/D[;D_ COL 'cache']                      ⍝      Good-bye![205]        D←(~B)⌿D                                                 ⍝      and remove them from the directory[206]        I←1↑D[;D_ COL 'source'] FINDI G                          ⍝      find our row again[207]     :end[208] [209]     H←1+⌈/0,⊃,/⎕FI¨STRIP¨(-1+⍴¨STRIP¨H)↓¨H←D[;D_ COL 'cache']   ⍝   New cache subfolder serial number[210]     1 MAKEDIR STRIPPATH H←(TOLOWER 2⊃cache),(⍕H),'\',STRIP G    ⍝   Target to cached grid; make containing folder[211] [212]     D[I;D_ COL 'cache status cachedate sourcedate']←H 'copying' NOW (2⊃V)     ⍝   Save cached grid location, set status to 'copying' and update cachedate and sourcedate[213]     head←1↓⎕TCHT MTOV D_[214]     D[;D_ COL 'xll yll cellsize']←FMTALL D[;D_ COL 'xll yll cellsize']    ⍝   Format xll, yll, and cellsize with a zillion digits[215]     D TMATOUT (2⊃cache),'gridcache.txt' ⍝   Write directory[216]     UNLOCKFILE lock                     ⍝   Unlock[217]     CACHEWAIT A[218] [219]     TRACK '   [READBLOCKC copying grid ',G,' to cache, ',NOW,']'[220]     SETCACHE 1                          ⍝   use local grid server to copy grid[221]     ACTIVATECONNECTION[222]     G GRIDCOPY H                        ⍝   copy grid to the cache[223]     TRACK '   [READBLOCKC has copied grid ',G,' to cache, ',NOW,']'[224] [225] [226]     D L lock A ← GETCACHEDIR 0          ⍝   Get cache directory   →→→ Holding lock; ⎕ELX will release it ←←←[227]     D D_ ← D                            ⍝   grid cache directory & header[228]     I←D[;D_ COL 'source'] FINDI G       ⍝   find grid in directory[229]     D[I;D_ COL 'status']←⊂'ready'       ⍝   Set status to 'ready'[230]     D[I;D_ COL 'size']←V[1]             ⍝   Set grid size[231]     D[I;D_ COL 'reads']←⊂''[232]     :if 0=⎕NC 'E'                       ⍝   if not passed a grid description,[233]        SETCACHE 1                       ⍝      use local grid server for call to .GRIDDESCRIBE[234]        ACTIVATECONNECTION[235]        E←∆GRIDDESCRIBE G[236]     :end[237]     D[I;D_ COL 'cols rows xll yll cellsize nodata type min max mean std']←11↑E[238] [239] [240] [241] [242] [243] [244] [245] [246] [247] [248] FRAGMENTS:[249] [250]  ⎕ERROR (MULTITILE G)/'Error: grid ',G,' is a multitiled ESRI grid - it can''t be read'[251] [252] [253] [254] [255] [256]     S←cache[3]⌊(U←+/D[;D_ COL 'size'])+(FILEINFO 2⊃cache)[3]-cache[4]   ⍝   Space available for cache (maxsize MIN used + free - minfree)[257]     P[6]←P[6]∨(V[1]×mingrids)>S                ⍝   If (grid×10) is too big to fit in empty cache, we'll suppress caching[258]  :end[259] [260] [261] +++[262] [263] [264] [265] ??? :if L                               ⍝   if we still have the lock,[266]         UNLOCKFILE lock                 ⍝      return it[267]         CACHEWAIT A[268]     :end[269] [270] [271]        XXXXXXXXXXXXX[272]        [273]        [274]     [275]        :if C←(⊂2↑2⊃cache)FIND ⊂2↑G                  ⍝      If cache is same drive as source,[276]           D[I←1↑⍴D;D_ COL 'cache']←⊂G               ⍝         cache-in-place[277]           cacheinplace←1[278]           TRACK '   [READBLOCKC caching ',G,' in place]'[279]        :else                                        ⍝   Else, copy grid[280]           D[I←1↑⍴D;D_ COL 'cache']←⊂G               ⍝         cache-in-place[281] [282] [283] [284] [285]        :end[286]        [287] [288]        [289]        [290]        [291]        [292]        [293]  :end[294] [295] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[296] [297] [298] [299] [300] [301] [302]     ∇