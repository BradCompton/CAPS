    ∇ A SAMPLEGRIDS S;buffer;exclude;loop;test;noread;grids;ffile;tilesize;E;Z;N;X;R;R;tilemapinclude;skiptilemap;I;Q;head;Y;result;mask;maskvalues;samples;G;T;source[1]   ⍝Sample points from a list of grids[2]   ⍝Parameters:[3]   ⍝   source              list of grids to sample[4]   ⍝   mask                mask grid--only sample non-missing cells in mask, or use maskvalue[5]   ⍝   maskvalues          values in mask to sample[6]   ⍝   samples             if >1, number of points to sample per tile--reduce this by % of nodata cells in mask for tile[7]   ⍝                       if ≤1, proportion of each class in maskvalues to sample[8]   ⍝   result              path and name of result file[9]   ⍝   tilesize            size of tiles (in cells)[10]  ⍝   targets = '1:1'     needs to be in parameters.par to run a single thread[11]  ⍝Runs as a CAPS metric, but only uses one thread.  It'll be fastest if you set host = 'w00'.[12]  ⍝B. Compton, 17-19 Jan 2018 (from IEISTATS)[13]  [14]  [15]  [16]   READPARS ME[17]   buffer←4⊃A[18]   exclude←''[19]   loop←test←noread←0 ⋄ grids←0 0⍴''              ⍝Silly junk for BLOCK, etc.[20]   ffile←'SAMPLEGRIDS '[21]   BLOCK (2⍴tilesize),buffer[22]   SETTILE[23]  [24]   tilemapinclude←0[25]   skiptilemap←0                                  ⍝Don't let DEBUG sabotage this[26]   E←TILEMAP '' tilesize 0 0                      ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[27]   G←FRDBL¨↓MATRIFY source[28]   ⎕←'Running SAMPLEGRIDS on ',(⍕+/E),' tiles to sample ',(⍕⍴G),' grids' ⋄ FLUSH[29]   NDROP result[30]  [31]   N←0[32]  L1:→(~E[N←N+1])/L6                              ⍝Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[33]   DOT[34]   BREAKCHECK[35]   X←READ GRIDNAME mask                           ⍝   Read mask grid[36]   :if ~0∊⍴maskvalues                             ⍝   If mask values supplied,[37]      Y←,X∊maskvalues                             ⍝      sample mask values only[38]   :else[39]      Y←,X≠MV                                     ⍝      otherwise, sample any non-missing[40]   :end[41]  [42]   :if samples>1                                  ⍝   if sampling by space,[43]      Q←(+/Y)⌊⌈.5+samples×(+/,X≠MV)÷×/⍴X          ⍝      adjust number of points to sample by amount of landscape in tile (NOT by maskvalues), but not more than available[44]      R←Q?+/Y[45]   :else                                          ⍝   else, sampling by class,[46]      :if 0∊⍴maskvalues                           ⍝      if not stratifying,[47]         R←(⌊.5+samples×+/Y)?+/Y                  ⍝         sample is percentage of nonmissing values[48]      :else                                       ⍝      else,[49]         Q←⌊.5+samples×+⌿(Y/,X)∘.=maskvalues      ⍝         take proportion of each class[50]         R←⍳0[51]         I←0[52]  L2:    →((⍴Q)<I←I+1)/L3                         ⍝         for each maskvalue, get random cells[53]         R←R,((Y/,X=maskvalues[I])/⍳+/Y)[Q[I]?+/Y/,X=maskvalues[I]][54]         →L2[55]  L3:[56]      :end[57]   :end[58]  [59]   Z←((⍴R),1+⍴G)⍴0[60]   head←⊃,/1↓⎕TCHT,¨(⊂mask),G[61]   Z[;1]←(Y/,X)[R]                                ⍝   sample mask grid (usually landcover)[62]   I←0[63]  L4:→((⍴G)<I←I+1)/L5                             ⍝   for each grid,[64]   T←READ GRIDNAME I⊃G                            ⍝      read it[65]   Z[;I+1]←(Y/,T)[R]                              ⍝      and sample it[66]   →L4[67]  [68]  L5:Z TMATAPPEND result[69]  [70]  L6:→(0≠NEXTBLOCK)/L1                            ⍝Until no more tiles[71]  [72]   LOG 'SAMPLEGRIDS is done. Results are in ',result[73]   →0[74]  [75]  [76]  what:auxiliary[77]  type:table[78]  info:('') ('') ('') 0 ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[79]  check:CHECKVAR 'source mask maskvalues samples result tilesize targets'    ∇