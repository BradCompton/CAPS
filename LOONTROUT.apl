    ∇ A LOONTROUT S;source;strata;result;nodata;reverse;integerize;zeropush;retainzeros;includemissing;samples;quantiles;tilesize;targets;value;id;range;acores;resultpath;species;buffer;exclude;loop;test;noread;grids;ffile;tilemapinclude;skiptilemap;E;N;Y;X;L;R;Q;B;area;Z;C;rangeslice;target;U;I;O;transparent;maxlake[1]   ⍝Build loon or brook trout aquatic species cores, continent upon ecosystem cores[2]   ⍝Parameters:[3]   ⍝   value               name of grid with loon LC or brook trout score[4]   ⍝   id                  name of grid with loon pondids or brook trout subbasins[5]   ⍝   acores              name of aquatic ecosystem cores grid[6]   ⍝   range               name of grid to use for loon range[7]   ⍝   rangeslice          value to slice loon range at (use ≥0.25)[8]   ⍝   maxlake             size of largest lake allowed in cores (ha) [use 8094 ha = 20,000 acres][9]   ⍝   species             'loon' or 'trout'[10]  ⍝   resultpath          use z:\LCC\GIS\Final\RCOA\Spring2016\aqspecies\[11]  ⍝   target              proportion of total area to target (use 0.25)[12]  ⍝   tilesize            size of tiles (in cells)[13]  ⍝   buffer              tile buffer to use[14]  ⍝   targets = '1:1'     needs to be in parameters.par to run a single thread[15]  ⍝Runs as a CAPS metric, but only uses one thread.  It'll be fastest if you set host = 'w00'.[16]  ⍝B. Compton, 8-17 Jun 2016 (from QUANTILESCALE)[17]  ⍝21 Jun 2016: use max lake sizes as for ACORES, allow trout in ponds[18]  [19]  [20]  [21]   READPARS ME[22]   buffer←4⊃A[23]   exclude←''[24]   loop←test←noread←0 ⋄ grids←0 0⍴''                  ⍝Silly junk for BLOCK, etc.[25]   ffile←'LOONTROUT '[26]   BLOCK (2⍴tilesize),buffer[27]   SETTILE[28]  [29]   tilemapinclude←0[30]   skiptilemap←0                                      ⍝Don't let DEBUG sabotage this[31]   E←TILEMAP '' tilesize 0 0                          ⍝Get tilemap, building it if necessary. This will only help if there's mask grid.[32]   ⎕←'Running for ',species,' on ',(⍕+/E),' tiles' ⋄ FLUSH[33]   LOG 'LOONTROUT, Pass 1: summarizing tiles'[34]   area←2⍴0                                           ⍝[1] total area in system, [2] area in ecosystem cores[35]   Z←0 4⍴0[36]   [37]   N←0[38]  L1:→(~E[N←N+1])/L2                                  ⍝Repeat: read tile (1st time through tiles), skip if not in tilemap    --- For each tile ---[39]   BREAKCHECK ⋄ DOT[40]   X←READ 1⊃1⊃A                                       ⍝   Read value grid [41]   →(^/,((2⍴buffer)↓(-2⍴buffer)↓X)∊0,MV)/L2           ⍝   If all missing in tile proper, we're done with this tile[42]   Y←0 MVREP READ 2⊃1⊃A                               ⍝   Read id grid[43]   L←READ 3⊃1⊃A                                       ⍝   landcover[44]  [45]   C←MV≠READ 5⊃1⊃A                                    ⍝   and aquatic cores[46]   :if species≡'trout'                                ⍝   If brook trout,[47]      Y←Y×L≠MV                                        ⍝      clip ids to landcover[48]      O←1=READ 6⊃1⊃A                                  ⍝      read orders grid to get headwater streams[49]      L←O^~L∊LOOK 'Lake'                              ⍝      want headwater streams not in lakes[50]      area[1]←area[1]++/,(2⍴buffer)↓(-2⍴buffer)↓L     ⍝      accumulate sum of area in headwater streams (only in tile proper)[51]      area[2]←area[2]++/,(2⍴buffer)↓(-2⍴buffer)↓L^C   ⍝      accumulate sum of area of ecosystem cores in headwater streams[52]      Y←Y×L^~C                                        ⍝      ids only in headwater streams, not lotic ecosystem cores[53]      Q←(,Y≠0)⌿(,Y),[1.5],X[54]      Q←Q[⍋Q[;1];][55]      B←(Q[;1]≠0)^Q[;1]≠¯1↓0,Q[;1][56]      Z←Z⍪N,(B⌿Q),B pSUM (1↑⍴Q)⍴1                     ⍝      Build table: tile #, id, value (all values are the same within each id), area for each id[57]   :else                                              ⍝   Else, loon,[58]      R←rangeslice≤READ 4⊃1⊃A                         ⍝      species range[59]      L←L∊LOOK 'Lentics'                              ⍝      only want lakes[60]      area[1]←area[1]++/,(2⍴buffer)↓(-2⍴buffer)↓L^R   ⍝      accumulate area of lentic (only in tile proper)[61]      area[2]←area[2]++/,(2⍴buffer)↓(-2⍴buffer)↓L^R^C ⍝      accumulate sum of area of ecosystem cores in lentic in range[62]      Y←Y×L^~C                                        ⍝      ids only in lentic, not lentic ecosystem cores[63]      Q←(,Y≠0)⌿(,Y),[1.5],X[64]      Q←Q[⍋Q[;1];][65]      B←(Q[;1]≠0)^Q[;1]≠¯1↓0,Q[;1][66]      Z←Z⍪N,(B/Q[;1]),(B pMAX Q[;2]),[1.5]B pSUM (1↑⍴Q)⍴1⍝      Build table: tile #, id, max value in lake, area for each id[67]   :end[68]  [69]  L2:→(0≠NEXTBLOCK)/L1                                ⍝   Until no more tiles[70]   [71]   Z←Z[⍒Z[;2 4];]                                     ⍝Sort table by id and area, largest 1st[72]   Z←(Z[;2]≠¯1↓0,Z[;2])⌿Z                             ⍝Take largest area for each id to ensure we're getting entire lakes (fails for Lake Champlain, sadly)[73]   :if species≡'loon'                                 ⍝If loon,[74]      Z←(Z[;4]≤maxlake×10000÷cellsize*2)⌿Z            ⍝   Don't allow lakes larger than maxlake ha[75]   :end[76]   Z←Z[⍒Z[;3 4];]                                     ⍝Now sort by value, high to low, and area, just to keep consistent[77]   Z←Z[⍳((+\Z[;4])>0⌈(area[1]×target)-area[2])⍳1;]    ⍝Take enough rows to get 25% of total area not already taken by ecosystem cores[78]  [79]   U←UNIQUE Z[;1][80]   LOG 'LOONTROUT, Pass 2: building ',(⍕1↑⍴Z),' cores for ',(⍕⍴U),' tiles'[81]   BLOCK (2⍴tilesize),buffer[82]   transparent←1[83]  [84]   I←0[85]  L3:→(~(I←I+1)∊U)/L4                                 ⍝For each tile, if there's a core in it,[86]   DOT[87]   Y←READ 2⊃1⊃A                                       ⍝   Read id grid[88]   Y←Y×0≠READ 5⊃1⊃A                                   ⍝   knock out aquatic cores[89]   Y←Y∊Z[;2]                                          ⍝   ids in table are cores[90]   L←READ 3⊃1⊃A                                       ⍝      read landcover[91]   :if species≡'trout'                                ⍝   If brook trout,[92]      Y←MVREP Y (L∊MV)                                ⍝      clip ids to landcover[93]      O←1=READ 6⊃1⊃A                                  ⍝      read orders grid to get headwater streams[94]      Y←Y×O^~L∊LOOK 'Lake'                            ⍝      want headwater streams not in lakes[95]   :else                                              ⍝   Else, loon,[96]      Y←Y×L∊LOOK 'Lentics'                            ⍝      only want lentic[97]   :end[98]   (MVREP Y (Y=0)) WRITEI 3⊃A                         ⍝   write cores[99]  L4:→(0≠NEXTBLOCK)/L3                             [100] [101]  ⎕←''[102]  LOG 'LOONTROUT is done.'[103]  →0[104] [105] [106] what:auxiliary[107] type:table[108] info:(value id 'dslland' range acores 'ordersraw') ('') (resultpath,species,'cores') buffer ''      ⍝Source grid, settings table, result grid, buffer size, and include grid[109] check:CHECKVAR 'value id range rangeslice maxlake result species target tilesize targets buffer'    ∇