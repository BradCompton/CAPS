    ∇ Z←E READBLOCK G;E;C;M;M_;L;R;K;T;I;P;Rx;Ry;Px;Py;ROL;Xr;Yr;O;H;V;Y;F;N;U[1]   ⍝Read block 1↓⍵ from grid 1⊃⍵, potentially using mosaics (and caching); optional griddescribe ⍺[2]   ⍝   ⍵[1]    grid path & name[3]   ⍝   ⍵[2 3]  starting row & column[4]   ⍝   ⍵[4 5]  nrows & ncols[5]   ⍝   ⍵[6]    buffer in cells (default = 0)[6]   ⍝   ⍵[7]    nocache - okay to cache grid? (default = 0)[7]   ⍝B. Compton, 7-10 Oct 2013[8]   ⍝1 Nov 2013: take optional grid describe[9]   ⍝14 Nov 2013: now use FINDCONNECTION, thanks to mosaics + drives[10]  [11]  [12]  [13]   :if 0≠⎕NC'noread'[14]      →noread/1↑⍴Z←0 0⍴''[15]   :end[16]  [17]   G ← 7↑G,0 0[18]   :if 0=⎕NC'E'                       ⍝If grid description wasn't passed,[19]      E←GRIDDESCRIBE 1⊃G              ⍝   Get info[20]   :end[21]   :if ~E[12]                                             ⍝If it's not a mosaic,[22]      ⎕ERROR (MV=C←FINDCONNECTION (5↑E) (1⊃G))/'Error: There is no connection for grid ',TOLOWER 1⊃G[23]      SETCONNECTION C                                     ⍝   Find & set the connection[24]      Z←E READBLOCKC G                                    ⍝   Read the block from a normal (possibly cached) grid[25]      →0[26]   :end                                                   ⍝Else, it's a mosaic,[27]   ⎕ERROR (0=⎕NC'mosaicwindow')/'Error: mosaics not initialized'[28]   ⎕ERROR (0=⍴mosaicwindow)/'Error: mosaics not initialized'[29]   ⎕ERROR (~(5↑E)≡mosaicwindow)/'Error: mosaic grid doesn''t conform to mosaic window'[30]  [31]   M M_ ← MOSAICINFO 1⊃G[32]   ⎕ERROR (∨/M[M_ COL 'rowsize colsize']≠mosaic[mosaic_ COL 'rowsize colsize'])/'Mosaic grid''s rowsize and colsize don''t match the scheme defined by MOSAICINIT'[33]  [34]   L←(E[3]+E[5]×G[3]-1),E[4]+E[5]×E[2]-G[4]+G[2]-1        ⍝Lower left corner (xll, yll) of block we're reading[35]   R←G[5 4],L,E[5]                                        ⍝Extent of result (ncol, nrow, xll, yll, cellsize)[36]   R[⍳4]←R[⍳4]+G[6]×2 2,2⍴-E[5]                           ⍝Expand by buffer[37]   Z←R[2 1]⍴MV                                            ⍝Result grid[38]  [39]   K←N/⍳⍴N←⎕FI((2×⍴N)⍴1 0)\N←⊃M[M_ COL 'panemap'][40]   T←⎕DEF 'Z←A ROL B' OVER 'Z←(A[1]⌈B[1])≤A[2]⌊B[2]'      ⍝Define range overlap function[41]   I←0[42]  L1:→((⍴K)<I←I+1)/0                                      ⍝For each nonempty pane,[43]   P←⊃mosaicwindow PANEWINDOW mosaic[mosaic_ COL 'rowsize colsize'],K[I] ⍝   window of pane[44]  [45]   Rx Ry ← (R CELL2POINT R[2],1),¨R CELL2POINT 1,R[1]     ⍝   x & y ranges of result[46]   Px Py ← (P CELL2POINT P[2],1),¨P CELL2POINT 1,P[1]     ⍝   x & y ranges of pane[47]  [48]   →((~Rx ROL Px)∨~Ry ROL Py)/L1                          ⍝   If no overlap, skip tile[49]  [50]   Xr←(Rx[1]⌈Px[1]),Rx[2]⌊Px[2]                           ⍝   Range of overlaps[51]   Yr←(Ry[1]⌈Py[1]),Ry[2]⌊Py[2][52]  [53]   O←(P POINT2CELL Xr[1],Yr[2]),P POINT2CELL Xr[2],Yr[1]  ⍝   Overlap of pane and result, in cells[54]   O←O[1 2],O[3 4]-O[1 2]-1                               ⍝   starting row, col, nrows, ncols[55]  [56]   SETCONNECTION FINDCONNECTION (-K[I]) (1⊃G)             ⍝   find and set matching connection[57]  [58]   H←⊂PANEPATH G[1],(⊂STRIP⊃M[M_ COL 'name']),K[I],⍴N     ⍝   Path to mosaic pane[59]   F←P,MV,E[7],4⍴MV                                       ⍝   Griddescribe of pane[60]   Y←F READBLOCKC H,O,0,G[7]                              ⍝   Read the block![61]  [62]   U V ← ↓[1]2 2⍴⊃,/(⊂R) POINT2CELL¨(Xr[1],Yr[2]) (Xr[2],Yr[1])  ⍝   Row range, column range[63]   Z[U[1]+0,⍳-/⌽U;V[1]+0,⍳-/⌽V]←Y                         ⍝   Put our values into the result[64]   →L1    ∇