    ∇ R SCRIPT_MEAN G;X;block;loop;test;grids;noread;E;N;tilemapinclude;dot;skiptilemap;ffile;Z;I;Q;mask;buffer;altmask;W;V[1]   ⍝Cell-by-cell addition of grids ⍵, tilesize 2⊃⍺; part of the LCD scripting system[2]   ⍝Arguments:[3]   ⍝   ⍺[1]            name of result grid[4]   ⍝   ⍺[2]            tilesize[5]   ⍝   ⍵[1...n]        names of input grids[6]   ⍝   ⍵[¯1+⍴⍵]        optional vector of grid weights (rescaled to sum to 1)[7]   ⍝   ⍵[⍴⍵]           name of mask grid[8]   ⍝Launched by SCRIPT_LAUNCH[9]   ⍝B. Compton, 18-26 Sep 2014 (from SCRIPT_ADD)[10]  [11]  [12]  [13]   SCRIPTSETUP 'MEAN'                             ⍝Set up and set several local variables[14]   W←(⍴X)⍴1                                       ⍝Equal weights[15]   :if 0=1↑0⍴(⍴X)⊃X                               ⍝If weights are supplied,[16]      W←(⍴X)⊃X                                    ⍝   use these, and drop weights from grid list[17]      X←¯1↓X[18]   :end[19]  L1:→(~E[N←N+1])/L4                              ⍝Repeat: read tile (skip if not in tilemap)    --- For each tile ---[20]   BREAKCHECK ⋄ DOT[21]   Z←V←I←0[22]  L2:→((⍴X)<I←I+1)/L3                             ⍝   For each input grid,[23]   Z←Z+W[I]×0 MVREP Q←READ I⊃X                    ⍝      Read each source grid and add to result weighting appropriately; omit nodata cells[24]   V←V+W[I]×Q≠MV                                  ⍝      sum of weights for each cell[25]   →L2[26]  L3:[27]   Z←Z÷V                                          ⍝   weighted mean, compensating for missing cells[28]   :if ~0∊⍴mask                                   ⍝   If mask grid supplied,[29]      Z←MVREP Z ((READ mask)∊0,MV)                ⍝      read mask & apply it[30]   :end[31]   (MVREP Z (V=0)) WRITE 1⊃R                      ⍝   replace missing and write[32]  L4:→(0≠NEXTBLOCK)/L1                            ⍝Until no more tiles[33]   ⎕←''    ∇